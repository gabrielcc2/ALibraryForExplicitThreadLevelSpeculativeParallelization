        -:    0:Source:/home/gabriel/Escritorio/SPEC_CPU2000_CD_2/benchspec/CFP2000/188.ammp/src/animate.c
        -:    0:Graph:ammp_parallel.gcno
        -:    0:Data:ammp_parallel.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*  animate.c
        -:    2:*
        -:    3:* routines for performing molecular dynamics
        -:    4:*
        -:    5:* v_maxwell( float Temperature, driftx,drifty,driftz)  initialize velocities
        -:    6:*                           with maxwell distribution, assuming
        -:    7:*                           simple kinetic theory relating T and v
        -:    8:*                           driftx,drifty,driftz allow the use of a constant 
        -:    9:*                           drift velocity.
        -:   10:*
        -:   11:* int v_rescale( float Temperature)
        -:   12:*  rescale velocities so that ke is 3RT/2M
        -:   13:*
        -:   14:* int verlet(forces,nforces, nstep,dtime)
        -:   15:*           perform verlet (forward Euler) dynamics
        -:   16:*                           
        -:   17:* int pac( forces,nforces, nstep,dtime)
        -:   18:*            predict and correct dynamics
        -:   19:*
        -:   20:* int pacpac( forces,nforces,nstep,dtime)
        -:   21:*             iterated pac dynamics
        -:   22:*
        -:   23:*
        -:   24:* int tpac( forces,nforces, nstep,dtime, T)
        -:   25:*  nose constrained dynamics
        -:   26:* int ppac( forces,nforces, nstep,dtime, P)
        -:   27:*   pressure only constrained
        -:   28:* int ptpac( forces,nforces, nstep,dtime,P, T)
        -:   29:*   pressure and temperature constrained
        -:   30:* int hpac( forces,nforces, nstep,dtime, H)
        -:   31:*  total energy  constrained dynamics
        -:   32:*/
        -:   33:/*
        -:   34:*  copyright 1992 Robert W. Harrison
        -:   35:*  
        -:   36:*  This notice may not be removed
        -:   37:*  This program may be copied for scientific use
        -:   38:*  It may not be sold for profit without explicit
        -:   39:*  permission of the author(s) who retain any
        -:   40:*  commercial rights including the right to modify 
        -:   41:*  this notice
        -:   42:*/
        -:   43:
        -:   44:#define ANSI 1
        -:   45:/* misc includes - ANSI and some are just to be safe */
        -:   46:#include <stdio.h>
        -:   47:#include <ctype.h>
        -:   48:#include <math.h>
        -:   49:#ifdef ANSI
        -:   50:#include <stdlib.h>
        -:   51:#endif
        -:   52:#include "parallel_loop_in_batches.h"
        -:   53:using namespace std;
        -:   54:
        1:   55:parallel_loop_in_batches parallel_manager;
call    0 returned 100%
call    1 returned 100%
        -:   56:pthread_mutex_t cond_mutex;
        -:   57:
        -:   58://#include "ammp.h"
        -:   59:/* ATOM structure contains a serial number for indexing into
        -:   60:* arrays and the like (a Hessian)
        -:   61:* but otherwise is self-contained. Note the hooks for Non-bonded potentials
        -:   62:*/
        -:   63:
        -:   64:typedef struct {
        -:   65:  float xc,yc,zc;
        -:   66:  float sqp;
        -:   67:  /* dipole appx for r^-6 */
        -:   68:  float sa,xa,ya,za;
        -:   69:  float q100,q010,q001;
        -:   70:  float q200,q020,q002,q110,q101,q011;
        -:   71:  float q300,q030,q003,q210,q201,q120,q021,q102,q012,q111;
        -:   72:#ifdef FOURTH
        -:   73:  float q400,q040,q004,q310,q301,q130,q031,q103,q013,q220,q202,q022,q211,q121,q112;
        -:   74:#endif
        -:   75:#ifdef FIFTH
        -:   76:  float q500,q050,q005,q410,q401,q140,q041,q104,q014,q320,q230,q302,q203,q032,q023,q311,q131,q113,q221,q212,q122;
        -:   77:#endif
        -:   78:  int first,last,innode; } MMNODE;
        -:   79:typedef struct {
        -:   80: ATOM *who;
        -:   81: int next,which; } MMATOM;
        -:   82:
        -:   83:
function _Z9v_maxwellffff called 0 returned 0% blocks executed 0%
    #####:   84:int v_maxwell(float T, float dx, float dy, float dz)
        -:   85:{
        -:   86:	float randg();
        -:   87:	/* void rand3();   SPEC declare proto in ammp.h jh/9/22/99   */
        -:   88:	ATOM *ap,*a_next(int),*bonded[10];
        -:   89:	int iflag,inbond;
        -:   90:	float vmag;
        -:   91:	float R;
    #####:   92:	R = 1.987 ; /* kcal/mol/K */
        -:   93:
    #####:   94:	iflag = -1;
    #####:   95:	while( (ap= a_next(iflag++)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   96:	{
    #####:   97:	iflag = 1;
    #####:   98:	if( ap->mass > 0.)
branch  0 never executed
branch  1 never executed
        -:   99:	{
        -:  100:/* convert from kcal to mks */
        -:  101:/* 4.184 to joules */
        -:  102:/* 1000 grams to kg */
    #####:  103:	vmag = sqrt( 3.*R*T/ap->mass*4.184*1000.)* randg();
call    0 never executed
    #####:  104:	rand3( &ap->vx,&ap->vy,&ap->vz);
call    0 never executed
    #####:  105:	if( ap->active ){
branch  0 never executed
branch  1 never executed
    #####:  106:	ap->vx = ap->vx*vmag + dx;
    #####:  107:	ap->vy = ap->vy*vmag + dy;
    #####:  108:	ap->vz = ap->vz*vmag + dz;
        -:  109:	}else{ 
    #####:  110:	ap->vx = 0.;
    #####:  111:	ap->vy = 0.;
    #####:  112:	ap->vz = 0.;
        -:  113:	}
        -:  114:	}
        -:  115:	}
        -:  116:/* now check those who are zero mass */
        -:  117:/* and give them the velocity of the first bonded atom */
    #####:  118:	iflag = -1;
    #####:  119:	while( (ap= a_next(iflag)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  120:	{
    #####:  121:	iflag = 1;
    #####:  122:		if( ap->mass <= 0.)
branch  0 never executed
branch  1 never executed
        -:  123:		{
    #####:  124:		get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  125:			if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  126:			{
    #####:  127:			ap->vx = bonded[0]->vx;
    #####:  128:			ap->vy = bonded[0]->vy;
    #####:  129:			ap->vz = bonded[0]->vz;
        -:  130:			}
        -:  131:		}
        -:  132:	}
    #####:  133:	return 1;
        -:  134:}
        -:  135:/* v_rescale(T)
        -:  136:*  rescale the velocities for constant KE  == Temperature 
        -:  137:*/
function _Z9v_rescalef called 0 returned 0% blocks executed 0%
    #####:  138:int v_rescale(float T)
        -:  139:{
        -:  140:	ATOM *ap,*a_next(int);
        -:  141:	int iflag,a_number();
        -:  142:	float vmag,KE,target;
        -:  143:	float R;
    #####:  144:	R = 1.987 ; /* kcal/mol/K */
        -:  145:
    #####:  146:	target = 0.;
    #####:  147:	target += .5*(3.*R*T)*4.184*1000*a_number();
call    0 never executed
    #####:  148:	KE = 0.; 
    #####:  149:	iflag = -1;
    #####:  150:	while( (ap= a_next(iflag++)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  151:	{
    #####:  152:	iflag = 1;
    #####:  153:	if( ap->mass > 0.)
branch  0 never executed
branch  1 never executed
        -:  154:	{
    #####:  155:	vmag = ap->vx*ap->vx+ap->vy*ap->vy+ap->vz*ap->vz;
    #####:  156:	KE += ap->mass*vmag;	
        -:  157:	}}
    #####:  158:	KE = KE *.5;
    #####:  159:	if( KE == 0.)
branch  0 never executed
branch  1 never executed
    #####:  160:	{ aaerror(" Cannot rescale a zero velocity field -use v_maxwell");
call    0 never executed
    #####:  161:		return 0;
        -:  162:		}
    #####:  163:	vmag = sqrt(target/KE);
        -:  164:
    #####:  165:	iflag = -1;
    #####:  166:	while( (ap= a_next(iflag++)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  167:	{
    #####:  168:	iflag = 1;
    #####:  169:	ap->vx = ap->vx*vmag;
    #####:  170:	ap->vy = ap->vy*vmag;
    #####:  171:	ap->vz = ap->vz*vmag;
        -:  172:	}
    #####:  173:	return 1;
        -:  174:}
        -:  175:/* routine verlet( nstep,dtime)
        -:  176:*int verlet(forces,nforces, nstep,dtime)
        -:  177:*
        -:  178:* perform nstep leapfrogging dynamics with dtime
        -:  179:*/
function _Z6verletPPFifEiif called 0 returned 0% blocks executed 0%
    #####:  180:int verlet(int (*forces[])(float), int nforces, int nstep, float dtime)
        -:  181:{
        -:  182:	ATOM *bp,*ap,*a_next(int),*bonded[10];
        -:  183:	int inbond,iflag;
        -:  184:	int a_f_zero(),a_inc_v(float);
        -:  185:	int istep,iforces;
        -:  186:	int i,imax,a_number();
    #####:  187:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  188:	{
        -:  189:
        -:  190:/*  find the force at the midpoint */
    #####:  191:	a_f_zero();
call    0 never executed
    #####:  192:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  193:		(*forces[iforces])( 0.);
call    0 never executed
        -:  194:/* update velocities */        
    #####:  195:	imax = a_number();
call    0 never executed
    #####:  196:	ap = a_next(-1);
call    0 never executed
    #####:  197:	bp = ap;
    #####:  198:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  199:	{
    #####:  200:	bp = a_next(1);
call    0 never executed
    #####:  201:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  202:	{
        -:  203:/* the magic number takes kcal/molA to mks */
    #####:  204:		ap->vx += ap->fx/ap->mass*dtime*4.184e6;
    #####:  205:		ap->vy += ap->fy/ap->mass*dtime*4.184e6;
    #####:  206:		ap->vz += ap->fz/ap->mass*dtime*4.184e6;
        -:  207:	}
        -:  208:	}
    #####:  209:	imax = a_number();
call    0 never executed
    #####:  210:	ap = a_next(-1);
call    0 never executed
    #####:  211:	bp = ap;
    #####:  212:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  213:	{
    #####:  214:	bp = a_next(1);
call    0 never executed
    #####:  215:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  216:		{
    #####:  217:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  218:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  219:                        {
    #####:  220:                        ap->vx = bonded[0]->vx;
    #####:  221:                        ap->vy = bonded[0]->vy;
    #####:  222:                        ap->vz = bonded[0]->vz;
        -:  223:                        }
        -:  224:		}
        -:  225:	}
        -:  226:/* update positions */
    #####:  227:	a_inc_v(dtime);
call    0 never executed
        -:  228:	}/* end of istep loop */
    #####:  229:	return 1;
        -:  230:}
        -:  231:/* routine pac( nstep,dtime)
        -:  232:*int pac(forces,nforces, nstep,dtime)
        -:  233:*
        -:  234:* perform nstep pac dynamics with dtime
        -:  235:*
        -:  236:* predict the path given current velocity
        -:  237:* integrate the force (simpson's rule)
        -:  238:*  predict the final velocity
        -:  239:*  update the position using trapezoidal correction
        -:  240:*  
        -:  241:*  ideally several cycles are good
        -:  242:*/
function _Z3pacPPFifEiif called 0 returned 0% blocks executed 0%
    #####:  243:int pac(int (*forces[])(float), int nforces, int nstep, float dtime)
        -:  244:{
        -:  245:	ATOM *ap,*bp,*a_next(int),*bonded[10];
        -:  246:	int inbond,iflag;
        -:  247:	int a_f_zero(),a_inc_v(float);
        -:  248:	int istep,iforces;
        -:  249:	int i,imax,a_number();
    #####:  250:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  251:	{
        -:  252:
        -:  253:/*  move the velocity vector into the displacment slot */
    #####:  254:	imax = a_number();
call    0 never executed
    #####:  255:	ap = a_next(-1);
call    0 never executed
    #####:  256:	bp = ap;
    #####:  257:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  258:	{
    #####:  259:	bp = a_next(1);
call    0 never executed
    #####:  260:	ap->dx = ap->vx;
    #####:  261:	ap->dy = ap->vy;
    #####:  262:	ap->dz = ap->vz;
        -:  263:	}
        -:  264:
        -:  265:/*  find the force at the midpoint */
    #####:  266:	a_f_zero();
call    0 never executed
    #####:  267:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  268:		(*forces[iforces])( dtime/2.);
call    0 never executed
        -:  269:/* update velocities */        
    #####:  270:	imax = a_number();
call    0 never executed
    #####:  271:	ap = a_next(-1);
call    0 never executed
    #####:  272:	bp = ap;
    #####:  273:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  274:	{
    #####:  275:	bp = a_next(1);
call    0 never executed
    #####:  276:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  277:	{
        -:  278:/* the magic number takes kcal/molA to mks */
        -:  279:/*		ap->vx += ap->fx/ap->mass*dtime*4.184e6/6.;
        -:  280:*		ap->vy += ap->fy/ap->mass*dtime*4.184e6/6.;
        -:  281:*		ap->vz += ap->fz/ap->mass*dtime*4.184e6/6.;
        -:  282:*/
    #####:  283:		ap->vx =  ap->dx +  ap->fx/ap->mass*dtime*4.184e6;
    #####:  284:		ap->vy = ap->dy  + ap->fy/ap->mass*dtime*4.184e6;
    #####:  285:		ap->vz = ap->dz  + ap->fz/ap->mass*dtime*4.184e6;
        -:  286:	}
        -:  287:	}
    #####:  288:	imax = a_number();
call    0 never executed
    #####:  289:	ap = a_next(-1);
call    0 never executed
    #####:  290:	bp = ap;
    #####:  291:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  292:	{
    #####:  293:	bp = a_next(1);
call    0 never executed
    #####:  294:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  295:		{
    #####:  296:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  297:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  298:                        {
    #####:  299:                        ap->vx = bonded[0]->vx;
    #####:  300:                        ap->vy = bonded[0]->vy;
    #####:  301:                        ap->vz = bonded[0]->vz;
        -:  302:                        }
        -:  303:		}
        -:  304:	}
        -:  305:/* update positions */
    #####:  306:	imax = a_number();
call    0 never executed
    #####:  307:	ap = a_next(-1);
call    0 never executed
    #####:  308:	bp = ap;
    #####:  309:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  310:	{
    #####:  311:	bp = a_next(1);
call    0 never executed
    #####:  312:		iflag = 1;
    #####:  313:		ap->x += .5*(ap->vx + ap->dx)*dtime;
    #####:  314:		ap->y += .5*(ap->vy + ap->dy)*dtime;
    #####:  315:		ap->z += .5*(ap->vz + ap->dz)*dtime;
        -:  316:	}
        -:  317:		
        -:  318:	}/* end of istep loop */
    #####:  319:	return 1;
        -:  320:}
        -:  321:/* routine tpac( nstep,dtime)
        -:  322:*int tpac(forces,nforces, nstep,dtime,T)
        -:  323:*
        -:  324:* perform nstep pac dynamics with dtime
        -:  325:* kinetic energy constraint to (3*natom-1) kT/2
        -:  326:*
        -:  327:* predict the path given current velocity
        -:  328:* integrate the force (simpson's rule)
        -:  329:*  predict the final velocity
        -:  330:*  update the position using trapezoidal correction
        -:  331:*  
        -:  332:*  ideally several cycles are good
        -:  333:*
        -:  334:* adaptive steps (6/19/96)
        -:  335:*  if the rescale is too large (i.e. > 2) do two half steps
        -:  336:*
        -:  337:*/
function _Z4tpacPPFifEiiff called 3 returned 100% blocks executed 90%
        3:  338:int tpac(int (*forces[])(float), int nforces, int nstep, float dtime_real, float T)
        -:  339:{
        -:  340:	ATOM *ap,*bp,*a_next(int),*bonded[10];
        -:  341:	float ke,Tke,R;
        -:  342:	float alpha;
        -:  343:	float dtime;
        -:  344:	int inbond,iflag;
        -:  345:	int a_f_zero(),a_inc_v(float);
        -:  346:	int istep,iforces;
        -:  347:	int i,imax,a_number();
        3:  348:	R = 1.987; /* kcal/mol/K */
        -:  349:
     1002:  350:	for( istep = 0.; istep< nstep; istep++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  351:	{
        -:  352:
        -:  353:/*  move the velocity vector into the displacment slot */
      999:  354:	ke = 0.;
      999:  355:	imax = a_number();
call    0 returned 100%
      999:  356:	ap = a_next(-1);
call    0 returned 100%
      999:  357:	bp = ap;
  9573417:  358:	for( i=0; i< imax; i++,ap = bp)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  359:	{
  9572418:  360:	bp = a_next(1);
call    0 returned 100%
        -:  361:	ke += ap->mass*(
  9572418:  362:	ap->vx*ap->vx + ap->vy*ap->vy + ap->vz*ap->vz);
  9572418:  363:	ap->dx = ap->vx;
  9572418:  364:	ap->dy = ap->vy;
  9572418:  365:	ap->dz = ap->vz;
        -:  366:	}
      999:  367:	Tke = 3*(imax)*R*4.184*1000;  /* converted into MKS */
      999:  368:	Tke = ke/Tke;  /* Tke is now the current temperature */ 
        -:  369:/* scale the current velocities */
      999:  370:	dtime = dtime_real;
      999:  371:	if( Tke > 1.e-6)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  372:	{	
      999:  373:	ke = sqrt(T/Tke); /* ke is the scaled shift value */
      999:  374:	dtime = dtime_real/ke;
        -:  375:/* 0.00002 is 2fs, this is near the limit so don't use it */
      999:  376:	if( dtime > 0.000020 ){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  377:		tpac(forces,nforces,1,dtime_real*0.5,T); 
call    0 never executed
    #####:  378:		tpac(forces,nforces,1,dtime_real*0.5,T); 
call    0 never executed
        -:  379:		//goto SKIP;
        -:  380:			}
      999:  381:	ap = a_next(-1);
call    0 returned 100%
      999:  382:	bp =  ap;
  9573417:  383:	for( i=0; i< imax;  i++, ap = bp)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  384:	{
  9572418:  385:	bp = a_next(1);
call    0 returned 100%
  9572418:  386:	ap->dx *= ke;
  9572418:  387:	ap->dy *= ke;
  9572418:  388:	ap->dz *= ke;
        -:  389:	}
        -:  390:	}
        -:  391:
        -:  392:/*  find the force at the midpoint */
      999:  393:	a_f_zero();
call    0 returned 100%
        -:  394:
        -:  395://	parallel_mm_fv_update.run(input_functions, input_vars);
        -:  396:  //      parallel_mm_fv_update.commit();
     6993:  397:	for( iforces=0;iforces<nforces; iforces++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
     5994:  398:		(*forces[iforces])( dtime/2.); //Esta es la invocación que consume la mayor parte del tiempo.
call    0 returned 100%
        -:  399:	//parallel_mm_fv_update.get_results();
        -:  400:/* update velocities */        
      999:  401:	imax = a_number();
call    0 returned 100%
      999:  402:	ap = a_next(-1);
call    0 returned 100%
      999:  403:	bp = ap;
  9573417:  404:	for( i=0; i< imax; i++,ap = bp)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  405:	{
  9572418:  406:	bp = a_next(1);
call    0 returned 100%
  9572418:  407:	if( ap->mass > 0.) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  408:	{
  9572418:  409:		ap->vx = ap->dx  + ap->fx/ap->mass*dtime*4.184e6;
  9572418:  410:		ap->vy = ap->dy  + ap->fy/ap->mass*dtime*4.184e6;
  9572418:  411:		ap->vz = ap->dz  + ap->fz/ap->mass*dtime*4.184e6;
        -:  412:	}
        -:  413:	}
      999:  414:	imax = a_number();
call    0 returned 100%
      999:  415:	ap = a_next(-1);
call    0 returned 100%
      999:  416:	bp = ap;
  9573417:  417:	for( i=0; i< imax; i++,ap = bp)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  418:	{
  9572418:  419:	bp = a_next(1);
call    0 returned 100%
  9572418:  420:	if( ap->mass <= 0.) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  421:		{
    #####:  422:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  423:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  424:                        {
    #####:  425:                        ap->vx = bonded[0]->vx;
    #####:  426:                        ap->vy = bonded[0]->vy;
    #####:  427:                        ap->vz = bonded[0]->vz;
        -:  428:                        }
        -:  429:		}
        -:  430:	}
        -:  431:/* update positions */
      999:  432:	imax = a_number();
call    0 returned 100%
      999:  433:	ap = a_next(-1);
call    0 returned 100%
      999:  434:	bp = ap;
  9573417:  435:	for( i=0; i< imax; i++,ap = bp)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  436:	{
  9572418:  437:	bp = a_next(1);
call    0 returned 100%
  9572418:  438:		iflag = 1;
  9572418:  439:		ap->x += .5*(ap->vx + ap->dx)*dtime;
  9572418:  440:		ap->y += .5*(ap->vy + ap->dy)*dtime;
  9572418:  441:		ap->z += .5*(ap->vz + ap->dz)*dtime;
        -:  442:	}
        -:  443:SKIP: ; /* if we are here from goto we have done two half steps (or more)*/
        -:  444:		
        -:  445:	}/* end of istep loop */
        3:  446:	return 1;
        -:  447:}
        -:  448:/* routine pacpac( nstep,dtime)
        -:  449:*int pacpac(forces,nforces, nstep,dtime)
        -:  450:*
        -:  451:* perform nstep pac dynamics with dtime
        -:  452:*
        -:  453:* predict the path given current velocity
        -:  454:* integrate the force (simpson's rule)
        -:  455:*  predict the final velocity
        -:  456:*  update the position using trapezoidal correction
        -:  457:*  
        -:  458:*  ideally several cycles are good
        -:  459:*/
function _Z6pacpacPPFifEiif called 0 returned 0% blocks executed 0%
    #####:  460:int pacpac(int (*forces[])(float), int nforces, int nstep, float dtime)
        -:  461:{
        -:  462:	ATOM *ap,*a_next(int),*bp,*bonded[10];
        -:  463:	int inbond,iflag;
        -:  464:	int a_f_zero(),a_inc_v(float);
        -:  465:	int istep,iforces,icorrect;
        -:  466:	int i,imax,a_number();
    #####:  467:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:
        -:  470:/*  move the velocity vector into the displacment slot */
    #####:  471:	iflag = -1;
    #####:  472:	while( (ap=a_next(iflag)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  473:	{
    #####:  474:	iflag = 1;
    #####:  475:	ap->dx = ap->vx;
    #####:  476:	ap->dy = ap->vy;
    #####:  477:	ap->dz = ap->vz;
        -:  478:	}
        -:  479:
        -:  480:/*  find the force at the midpoint */
    #####:  481:	a_f_zero();
call    0 never executed
    #####:  482:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  483:		(*forces[iforces])( dtime/2.);
call    0 never executed
        -:  484:/* update velocities */        
    #####:  485:	iflag = -1;
    #####:  486:	while( (ap=a_next(iflag)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  487:	{
    #####:  488:	iflag = 1;
    #####:  489:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  490:	{
        -:  491:/* the magic number takes kcal/molA to mks */
    #####:  492:		ap->gx = ap->vx;	
    #####:  493:		ap->gy = ap->vy;	
    #####:  494:		ap->gz = ap->vz;	
    #####:  495:		ap->vx += ap->fx/ap->mass*dtime*4.184e6;
    #####:  496:		ap->vy += ap->fy/ap->mass*dtime*4.184e6;
    #####:  497:		ap->vz += ap->fz/ap->mass*dtime*4.184e6;
        -:  498:	}
        -:  499:	}
    #####:  500:	iflag = -1;
    #####:  501:	while( (ap=a_next(iflag)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  502:	{
    #####:  503:	iflag = 1;
    #####:  504:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  505:		{
    #####:  506:		ap->gx = ap->vx;	
    #####:  507:		ap->gy = ap->vy;	
    #####:  508:		ap->gz = ap->vz;	
    #####:  509:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  510:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  511:                        {
    #####:  512:                        ap->vx = bonded[0]->vx;
    #####:  513:                        ap->vy = bonded[0]->vy;
    #####:  514:                        ap->vz = bonded[0]->vz;
        -:  515:                        }
        -:  516:		} /* end of mass check */
        -:  517:	}
        -:  518:/* make up the new prediction direction */
    #####:  519:	imax = a_number();
call    0 never executed
    #####:  520:	ap = a_next(-1);
call    0 never executed
    #####:  521:	bp = ap;
    #####:  522:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  523:	{
    #####:  524:		bp = a_next(1);
call    0 never executed
    #####:  525:		ap->dx = ap->vx + ap->gx;
    #####:  526:		ap->dy = ap->vy + ap->gy;
    #####:  527:		ap->dz = ap->vz + ap->gz;
        -:  528:	}
    #####:  529:	for( icorrect = 0;icorrect < 2; icorrect ++)
branch  0 never executed
branch  1 never executed
        -:  530:	{
    #####:  531:	a_f_zero();
call    0 never executed
    #####:  532:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  533:		(*forces[iforces])( dtime/4.);
call    0 never executed
        -:  534:/* update velocities */        
    #####:  535:	imax = a_number();
call    0 never executed
    #####:  536:	ap = a_next(-1);
call    0 never executed
    #####:  537:	bp = ap;
    #####:  538:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  539:	{
    #####:  540:	bp = a_next(1);
call    0 never executed
    #####:  541:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  542:	{
        -:  543:/* the magic number takes kcal/molA to mks */
    #####:  544:		ap->vx = ap->gx + ap->fx/ap->mass*dtime*4.184e6;
    #####:  545:		ap->vy = ap->gy + ap->fy/ap->mass*dtime*4.184e6;
    #####:  546:		ap->vz = ap->gz + ap->fz/ap->mass*dtime*4.184e6;
        -:  547:	}
        -:  548:	}
    #####:  549:	imax = a_number();
call    0 never executed
    #####:  550:	ap = a_next(-1);
call    0 never executed
    #####:  551:	bp = ap;
    #####:  552:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  553:	{
    #####:  554:	bp = a_next(1);
call    0 never executed
    #####:  555:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  556:		{
    #####:  557:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  558:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  559:                        {
    #####:  560:                        ap->vx = bonded[0]->vx;
    #####:  561:                        ap->vy = bonded[0]->vy;
    #####:  562:                        ap->vz = bonded[0]->vz;
        -:  563:                        }
        -:  564:		} /* end of mass check */
        -:  565:	}
        -:  566:/* make up the new prediction direction */
    #####:  567:	imax = a_number();
call    0 never executed
    #####:  568:	ap = a_next(-1);
call    0 never executed
    #####:  569:	bp = ap;
    #####:  570:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  571:	{
    #####:  572:	bp = a_next(1);
call    0 never executed
    #####:  573:		ap->dx = ap->vx + ap->gx;
    #####:  574:		ap->dy = ap->vy + ap->gy;
    #####:  575:		ap->dz = ap->vz + ap->gz;
        -:  576:	}
        -:  577:	}
        -:  578:/* update positions */
    #####:  579:	imax = a_number();
call    0 never executed
    #####:  580:	ap = a_next(-1);
call    0 never executed
    #####:  581:	bp = ap;
    #####:  582:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  583:	{
    #####:  584:	bp = a_next(1);
call    0 never executed
    #####:  585:		ap->x += .5*(ap->vx + ap->gx)*dtime;
    #####:  586:		ap->y += .5*(ap->vy + ap->gy)*dtime;
    #####:  587:		ap->z += .5*(ap->vz + ap->gz)*dtime;
        -:  588:	}
        -:  589:		
        -:  590:	}/* end of istep loop */
    #####:  591:	return 1;
        -:  592:}
        -:  593:/* routine hpac( nstep,dtime)
        -:  594:*int hpac(forces,nforces, nstep,dtime,H)
        -:  595:*
        -:  596:* perform nstep pac dynamics with dtime
        -:  597:* kinetic energy adusted for constant H
        -:  598:*
        -:  599:* predict the path given current velocity
        -:  600:* integrate the force (simpson's rule)
        -:  601:*  predict the final velocity
        -:  602:*  update the position using trapezoidal correction
        -:  603:*  
        -:  604:*  ideally several cycles are good
        -:  605:*/
function _Z4hpacPPFifEPPFiPffEiiff called 0 returned 0% blocks executed 0%
    #####:  606:int hpac(int (*forces[])(float), int (*poten[])(float*, float), int nforces, int nstep, float dtime_real, float H)
        -:  607:{
        -:  608:	ATOM *ap,*bp,*a_next(int),*bonded[10];
        -:  609:	float ke,Tke;
        -:  610:	float alpha;
        -:  611:	float dtime;
        -:  612:	int inbond,iflag;
        -:  613:	int a_f_zero(),a_inc_v(float);
        -:  614:	int istep,iforces;
        -:  615:	int i,imax,a_number();
        -:  616:
        -:  617:
    #####:  618:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  619:	{
        -:  620:
        -:  621:/*  move the velocity vector into the displacment slot */
    #####:  622:	ke = 0.;
    #####:  623:	imax = a_number();
call    0 never executed
    #####:  624:	ap = a_next(-1);
call    0 never executed
    #####:  625:	bp = ap;
    #####:  626:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  627:	{
    #####:  628:	bp = a_next(1);
call    0 never executed
        -:  629:	ke += ap->mass*(
    #####:  630:	ap->vx*ap->vx + ap->vy*ap->vy + ap->vz*ap->vz);
    #####:  631:	ap->dx = ap->vx;
    #####:  632:	ap->dy = ap->vy;
    #####:  633:	ap->dz = ap->vz;
        -:  634:	}
    #####:  635:	ke = ke*.5/4.184/1000/1000;  /* ke in kcal/mol */
        -:  636:/* get the current potential */
    #####:  637:	Tke = 0.;
    #####:  638:	for(i=0; i< nforces; i++)
branch  0 never executed
branch  1 never executed
    #####:  639:		(*poten[i])(&Tke,0.);
call    0 never executed
        -:  640:/* scale the current velocities */
    #####:  641:	dtime = dtime_real;
    #####:  642:	if( Tke < H )
branch  0 never executed
branch  1 never executed
        -:  643:	{	
    #####:  644:	ke = sqrt((H-Tke)/ke); /* ke is the scaled shift value */
    #####:  645:	dtime = dtime_real/ke;
        -:  646:/* 0.00002 is 2fs, this is near the limit so don't use it */
    #####:  647:	if( dtime > 0.000020 ){
branch  0 never executed
branch  1 never executed
        -:  648:                /* SPEC: fix # of arguments - jh/9/21/99 */
    #####:  649:		hpac(forces,poten,nforces,1,dtime_real*0.5,H); 
call    0 never executed
    #####:  650:		hpac(forces,poten,nforces,1,dtime_real*0.5,H); 
call    0 never executed
    #####:  651:		goto SKIP;
        -:  652:			}
    #####:  653:	ap = a_next(-1);
call    0 never executed
    #####:  654:	bp =  ap;
    #####:  655:	for( i=0; i< imax;  i++, ap = bp)
branch  0 never executed
branch  1 never executed
        -:  656:	{
    #####:  657:	bp = a_next(1);
call    0 never executed
    #####:  658:	ap->dx *= ke;
    #####:  659:	ap->dy *= ke;
    #####:  660:	ap->dz *= ke;
        -:  661:	}
        -:  662:	} else { 
    #####:  663:	aaerror("Warning in Hpac, Potential energy higher than target\n");
call    0 never executed
    #####:  664:	a_v_zero();
call    0 never executed
    #####:  665:	a_d_zero();
call    0 never executed
        -:  666:	}
        -:  667:
        -:  668:/*  find the force at the midpoint */
    #####:  669:	a_f_zero();
call    0 never executed
    #####:  670:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  671:		(*forces[iforces])( dtime/2.);
call    0 never executed
        -:  672:/* update velocities */        
    #####:  673:	imax = a_number();
call    0 never executed
    #####:  674:	ap = a_next(-1);
call    0 never executed
    #####:  675:	bp = ap;
    #####:  676:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  677:	{
    #####:  678:	bp = a_next(1);
call    0 never executed
    #####:  679:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  680:	{
    #####:  681:		ap->vx = ap->dx  + ap->fx/ap->mass*dtime*4.184e6;
    #####:  682:		ap->vy = ap->dy  + ap->fy/ap->mass*dtime*4.184e6;
    #####:  683:		ap->vz = ap->dz  + ap->fz/ap->mass*dtime*4.184e6;
        -:  684:	}
        -:  685:	}
    #####:  686:	imax = a_number();
call    0 never executed
    #####:  687:	ap = a_next(-1);
call    0 never executed
    #####:  688:	bp = ap;
    #####:  689:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  690:	{
    #####:  691:	bp = a_next(1);
call    0 never executed
    #####:  692:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  693:		{
    #####:  694:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  695:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  696:                        {
    #####:  697:                        ap->vx = bonded[0]->vx;
    #####:  698:                        ap->vy = bonded[0]->vy;
    #####:  699:                        ap->vz = bonded[0]->vz;
        -:  700:                        }
        -:  701:		}
        -:  702:	}
        -:  703:/* update positions */
    #####:  704:	imax = a_number();
call    0 never executed
    #####:  705:	ap = a_next(-1);
call    0 never executed
    #####:  706:	bp = ap;
    #####:  707:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  708:	{
    #####:  709:	bp = a_next(1);
call    0 never executed
    #####:  710:		iflag = 1;
    #####:  711:		ap->x += .5*(ap->vx + ap->dx)*dtime;
    #####:  712:		ap->y += .5*(ap->vy + ap->dy)*dtime;
    #####:  713:		ap->z += .5*(ap->vz + ap->dz)*dtime;
        -:  714:	}
        -:  715:SKIP: ; /* if goto here we've had too large a step and used half steps */
        -:  716:		
        -:  717:	}/* end of istep loop */
    #####:  718:	return 1;
        -:  719:}
        -:  720:/* routine ppac( nstep,dtime)
        -:  721:*int ppac(forces,nforces, nstep,dtime,P)
        -:  722:*
        -:  723:* force the pressure to be constant
        -:  724:* use P = integral ( f . r )dV as 	
        -:  725:* the basis for a diffeomorphism
        -:  726:*   P => kP or Integral( kf.r)dV
        -:  727:*         to enforce pressure
        -:  728:*   r => r/k to enforce physical reality
        -:  729:*   may need to damp this.
        -:  730:*  
        -:  731:*
        -:  732:* perform nstep pac dynamics with dtime
        -:  733:*
        -:  734:* predict the path given current velocity
        -:  735:* integrate the force (simpson's rule)
        -:  736:*  predict the final velocity
        -:  737:*  update the position using trapezoidal correction
        -:  738:*  
        -:  739:*  ideally several cycles are good
        -:  740:*/
function _Z4ppacPPFifEiiff called 0 returned 0% blocks executed 0%
    #####:  741:int ppac(int (*forces[])(float), int nforces, int nstep, float dtime_real, float P)
        -:  742:{
        -:  743:	ATOM *ap,*bp,*a_next(int),*bonded[10];
        -:  744:	float p,Tp,R;
        -:  745:	float dtime,cx,cy,cz;
        -:  746:	float alpha;
        -:  747:	int inbond,iflag;
        -:  748:	int a_f_zero(),a_inc_v(float);
        -:  749:	int istep,iforces;
        -:  750:	int i,imax,a_number();
    #####:  751:	R = 1.987; /* kcal/mol/K */
        -:  752:
    #####:  753:	imax = a_number();
call    0 never executed
    #####:  754:	if( imax <= 0 )return 0;
branch  0 never executed
branch  1 never executed
    #####:  755:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  756:	{
        -:  757:
    #####:  758:	cx = 0.; cy = 0.; cz = 0.;	
        -:  759:/*  move the velocity vector into the displacment slot */
    #####:  760:	ap = a_next(-1);
call    0 never executed
    #####:  761:	bp = ap;
    #####:  762:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  763:	{
    #####:  764:	bp = a_next(1);
call    0 never executed
    #####:  765:	ap->dx = ap->vx;
    #####:  766:	ap->dy = ap->vy;
    #####:  767:	ap->dz = ap->vz;
    #####:  768:	cx += ap->x;
    #####:  769:	cy += ap->y;
    #####:  770:	cz += ap->z;
        -:  771:	}
    #####:  772:	cx /= imax;
    #####:  773:	cy /= imax;
    #####:  774:	cz /= imax;
        -:  775:
        -:  776:/* calculate the pressure */
        -:  777:
    #####:  778:	p = 0.;
    #####:  779:	Tp = 0.;
    #####:  780:	ap = a_next(-1);
call    0 never executed
    #####:  781:	bp = ap;
    #####:  782:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  783:	{
    #####:  784:		bp = a_next(1);
call    0 never executed
    #####:  785:		p += ap->vx*ap->vx*ap->mass;
    #####:  786:		p += ap->vy*ap->vy*ap->mass;
    #####:  787:		p += ap->vz*ap->vz*ap->mass;
    #####:  788:		Tp += (ap->x-cx)*(ap->x-cx);
    #####:  789:		Tp += (ap->y-cy)*(ap->y-cy);
    #####:  790:		Tp += (ap->z-cz)*(ap->z-cz);
        -:  791:	}
    #####:  792:	Tp = sqrt(Tp/imax);
    #####:  793:	Tp = 4*PI/3*Tp*Tp*Tp;
    #####:  794:  	p = p/imax/Tp*.5; /* now mks molar */
    #####:  795:	printf("P %f p %f Tp %f\n",P,p,Tp);
        -:  796:/* moment shift
        -:  797:	p = sqrt( P/p);
        -:  798:	dtime = dtime_real/p;
        -:  799:*/
    #####:  800:	dtime = dtime_real;
        -:  801:/* this is about the steepest volume correction which works !! 
        -:  802:  1. + .2/1.2 and 1 + .5/1.5 fail
        -:  803:*/
    #####:  804:	p = (1.+.1*pow( p/P, 1./3.))/1.1;
        -:  805:	
        -:  806:/* temporary kludge to understand problem */
    #####:  807:	ap = a_next(-1);
call    0 never executed
    #####:  808:	bp = ap;
    #####:  809:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  810:	{
    #####:  811:		bp = a_next(1);
call    0 never executed
        -:  812:/*
        -:  813:		ap->vx *= p;	
        -:  814:		ap->vy *= p;	
        -:  815:		ap->vz *= p;	
        -:  816:		ap->dx *= p;	
        -:  817:		ap->dy *= p;	
        -:  818:		ap->dz *= p;	
        -:  819:*/
        -:  820:
    #####:  821:		ap->x *= p;
    #####:  822:		ap->y *= p;
    #####:  823:		ap->z *= p;
        -:  824:	}
        -:  825:/*  find the force at the midpoint */
    #####:  826:	a_f_zero();
call    0 never executed
    #####:  827:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  828:		(*forces[iforces])( dtime/2.);
call    0 never executed
        -:  829:
        -:  830:/* update velocities */        
    #####:  831:	imax = a_number();
call    0 never executed
    #####:  832:	ap = a_next(-1);
call    0 never executed
    #####:  833:	bp = ap;
    #####:  834:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  835:	{
    #####:  836:	bp = a_next(1);
call    0 never executed
    #####:  837:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  838:	{
    #####:  839:		ap->vx = ap->dx  + ap->fx/ap->mass*dtime*4.184e6;
    #####:  840:		ap->vy = ap->dy  + ap->fy/ap->mass*dtime*4.184e6;
    #####:  841:		ap->vz = ap->dz  + ap->fz/ap->mass*dtime*4.184e6;
        -:  842:	}
        -:  843:	}
    #####:  844:	imax = a_number();
call    0 never executed
    #####:  845:	ap = a_next(-1);
call    0 never executed
    #####:  846:	bp = ap;
    #####:  847:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  848:	{
    #####:  849:	bp = a_next(1);
call    0 never executed
    #####:  850:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -:  851:		{
    #####:  852:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####:  853:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -:  854:                        {
    #####:  855:                        ap->vx = bonded[0]->vx;
    #####:  856:                        ap->vy = bonded[0]->vy;
    #####:  857:                        ap->vz = bonded[0]->vz;
        -:  858:                        }
        -:  859:		}
        -:  860:	}
        -:  861:/* update positions */
    #####:  862:	imax = a_number();
call    0 never executed
    #####:  863:	ap = a_next(-1);
call    0 never executed
    #####:  864:	bp = ap;
    #####:  865:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  866:	{
    #####:  867:	bp = a_next(1);
call    0 never executed
    #####:  868:		iflag = 1;
    #####:  869:		ap->x += .5*(ap->vx + ap->dx)*dtime;
    #####:  870:		ap->y += .5*(ap->vy + ap->dy)*dtime;
    #####:  871:		ap->z += .5*(ap->vz + ap->dz)*dtime;
        -:  872:	}
        -:  873:		
        -:  874:	}/* end of istep loop */
    #####:  875:	return 1;
        -:  876:}
        -:  877:/* routine ptpac( nstep,dtime)
        -:  878:*int ptpac(forces,nforces, nstep,dtime,P,T)
        -:  879:*
        -:  880:* force the pressure to be constant
        -:  881:*  
        -:  882:*
        -:  883:* perform nstep pac dynamics with dtime
        -:  884:*
        -:  885:* predict the path given current velocity
        -:  886:* integrate the force (simpson's rule)
        -:  887:*  predict the final velocity
        -:  888:*  update the position using trapezoidal correction
        -:  889:*  
        -:  890:*  ideally several cycles are good
        -:  891:*/
function _Z5ptpacPPFifEiifff called 0 returned 0% blocks executed 0%
    #####:  892:int ptpac(int (*forces[])(float), int nforces, int nstep, float dtime_real, float P, float T)
        -:  893:{
        -:  894:	ATOM *ap,*bp,*a_next(int),*bonded[10];
        -:  895:	float p,Tp,R;
        -:  896:	float Tk;
        -:  897:	float dtime,cx,cy,cz;
        -:  898:	float alpha;
        -:  899:	int inbond,iflag;
        -:  900:	int a_f_zero(),a_inc_v(float);
        -:  901:	int istep,iforces;
        -:  902:	int i,imax,a_number();
    #####:  903:	R = 1.987; /* kcal/mol/K */
        -:  904:
    #####:  905:	imax = a_number();
call    0 never executed
    #####:  906:	if( imax <= 0 )return 0;
branch  0 never executed
branch  1 never executed
    #####:  907:	for( istep = 0.; istep< nstep; istep++)
branch  0 never executed
branch  1 never executed
        -:  908:	{
        -:  909:
    #####:  910:	cx = 0.; cy = 0.; cz = 0.;	
        -:  911:/*  move the velocity vector into the displacment slot */
    #####:  912:	ap = a_next(-1);
call    0 never executed
    #####:  913:	bp = ap;
    #####:  914:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  915:	{
    #####:  916:	bp = a_next(1);
call    0 never executed
    #####:  917:	ap->dx = ap->vx;
    #####:  918:	ap->dy = ap->vy;
    #####:  919:	ap->dz = ap->vz;
    #####:  920:	cx += ap->x;
    #####:  921:	cy += ap->y;
    #####:  922:	cz += ap->z;
        -:  923:	}
    #####:  924:	cx /= imax;
    #####:  925:	cy /= imax;
    #####:  926:	cz /= imax;
        -:  927:
        -:  928:/* calculate the pressure */
        -:  929:
    #####:  930:	p = 0.;
    #####:  931:	Tp = 0.;
    #####:  932:	ap = a_next(-1);
call    0 never executed
    #####:  933:	bp = ap;
    #####:  934:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  935:	{
    #####:  936:		bp = a_next(1);
call    0 never executed
    #####:  937:		p += ap->vx*ap->vx*ap->mass;
    #####:  938:		p += ap->vy*ap->vy*ap->mass;
    #####:  939:		p += ap->vz*ap->vz*ap->mass;
    #####:  940:		Tp += (ap->x-cx)*(ap->x-cx);
    #####:  941:		Tp += (ap->y-cy)*(ap->y-cy);
    #####:  942:		Tp += (ap->z-cz)*(ap->z-cz);
        -:  943:	}
    #####:  944:	Tp = sqrt(Tp/imax);
    #####:  945:	Tp = 4*PI/3*Tp*Tp*Tp;
    #####:  946:	Tk = 3*imax*R*4.184*1000;
    #####:  947:	Tk = p/Tk;  /* Tk is now the temperature */
    #####:  948:	if( Tk < 1.e-5) Tk = 1.;
branch  0 never executed
branch  1 never executed
    #####:  949:  	p = p/imax/Tp*.5; /* now mks molar  ( kilopascal's because of grams)*/
    #####:  950:	printf("P %f p %f Tp %f\n",P,p,Tp);
        -:  951:/* momentum shift */
    #####:  952:	Tk = sqrt(T/Tk);
    #####:  953:	dtime = dtime_real/Tk;
        -:  954:/* 0.00002 is 2fs, this is near the limit so don't use it */
    #####:  955:	if( dtime > 0.000020 ){
branch  0 never executed
branch  1 never executed
    #####:  956:		ptpac(forces,nforces,1,dtime_real*0.5,P,T); 
call    0 never executed
    #####:  957:		ptpac(forces,nforces,1,dtime_real*0.5,P,T); 
call    0 never executed
    #####:  958:		goto SKIP;
        -:  959:			}
        -:  960:/* this is about the steepest volume correction which works !! 
        -:  961:  1. + .2/1.2 and 1 + .5/1.5 fail
        -:  962:also checked that the current 'pressure' is the best to use
        -:  963:for stable running  
        -:  964:*/
    #####:  965:	p = (1.+.1*pow( p/P, 1./3.))/1.1;
        -:  966:	
        -:  967:/* temporary kludge to understand problem */
    #####:  968:	ap = a_next(-1);
call    0 never executed
    #####:  969:	bp = ap;
    #####:  970:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  971:	{
    #####:  972:		bp = a_next(1);
call    0 never executed
    #####:  973:		ap->vx *= Tk;	
    #####:  974:		ap->vy *= Tk;	
    #####:  975:		ap->vz *= Tk;	
    #####:  976:		ap->dx *= Tk;	
    #####:  977:		ap->dy *= Tk;	
    #####:  978:		ap->dz *= Tk;	
        -:  979:
    #####:  980:		ap->x *= p;
    #####:  981:		ap->y *= p;
    #####:  982:		ap->z *= p;
        -:  983:	}
        -:  984:/*  find the force at the midpoint */
    #####:  985:	a_f_zero();
call    0 never executed
    #####:  986:	for( iforces=0;iforces<nforces; iforces++)
branch  0 never executed
branch  1 never executed
    #####:  987:		(*forces[iforces])( dtime/2.);
call    0 never executed
        -:  988:
        -:  989:/* update velocities */        
    #####:  990:	imax = a_number();
call    0 never executed
    #####:  991:	ap = a_next(-1);
call    0 never executed
    #####:  992:	bp = ap;
    #####:  993:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -:  994:	{
    #####:  995:	bp = a_next(1);
call    0 never executed
    #####:  996:	if( ap->mass > 0.) 
branch  0 never executed
branch  1 never executed
        -:  997:	{
    #####:  998:		ap->vx = ap->dx  + ap->fx/ap->mass*dtime*4.184e6;
    #####:  999:		ap->vy = ap->dy  + ap->fy/ap->mass*dtime*4.184e6;
    #####: 1000:		ap->vz = ap->dz  + ap->fz/ap->mass*dtime*4.184e6;
        -: 1001:	}
        -: 1002:	}
    #####: 1003:	imax = a_number();
call    0 never executed
    #####: 1004:	ap = a_next(-1);
call    0 never executed
    #####: 1005:	bp = ap;
    #####: 1006:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -: 1007:	{
    #####: 1008:	bp = a_next(1);
call    0 never executed
    #####: 1009:	if( ap->mass <= 0.) 
branch  0 never executed
branch  1 never executed
        -: 1010:		{
    #####: 1011:                get_bond(ap,bonded,10,&inbond);
call    0 never executed
    #####: 1012:                        if( inbond >= 0)
branch  0 never executed
branch  1 never executed
        -: 1013:                        {
    #####: 1014:                        ap->vx = bonded[0]->vx;
    #####: 1015:                        ap->vy = bonded[0]->vy;
    #####: 1016:                        ap->vz = bonded[0]->vz;
        -: 1017:                        }
        -: 1018:		}
        -: 1019:	}
        -: 1020:/* update positions */
    #####: 1021:	imax = a_number();
call    0 never executed
    #####: 1022:	ap = a_next(-1);
call    0 never executed
    #####: 1023:	bp = ap;
    #####: 1024:	for( i=0; i< imax; i++,ap = bp)
branch  0 never executed
branch  1 never executed
        -: 1025:	{
    #####: 1026:	bp = a_next(1);
call    0 never executed
    #####: 1027:		iflag = 1;
    #####: 1028:		ap->x += .5*(ap->vx + ap->dx)*dtime;
    #####: 1029:		ap->y += .5*(ap->vy + ap->dy)*dtime;
    #####: 1030:		ap->z += .5*(ap->vz + ap->dz)*dtime;
        -: 1031:	}
        -: 1032:		
        -: 1033:SKIP: ; /* if goto here we've had too large a step and used half steps */
        -: 1034:	}/* end of istep loop */
    #####: 1035:	return 1;
        -: 1036:}
        -: 1037:
        -: 1038:
        -: 1039:
        -: 1040:/* rectmm.c
        -: 1041:*
        -: 1042:* integrated multipole method with the amortized
        -: 1043:* standard nonbonded program.
        -: 1044:*  rectangular multipole expansion to the r^-6 order (5th order expansion)
        -: 1045:*
        -: 1046:*  from Eyges "The Classical Electromagnetic Field"
        -: 1047:*  note that we use the oposite convention for sign of
        -: 1048:*  expansion so use + for all the cumulants, while he uses
        -: 1049:*   -1^n.   This is solely due to choice of origin and for
        -: 1050:*   other applications (rxn feild ) the -1^n is correct.
        -: 1051:*
        -: 1052:*
        -: 1053:* collection of routines to service nonbonded potentials
        -: 1054:*
        -: 1055:* POOP (Poor-mans Object Oriented Programming) using scope rules
        -: 1056:*
        -: 1057:* the routines for potential value, force and (eventually) second
        -: 1058:* derivatives are here also
        -: 1059:*
        -: 1060:* force and 2nd derivative routines assume zero'd arrays for output
        -: 1061:* this allows for parralellization if needed (on a PC?)
        -: 1062:*
        -: 1063:* forces are symmetric - so we don't have to mess around with
        -: 1064:* s matrices and the like.
        -: 1065:*
        -: 1066:* note that the non-bonded information is in the ATOM structures 
        -: 1067:*
        -: 1068:*
        -: 1069:* attempts at vectorization
        -: 1070:*/
        -: 1071:/*
        -: 1072:*  copyright 1992, 1993, 1994, 1995 Robert W. Harrison
        -: 1073:*  
        -: 1074:*  This notice may not be removed
        -: 1075:*  This program may be copied for scientific use
        -: 1076:*  It may not be sold for profit without explicit
        -: 1077:*  permission of the author(s) who retain any
        -: 1078:*  commercial rights including the right to modify 
        -: 1079:*  this notice
        -: 1080:*/
        -: 1081:/* ATOM structure contains a serial number for indexing into
        -: 1082:* arrays and the like (a Hessian)
        -: 1083:* but otherwise is self-contained. Note the hooks for Non-nonboned potentials
        -: 1084:*/
        -: 1085:
        -: 1086:/*
        -: 1087:#define FOURTH
        -: 1088:#define  FIFTH
        -: 1089:#ifdef FIFTH
        -: 1090:#define FOURTH
        -: 1091:#endif
        -: 1092:*/
        -: 1093:
function _Z19mm_fv_update_nonbonf called 0 returned 0% blocks executed 0%
    #####: 1094:int mm_fv_update_nonbon(float lambda)
        -: 1095:{
        -: 1096:	float r,r0,xt,yt,zt;
        -: 1097:	float xt2,xt3,xt4,yt2,yt3,yt4,zt2,zt3,zt4;
        -: 1098:	float k,k1,k2,k3,k4,k5;
        -: 1099:	float ka2,ka3;
        -: 1100:	float kb2,kb3;
        -: 1101:	float c1,c2,c3,c4,c5; /* constants for the mm expansion */
        -: 1102:	float get_f_variable(char*);
        -: 1103:	int inbond,inangle,i;
        -: 1104:	ATOM *ap,*a1,*a2,*bonded[10],*angled[10];
        -: 1105:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 1106:	int a_number();
        -: 1107:	int ii,j,jj,imax,inclose;
        -: 1108:	float (*vector)[];
        -: 1109:/* */
        -: 1110:	ATOM *close[NCLOSE],*(*atomall)[];
        -: 1111:	float mxdq,dielectric,mxcut; 
        -: 1112:	float mmbox;
        -: 1113:	float xmax,xmin,ymax,ymin,zmax,zmin;
        -: 1114:	int nx,ny,nz;
        -: 1115:	int ix,iy,iz,inode;
        -: 1116:	int naybor[27];
        -: 1117:	char line[80];
        -: 1118:	MMNODE (*nodelist)[];
        -: 1119:	MMATOM (*atomlist)[];
        -: 1120:
        -: 1121:
    #####: 1122:	mmbox = get_f_variable("mmbox");
call    0 never executed
    #####: 1123:	mxcut = get_f_variable("mxcut");
call    0 never executed
    #####: 1124:	if( mxcut < 0.) mxcut= 5.;
branch  0 never executed
branch  1 never executed
        -: 1125:
    #####: 1126:	dielectric = get_f_variable("dielec");
call    0 never executed
    #####: 1127:	if( dielectric <= 0.) dielectric = 1.;
branch  0 never executed
branch  1 never executed
    #####: 1128:	dielectric = 332.17752/dielectric;
        -: 1129:	
        -: 1130:/*  get the number of atoms and allocate the memory for the array space */
    #####: 1131:	i = a_number();
call    0 never executed
    #####: 1132:	vector = (float (*)[])  malloc( 4*i*sizeof(float) );
    #####: 1133:	if( vector == NULL) 
branch  0 never executed
branch  1 never executed
    #####: 1134:	{ aaerror("cannot allocate memory in mm_fv_update\n"); return 0;}
call    0 never executed
    #####: 1135:	atomall = (ATOM*(*)[]) malloc( i*sizeof(ATOM *) );
    #####: 1136:	if( atomall == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1137:	{aaerror("cannot allocate memory in mm_fv_update\n"); return 0;}
call    0 never executed
    #####: 1138:	atomlist = (MMATOM (*)[]) malloc( i * sizeof( MMATOM ));
    #####: 1139:	if( atomlist == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1140:	{ aaerror("cannot allocate memory in mm_fv_update\n"); return 0;}
call    0 never executed
        -: 1141:
    #####: 1142:	imax = a_number();
call    0 never executed
    #####: 1143:	jj = imax;
        -: 1144:
    #####: 1145:	for( i=0; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 1146:	{
    #####: 1147:		(*atomall)[i] = a_next(i);
call    0 never executed
    #####: 1148:		(*atomlist)[i].who = (*atomall)[i];
        -: 1149:	}
        -: 1150:/* first check if anyone's moved and update the lists */
        -: 1151:/* note that this must be a look-ahead rather than
        -: 1152:*  look back search because
        -: 1153:* we cannot update ->px until we've used that atom !!! */
    #####: 1154:	for( ii=0; ii< imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 1155:	{
    #####: 1156:        a1 = (*atomall)[ii];
    #####: 1157:	j = ii*4;
    #####: 1158:        (*vector)[j] = a1->dx*lambda +a1->x ;
    #####: 1159:        (*vector)[j+1] = a1->dy*lambda +a1->y;
    #####: 1160:        (*vector)[j+2] = a1->dz*lambda +a1->z;
        -: 1161:	}
        -: 1162:/* determine the bounds of box which surrounds all of the atoms */
    #####: 1163:	xmax = -10e10;
    #####: 1164:	ymax = -10e10;
    #####: 1165:	zmax = -10e10;
    #####: 1166:	xmin =  10e10;
    #####: 1167:	ymin =  10e10;
    #####: 1168:	zmin =  10e10;
    #####: 1169:	for( ii= 0; ii< imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 1170:	{
    #####: 1171:		j = ii*4;
    #####: 1172:	  if( xmax < (*vector)[j] ) xmax = (*vector)[j];
branch  0 never executed
branch  1 never executed
    #####: 1173:	  if( ymax < (*vector)[j+1] ) ymax = (*vector)[j+1];
branch  0 never executed
branch  1 never executed
    #####: 1174:	  if( zmax < (*vector)[j+2] ) zmax = (*vector)[j+2];
branch  0 never executed
branch  1 never executed
    #####: 1175:	  if( xmin > (*vector)[j] ) xmin = (*vector)[j];
branch  0 never executed
branch  1 never executed
    #####: 1176:	  if( ymin > (*vector)[j+1] ) ymin = (*vector)[j+1];
branch  0 never executed
branch  1 never executed
    #####: 1177:	  if( zmin > (*vector)[j+2] ) zmin = (*vector)[j+2];
branch  0 never executed
branch  1 never executed
        -: 1178:	  }
    #####: 1179:	nx = (xmax - xmin)/mmbox + 1 ;
    #####: 1180:	ny = (ymax - ymin)/mmbox + 1 ;
    #####: 1181:	nz = (zmax - zmin)/mmbox + 1 ;
        -: 1182:
        -: 1183:/* DEBUG	
        -: 1184:	sprintf(line,"before allocation mmbox %f nx %d ny %d nz %d \n",mmbox,nx,ny,nz);
        -: 1185:	aaerror( line);
        -: 1186:	sprintf(line," xmin xmax %f %f ymin ymax %f %f zmin zmax %f %f\n",
        -: 1187:	xmin,xmax,ymin,ymax,zmin,zmax);
        -: 1188:	aaerror( line);
        -: 1189:end of DEBUG */
        -: 1190:
        -: 1191:/* now try to malloc the mmnodes */
    #####: 1192:	nodelist = (MMNODE (*)[]) malloc( nx*ny*nz * sizeof( MMNODE ));
    #####: 1193:	if( nodelist == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1194:	{ aaerror("cannot allocate node memory in mm_fv_update (doubling grid )\n"); 
call    0 never executed
    #####: 1195:	sprintf(line,"mmbox %f nx %d ny %d nz %d ",mmbox,nx,ny,nz);
    #####: 1196:	aaerror( line);
call    0 never executed
        -: 1197:	sprintf(line," xmin xmax %f %f ymin ymax %f %f zmin zmax %f %f",
    #####: 1198:	xmin,xmax,ymin,ymax,zmin,zmax);
    #####: 1199:	aaerror( line);
call    0 never executed
    #####: 1200:	mmbox = mmbox *2;
    #####: 1201:	set_f_variable( "mmbox",mmbox);
call    0 never executed
    #####: 1202:	nx = (xmax - xmin)/mmbox + 1;
    #####: 1203:	ny = (ymax - ymin)/mmbox + 1;
    #####: 1204:	nz = (zmax - zmin)/mmbox + 1;
    #####: 1205:	nodelist = (MMNODE(*)[])malloc( nx*ny*nz * sizeof( MMNODE ));
    #####: 1206:	if( nodelist == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1207:	{ aaerror("cannot allocate node memory in mm_fv_update (cannot do it)\n"); return 0; }
call    0 never executed
        -: 1208:	}
    #####: 1209:	for( ix=0; ix< nx; ix++)
branch  0 never executed
branch  1 never executed
    #####: 1210:	for( iy=0; iy< ny; iy++)
branch  0 never executed
branch  1 never executed
    #####: 1211:	for( iz=0; iz< nz; iz++)
branch  0 never executed
branch  1 never executed
        -: 1212:	{
    #####: 1213:	inode = ((iz*ny)+iy)*nx + ix;
    #####: 1214:	(*nodelist)[inode].xc = ix*mmbox + .5*mmbox + xmin;
    #####: 1215:	(*nodelist)[inode].yc = iy*mmbox + .5*mmbox + ymin;
    #####: 1216:	(*nodelist)[inode].zc = iz*mmbox + .5*mmbox + zmin;
        -: 1217:	}
    #####: 1218:	for( ii=0; ii < nx*ny*nz; ii++)
branch  0 never executed
branch  1 never executed
        -: 1219:	{
    #####: 1220:	(*nodelist)[ii].sqp = 0.;
    #####: 1221:	(*nodelist)[ii].sa = 0.;
    #####: 1222:	(*nodelist)[ii].xa = 0.;
    #####: 1223:	(*nodelist)[ii].ya = 0.;
    #####: 1224:	(*nodelist)[ii].za = 0.;
    #####: 1225:	(*nodelist)[ii].q100 = 0.;
    #####: 1226:	(*nodelist)[ii].q010 = 0.;
    #####: 1227:	(*nodelist)[ii].q001 = 0.;
    #####: 1228:	(*nodelist)[ii].q200 = 0.;
    #####: 1229:	(*nodelist)[ii].q020 = 0.;
    #####: 1230:	(*nodelist)[ii].q002 = 0.;
    #####: 1231:	(*nodelist)[ii].q101 = 0.;
    #####: 1232:	(*nodelist)[ii].q110 = 0.;
    #####: 1233:	(*nodelist)[ii].q011 = 0.;
    #####: 1234:	(*nodelist)[ii].q300 = 0.;
    #####: 1235:	(*nodelist)[ii].q030 = 0.;
    #####: 1236:	(*nodelist)[ii].q003 = 0.;
    #####: 1237:	(*nodelist)[ii].q210 = 0.;
    #####: 1238:	(*nodelist)[ii].q120 = 0.;
    #####: 1239:	(*nodelist)[ii].q201 = 0.;
    #####: 1240:	(*nodelist)[ii].q102 = 0.;
    #####: 1241:	(*nodelist)[ii].q021 = 0.;
    #####: 1242:	(*nodelist)[ii].q012 = 0.;
    #####: 1243:	(*nodelist)[ii].q111 = 0.;
        -: 1244:#ifdef FOURTH
        -: 1245:	(*nodelist)[ii].q400 = 0.;
        -: 1246:	(*nodelist)[ii].q040 = 0.;
        -: 1247:	(*nodelist)[ii].q004 = 0.;
        -: 1248:	(*nodelist)[ii].q310 = 0.;
        -: 1249:	(*nodelist)[ii].q130 = 0.;
        -: 1250:	(*nodelist)[ii].q301 = 0.;
        -: 1251:	(*nodelist)[ii].q103 = 0.;
        -: 1252:	(*nodelist)[ii].q031 = 0.;
        -: 1253:	(*nodelist)[ii].q013 = 0.;
        -: 1254:	(*nodelist)[ii].q220 = 0.;
        -: 1255:	(*nodelist)[ii].q202 = 0.;
        -: 1256:	(*nodelist)[ii].q022 = 0.;
        -: 1257:	(*nodelist)[ii].q211 = 0.;
        -: 1258:	(*nodelist)[ii].q121 = 0.;
        -: 1259:	(*nodelist)[ii].q112 = 0.;
        -: 1260:#endif
        -: 1261:#ifdef FIFTH
        -: 1262:	(*nodelist)[ii].q500 = 0.;
        -: 1263:	(*nodelist)[ii].q050 = 0.;
        -: 1264:	(*nodelist)[ii].q005 = 0.;
        -: 1265:	(*nodelist)[ii].q410 = 0.;
        -: 1266:	(*nodelist)[ii].q140 = 0.;
        -: 1267:	(*nodelist)[ii].q401 = 0.;
        -: 1268:	(*nodelist)[ii].q104 = 0.;
        -: 1269:	(*nodelist)[ii].q041 = 0.;
        -: 1270:	(*nodelist)[ii].q014 = 0.;
        -: 1271:	(*nodelist)[ii].q320 = 0.;
        -: 1272:	(*nodelist)[ii].q230 = 0.;
        -: 1273:	(*nodelist)[ii].q302 = 0.;
        -: 1274:	(*nodelist)[ii].q203 = 0.;
        -: 1275:	(*nodelist)[ii].q032 = 0.;
        -: 1276:	(*nodelist)[ii].q023 = 0.;
        -: 1277:	(*nodelist)[ii].q221 = 0.;
        -: 1278:	(*nodelist)[ii].q212 = 0.;
        -: 1279:	(*nodelist)[ii].q122 = 0.;
        -: 1280:	(*nodelist)[ii].q311 = 0.;
        -: 1281:	(*nodelist)[ii].q131 = 0.;
        -: 1282:	(*nodelist)[ii].q113 = 0.;
        -: 1283:#endif
    #####: 1284:	(*nodelist)[ii].first = -1;
    #####: 1285:	(*nodelist)[ii].last = -1;
    #####: 1286:	(*nodelist)[ii].innode = 0;
        -: 1287:	}
        -: 1288:/* now decide for each atom who he belongs to */	
    #####: 1289:	for( ii=0; ii< imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 1290:	{
    #####: 1291:	j = ii*4;
    #####: 1292:	ix = ((*vector)[j] - xmin )/mmbox;
    #####: 1293:	iy = ((*vector)[j+1] - ymin )/mmbox;
    #####: 1294:	iz = ((*vector)[j+2] - zmin )/mmbox;
    #####: 1295:	inode = ((iz*ny)+iy)*nx + ix;
    #####: 1296:	(*atomlist)[ii].which = inode;
        -: 1297:/* DEBUG
        -: 1298:	printf(" error %f %f %f %d %d %d %d\n",
        -: 1299:		(*vector)[j],(*vector)[j+1],(*vector)[j+2],ix,iy,iz,inode);
        -: 1300:
        -: 1301:ENDDEBUG */
        -: 1302:	}
        -: 1303:/* and generate the links */ 
    #####: 1304:	for( inode = 0; inode < nx*ny*nz; inode++)
branch  0 never executed
branch  1 never executed
        -: 1305:	{
        -: 1306:	/* first find the first atom which belongs to me */
    #####: 1307:	for( ii = 0; ii< imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 1308:	{
    #####: 1309:		if( (*atomlist)[ii].which == inode)
branch  0 never executed
branch  1 never executed
        -: 1310:		{
    #####: 1311:		(*nodelist)[inode].first = ii;
    #####: 1312:		(*nodelist)[inode].last = ii;
    #####: 1313:		(*nodelist)[inode].innode += 1;
    #####: 1314:		ap = (*atomlist)[ii].who;
    #####: 1315:		break;
        -: 1316:		}
        -: 1317:	}
        -: 1318:	/* only if i'm not null */
    #####: 1319:	if( ii != imax )
branch  0 never executed
branch  1 never executed
        -: 1320:	{
    #####: 1321:	for( ii= (*nodelist)[inode].first; ii < imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 1322:	{
    #####: 1323:		if( (*atomlist)[ii].which == inode)
branch  0 never executed
branch  1 never executed
        -: 1324:		{
    #####: 1325:		(*atomlist)[(*nodelist)[inode].last].next  = ii;
    #####: 1326:		(*nodelist)[inode].last = ii;
    #####: 1327:		(*nodelist)[inode].innode += 1;
    #####: 1328:		ap = (*atomlist)[ii].who;
    #####: 1329:		xt = ap->x + lambda*ap->dx - (*nodelist)[inode].xc;
    #####: 1330:		yt = ap->y + lambda*ap->dy - (*nodelist)[inode].yc;
    #####: 1331:		zt = ap->z + lambda*ap->dz - (*nodelist)[inode].zc;
    #####: 1332:		(*nodelist)[inode].sqp +=  ap->q;
    #####: 1333:		(*nodelist)[inode].sa +=  ap->a;
    #####: 1334:		(*nodelist)[inode].xa +=  ap->a*xt;
    #####: 1335:		(*nodelist)[inode].ya +=  ap->a*yt;
    #####: 1336:		(*nodelist)[inode].za +=  ap->a*zt;
    #####: 1337:		xt2 = xt*xt;
    #####: 1338:		xt3 = xt2*xt;
    #####: 1339:		xt4 = xt3*xt;
    #####: 1340:		yt2 = yt*yt;
    #####: 1341:		yt3 = yt2*yt;
    #####: 1342:		yt4 = yt3*yt;
    #####: 1343:		zt2 = zt*zt;
    #####: 1344:		zt3 = zt2*zt;
    #####: 1345:		zt4 = zt3*zt;
    #####: 1346:	(*nodelist)[inode].q100 += ap->q*xt;
    #####: 1347:	(*nodelist)[inode].q010 += ap->q*yt;
    #####: 1348:	(*nodelist)[inode].q001 += ap->q*zt;
    #####: 1349:	(*nodelist)[inode].q200 += ap->q*xt2;
    #####: 1350:	(*nodelist)[inode].q020 += ap->q*yt2;
    #####: 1351:	(*nodelist)[inode].q002 += ap->q*zt2;
    #####: 1352:	(*nodelist)[inode].q101 += ap->q*xt*zt;
    #####: 1353:	(*nodelist)[inode].q110 += ap->q*xt*yt;
    #####: 1354:	(*nodelist)[inode].q011 += ap->q*yt*zt;
    #####: 1355:	(*nodelist)[inode].q300 += ap->q*xt3;
    #####: 1356:	(*nodelist)[inode].q030 += ap->q*yt3;
    #####: 1357:	(*nodelist)[inode].q003 += ap->q*zt3;
    #####: 1358:	(*nodelist)[inode].q210 += ap->q*xt2*yt;
    #####: 1359:	(*nodelist)[inode].q120 += ap->q*xt*yt2;
    #####: 1360:	(*nodelist)[inode].q201 += ap->q*xt2*zt;
    #####: 1361:	(*nodelist)[inode].q102 += ap->q*xt*zt2;
    #####: 1362:	(*nodelist)[inode].q021 += ap->q*yt2*zt;
    #####: 1363:	(*nodelist)[inode].q012 += ap->q*yt*zt2;
    #####: 1364:	(*nodelist)[inode].q111 += ap->q*xt*yt*zt;
        -: 1365:#ifdef FOURTH
        -: 1366:	(*nodelist)[inode].q400 += ap->q*xt4;
        -: 1367:	(*nodelist)[inode].q040 += ap->q*yt4;
        -: 1368:	(*nodelist)[inode].q004 += ap->q*zt4;
        -: 1369:	(*nodelist)[inode].q310 += ap->q*xt3*yt;
        -: 1370:	(*nodelist)[inode].q130 += ap->q*xt*yt3;
        -: 1371:	(*nodelist)[inode].q301 += ap->q*xt3*zt;
        -: 1372:	(*nodelist)[inode].q103 += ap->q*xt*zt3;
        -: 1373:	(*nodelist)[inode].q031 += ap->q*yt3*zt;
        -: 1374:	(*nodelist)[inode].q013 += ap->q*yt*zt3;
        -: 1375:	(*nodelist)[inode].q220 += ap->q*xt2*yt2;
        -: 1376:	(*nodelist)[inode].q202 += ap->q*xt2*zt2;
        -: 1377:	(*nodelist)[inode].q022 += ap->q*yt2*zt2;
        -: 1378:	(*nodelist)[inode].q211 += ap->q*xt2*yt*zt;
        -: 1379:	(*nodelist)[inode].q121 += ap->q*xt*yt2*zt;
        -: 1380:	(*nodelist)[inode].q112 += ap->q*xt*yt*zt2;
        -: 1381:#endif
        -: 1382:#ifdef FIFTH
        -: 1383:	(*nodelist)[inode].q500 += ap->q*xt4*xt;
        -: 1384:	(*nodelist)[inode].q050 += ap->q*yt4*yt;
        -: 1385:	(*nodelist)[inode].q005 += ap->q*zt4*zt;
        -: 1386:	(*nodelist)[inode].q410 += ap->q*xt4*yt;
        -: 1387:	(*nodelist)[inode].q140 += ap->q*yt4*xt;
        -: 1388:	(*nodelist)[inode].q401 += ap->q*xt4*zt;
        -: 1389:	(*nodelist)[inode].q104 += ap->q*zt4*xt;
        -: 1390:	(*nodelist)[inode].q041 += ap->q*yt4*zt;
        -: 1391:	(*nodelist)[inode].q014 += ap->q*zt4*yt;
        -: 1392:	(*nodelist)[inode].q320 += ap->q*xt3*yt2;
        -: 1393:	(*nodelist)[inode].q230 += ap->q*yt3*xt2;
        -: 1394:	(*nodelist)[inode].q302 += ap->q*xt3*zt2;
        -: 1395:	(*nodelist)[inode].q203 += ap->q*zt3*xt2;
        -: 1396:	(*nodelist)[inode].q032 += ap->q*yt3*zt2;
        -: 1397:	(*nodelist)[inode].q023 += ap->q*zt3*yt2;
        -: 1398:	(*nodelist)[inode].q221 += ap->q*xt2*yt2*zt;
        -: 1399:	(*nodelist)[inode].q212 += ap->q*xt2*yt*zt2;
        -: 1400:	(*nodelist)[inode].q122 += ap->q*xt*yt2*zt2;
        -: 1401:	(*nodelist)[inode].q311 += ap->q*xt3*yt*zt;
        -: 1402:	(*nodelist)[inode].q131 += ap->q*xt*yt3*zt;
        -: 1403:	(*nodelist)[inode].q113 += ap->q*xt*yt*zt3;
        -: 1404:#endif
        -: 1405:		}
        -: 1406:	}/* ii */
        -: 1407:	}/* checking if ii != imax */
        -: 1408:	}/* inode */
        -: 1409:/* and now (almost done with the MM setup)
        -: 1410:* normalize the accumulated nodal data */
        -: 1411:	/* multiplied by .5 to correct for double counting */
    #####: 1412:	k = dielectric *.5;
    #####: 1413:	xt = .5/3.;
    #####: 1414:	yt = xt/4.;
    #####: 1415:	zt = yt/5.;
    #####: 1416:	for( ii = 0; ii < nx*ny*nz; ii ++)
branch  0 never executed
branch  1 never executed
        -: 1417:	{
    #####: 1418:	(*nodelist)[ii].sqp *= k;
    #####: 1419:	(*nodelist)[ii].q100 *= k;
    #####: 1420:	(*nodelist)[ii].q010 *= k;
    #####: 1421:	(*nodelist)[ii].q001 *= k;
    #####: 1422:	(*nodelist)[ii].q200 *= .5*k;
    #####: 1423:	(*nodelist)[ii].q020 *= .5*k;
    #####: 1424:	(*nodelist)[ii].q002 *= .5*k;
    #####: 1425:	(*nodelist)[ii].q101 *= k;
    #####: 1426:	(*nodelist)[ii].q110 *= k;
    #####: 1427:	(*nodelist)[ii].q011 *= k;
    #####: 1428:	(*nodelist)[ii].q300 *= xt*k;
    #####: 1429:	(*nodelist)[ii].q030 *= xt*k;
    #####: 1430:	(*nodelist)[ii].q003 *= xt*k;
    #####: 1431:	(*nodelist)[ii].q210 *= 0.5*k;
    #####: 1432:	(*nodelist)[ii].q120 *= 0.5*k;
    #####: 1433:	(*nodelist)[ii].q201 *= 0.5*k;
    #####: 1434:	(*nodelist)[ii].q102 *= 0.5*k;
    #####: 1435:	(*nodelist)[ii].q021 *= 0.5*k;
    #####: 1436:	(*nodelist)[ii].q012 *= 0.5*k;
    #####: 1437:	(*nodelist)[ii].q111 *= k;
        -: 1438:#ifdef FOURTH
        -: 1439:	(*nodelist)[ii].q400 *= yt*k;
        -: 1440:	(*nodelist)[ii].q040 *= yt*k;
        -: 1441:	(*nodelist)[ii].q004 *= yt*k;
        -: 1442:	(*nodelist)[ii].q310 *= xt*k;
        -: 1443:	(*nodelist)[ii].q130 *= xt*k;
        -: 1444:	(*nodelist)[ii].q301 *= xt*k;
        -: 1445:	(*nodelist)[ii].q103 *= xt*k;
        -: 1446:	(*nodelist)[ii].q031 *= xt*k;
        -: 1447:	(*nodelist)[ii].q013 *= xt*k;
        -: 1448:	(*nodelist)[ii].q220 *= .25*k;
        -: 1449:	(*nodelist)[ii].q202 *= .25*k;
        -: 1450:	(*nodelist)[ii].q022 *= .25*k;
        -: 1451:	(*nodelist)[ii].q211 *= .5*k;
        -: 1452:	(*nodelist)[ii].q121 *= .5*k;
        -: 1453:	(*nodelist)[ii].q112 *= .5*k;
        -: 1454:#endif
        -: 1455:#ifdef FIFTH
        -: 1456:	(*nodelist)[ii].q500 *= zt*k;
        -: 1457:	(*nodelist)[ii].q050 *= zt*k;
        -: 1458:	(*nodelist)[ii].q005 *= zt*k;
        -: 1459:	(*nodelist)[ii].q410 *= yt*k;
        -: 1460:	(*nodelist)[ii].q140 *= yt*k;
        -: 1461:	(*nodelist)[ii].q401 *= yt*k;
        -: 1462:	(*nodelist)[ii].q104 *= yt*k;
        -: 1463:	(*nodelist)[ii].q041 *= yt*k;
        -: 1464:	(*nodelist)[ii].q014 *= yt*k;
        -: 1465:	(*nodelist)[ii].q320 *= .5*xt*k;
        -: 1466:	(*nodelist)[ii].q230 *= .5*xt*k;
        -: 1467:	(*nodelist)[ii].q302 *= .5*xt*k;
        -: 1468:	(*nodelist)[ii].q203 *= .5*xt*k;
        -: 1469:	(*nodelist)[ii].q032 *= .5*xt*k;
        -: 1470:	(*nodelist)[ii].q023 *= .5*xt*k;
        -: 1471:	(*nodelist)[ii].q221 *= .25*k;
        -: 1472:	(*nodelist)[ii].q212 *= .25*k;
        -: 1473:	(*nodelist)[ii].q122 *= .25*k;
        -: 1474:	(*nodelist)[ii].q311 *= xt*k;
        -: 1475:	(*nodelist)[ii].q131 *= xt*k;
        -: 1476:	(*nodelist)[ii].q113 *= xt*k;
        -: 1477:#endif
        -: 1478:	/*debug
        -: 1479:	printf("%d %f %f\n",ii,(*nodelist)[ii].sqp,(*nodelist)[ii].q100);
        -: 1480:	*/
    #####: 1481:	if( (*nodelist)[ii].sa != 0.)
branch  0 never executed
branch  1 never executed
        -: 1482:	{
    #####: 1483:	(*nodelist)[ii].xa = (*nodelist)[ii].xa/(*nodelist)[ii].sa;
    #####: 1484:	(*nodelist)[ii].ya = (*nodelist)[ii].ya/(*nodelist)[ii].sa;
    #####: 1485:	(*nodelist)[ii].za = (*nodelist)[ii].za/(*nodelist)[ii].sa;
        -: 1486:	}
    #####: 1487:	(*nodelist)[ii].xa += (*nodelist)[ii].xc;
    #####: 1488:	(*nodelist)[ii].ya += (*nodelist)[ii].yc;
    #####: 1489:	(*nodelist)[ii].za += (*nodelist)[ii].zc;
        -: 1490:/* correct for double counting */
    #####: 1491:	(*nodelist)[ii].sa  *= .5;
        -: 1492:	}
        -: 1493:
        -: 1494:/* initiallization of the mmnodes is done !!! */
        -: 1495:
        -: 1496:/*  initialize the data for every atom */
    #####: 1497:	for( ii=0; ii< jj; ii++)
branch  0 never executed
branch  1 never executed
        -: 1498:	{
    #####: 1499:	a1 = (*atomall)[ii];
    #####: 1500:	a1-> px = a1->x + lambda*a1->dx;
    #####: 1501:	a1-> py = a1->y + lambda*a1->dy;
    #####: 1502:	a1-> pz = a1->z + lambda*a1->dz;
    #####: 1503:	a1 -> VP = 0.;
    #####: 1504:	a1 -> dpx = 0.;
    #####: 1505:	a1 -> dpy = 0.;
    #####: 1506:	a1 -> dpz = 0.;
    #####: 1507:	a1 -> qxx = 0.;
    #####: 1508:	a1 -> qxy = 0.;
    #####: 1509:	a1 -> qxz = 0.;
    #####: 1510:	a1 -> qyy = 0.;
    #####: 1511:	a1 -> qyz = 0.;
    #####: 1512:	a1 -> qzz = 0.;
        -: 1513:#ifdef CUBIC
        -: 1514:	a1 -> qxxx = 0.;
        -: 1515:	a1 -> qxxy = 0.;
        -: 1516:	a1 -> qxxz = 0.;
        -: 1517:	a1 -> qxyy = 0.;
        -: 1518:	a1 -> qxyz = 0.;
        -: 1519:	a1 -> qxzz = 0.;
        -: 1520:	a1 -> qyyy = 0.;
        -: 1521:	a1 -> qyyz = 0.;
        -: 1522:	a1 -> qyzz = 0.;
        -: 1523:	a1 -> qzzz = 0.;
        -: 1524:#endif
    #####: 1525:	for( j=0; j< NCLOSE; j++) 
branch  0 never executed
branch  1 never executed
    #####: 1526:		a1->close[j] = NULL;
        -: 1527:
        -: 1528:	}/* end of initializations */
        -: 1529:
        -: 1530:
    #####: 1531:	for( ii=0; ii<  jj; ii++)
branch  0 never executed
branch  1 never executed
        -: 1532:	{ /* if this is met we update the expansion for this atom */
        -: 1533:/*	a1 = (*atomall)[ii];
        -: 1534:	atomall will be reused in this loop so we refer to atomlist
        -: 1535:	*/
    #####: 1536:	a1 = (*atomlist)[ii].who;
    #####: 1537:	inclose = 0;
        -: 1538:/* loop over the nodes 
        -: 1539:   if the node is mine or a neighbor then use an
        -: 1540:   explicit summation
        -: 1541:   otherwise use the MM node */
    #####: 1542:	ix = (a1->px  - xmin )/mmbox ;
    #####: 1543:	iy = (a1->py  - ymin )/mmbox ;
    #####: 1544:	iz = (a1->pz  - zmin )/mmbox ;
    #####: 1545:	naybor[0] = ((iz*ny)+iy)*nx + ix;
    #####: 1546:	naybor[1] = ((iz*ny)+iy)*nx + ix+1;
    #####: 1547:	naybor[2] = ((iz*ny)+iy)*nx + ix-1;
    #####: 1548:	naybor[3] = ((iz*ny)+iy)*nx+nx + ix;
    #####: 1549:	naybor[4] = ((iz*ny)+iy)*nx-nx + ix;
    #####: 1550:	naybor[5] = ((iz*ny)+iy)*nx+nx + ix+1;
    #####: 1551:	naybor[6] = ((iz*ny)+iy)*nx+nx + ix-1;
    #####: 1552:	naybor[7] = ((iz*ny)+iy)*nx-nx + ix+1;
    #####: 1553:	naybor[8] = ((iz*ny)+iy)*nx-nx + ix-1;
    #####: 1554:	naybor[9] = ((iz*ny)+ny+iy)*nx + ix;
    #####: 1555:	naybor[10] = ((iz*ny)+ny+iy)*nx + ix+1;
    #####: 1556:	naybor[11] = ((iz*ny)+ny+iy)*nx + ix-1;
    #####: 1557:	naybor[12] = ((iz*ny)+ny+iy)*nx+nx + ix;
    #####: 1558:	naybor[13] = ((iz*ny)+ny+iy)*nx-nx + ix;
    #####: 1559:	naybor[14] = ((iz*ny)+ny+iy)*nx+nx + ix+1;
    #####: 1560:	naybor[15] = ((iz*ny)+ny+iy)*nx+nx + ix-1;
    #####: 1561:	naybor[16] = ((iz*ny)+ny+iy)*nx-nx + ix+1;
    #####: 1562:	naybor[17] = ((iz*ny)+ny+iy)*nx-nx + ix-1;
    #####: 1563:	naybor[18] = ((iz*ny)-ny+iy)*nx + ix;
    #####: 1564:	naybor[19] = ((iz*ny)-ny+iy)*nx + ix+1;
    #####: 1565:	naybor[20] = ((iz*ny)-ny+iy)*nx + ix-1;
    #####: 1566:	naybor[21] = ((iz*ny)-ny+iy)*nx+nx + ix;
    #####: 1567:	naybor[22] = ((iz*ny)-ny+iy)*nx-nx + ix;
    #####: 1568:	naybor[23] = ((iz*ny)-ny+iy)*nx+nx + ix+1;
    #####: 1569:	naybor[24] = ((iz*ny)-ny+iy)*nx+nx + ix-1;
    #####: 1570:	naybor[25] = ((iz*ny)-ny+iy)*nx-nx + ix+1;
    #####: 1571:	naybor[26] = ((iz*ny)-ny+iy)*nx-nx + ix-1;
        -: 1572:
    #####: 1573:	for( inode = 0; inode < nx*ny*nz; inode ++)
branch  0 never executed
branch  1 never executed
        -: 1574:	{/* loop over all mm nodes */
        -: 1575:	/* check the origin */
    #####: 1576:	for(j=0; j< 27; j++)
branch  0 never executed
branch  1 never executed
        -: 1577:	{  
    #####: 1578:	if( inode == naybor[j]) break; }
branch  0 never executed
branch  1 never executed
    #####: 1579:	if( j == 27  )
branch  0 never executed
branch  1 never executed
        -: 1580:	{ /* then use mm */
    #####: 1581:	if( (*nodelist)[inode].innode > 0 )
branch  0 never executed
branch  1 never executed
        -: 1582:	{
        -: 1583:/* $%$%$%$%$  the expansion for f(r) goes here */
        -: 1584:/* first the a terms */
        -: 1585:	/*
        -: 1586:	xt = (*nodelist)[inode].xa - a1->px;
        -: 1587:	yt = (*nodelist)[inode].ya - a1->py;
        -: 1588:	zt = (*nodelist)[inode].za - a1->pz;
        -: 1589:	r = one/(xt*xt + yt*yt + zt*zt);
        -: 1590:	r0 = sqrt(r);
        -: 1591:	r = r*r*r;
        -: 1592:	k = -(*nodelist)[inode].sa *a1->a*r;
        -: 1593:	a1->VP  += k/r;
        -: 1594:	k *= six*r0; 
        -: 1595:	xt *= r0;
        -: 1596:	yt *= r0;
        -: 1597:	zt *= r0;
        -: 1598:	a1->dpx += k*xt;
        -: 1599:	a1->dpy += k*yt;
        -: 1600:	a1->dpz += k*zt;
        -: 1601:	k *= eight*r0;
        -: 1602:	a1->qxx -= k *(xt*xt -eightth);
        -: 1603:	a1->qxy -= k*xt*yt;
        -: 1604:	a1->qxz -= k*xt*zt;
        -: 1605:	a1->qyy -= k *(yt*yt -eightth);
        -: 1606:	a1->qyz -= k*yt*zt;
        -: 1607:	a1->qzz -= k *(zt*zt -eightth);
        -: 1608:	*/
        -: 1609:/* now do the multipole expansion for the electrostatic terms */
        -: 1610:/* note that dielectric is included in the multipole expansion */
    #####: 1611:	xt = (*nodelist)[inode].xc - a1->px;
    #####: 1612:	yt = (*nodelist)[inode].yc - a1->py;
    #####: 1613:	zt = (*nodelist)[inode].zc - a1->pz;
    #####: 1614:	r = one/(xt*xt + yt*yt + zt*zt);
    #####: 1615:	r0 = sqrt(r);
    #####: 1616:	c1 =  -r*r0;
    #####: 1617:	c2 = -three*c1*r;
    #####: 1618:	c3 = -five*c2*r;
    #####: 1619:	c4 = -seven*c3*r;
    #####: 1620:	c5 = -nine*c4*r;
    #####: 1621:	xt2 = xt*xt;
    #####: 1622:	xt3 = xt2*xt;
    #####: 1623:	xt4 = xt3*xt;
    #####: 1624:	yt2 = yt*yt;
    #####: 1625:	yt3 = yt2*yt;
    #####: 1626:	yt4 = yt3*yt;
    #####: 1627:	zt2 = zt*zt;
    #####: 1628:	zt3 = zt2*zt;
    #####: 1629:	zt4 = zt3*zt;
    #####: 1630:	a1->VP += (*nodelist)[inode].sqp*a1->q*r0;
    #####: 1631:	k = c1*a1->q*xt;
    #####: 1632:	a1->VP += k*(*nodelist)[inode].q100;
    #####: 1633:	a1->dpx += k*(*nodelist)[inode].sqp;
    #####: 1634:	k = c1*a1->q*yt;
    #####: 1635:	a1->VP += k*(*nodelist)[inode].q010;
    #####: 1636:	a1->dpy += k*(*nodelist)[inode].sqp;
    #####: 1637:	k = c1*a1->q*zt;
    #####: 1638:	a1->VP += k*(*nodelist)[inode].q001;
    #####: 1639:	a1->dpz += k*(*nodelist)[inode].sqp;
        -: 1640:/* n=2 */
    #####: 1641:	k = (c2*xt2 +c1)*a1->q;
    #####: 1642:	a1->VP += k*(*nodelist)[inode].q200;
    #####: 1643:	a1->dpx += k*(*nodelist)[inode].q100;
    #####: 1644:	a1->qxx += k*(*nodelist)[inode].sqp;
    #####: 1645:	k = (c2*yt2 +c1)*a1->q;
    #####: 1646:	a1->VP += k*(*nodelist)[inode].q020;
    #####: 1647:	a1->dpy += k*(*nodelist)[inode].q010;
    #####: 1648:	a1->qyy += k*(*nodelist)[inode].sqp;
    #####: 1649:	k = (c2*zt2 +c1)*a1->q;
    #####: 1650:	a1->VP += k*(*nodelist)[inode].q002;
    #####: 1651:	a1->dpz += k*(*nodelist)[inode].q001;
    #####: 1652:	a1->qzz += k*(*nodelist)[inode].sqp;
    #####: 1653:	k = c2*xt*yt*a1->q;
    #####: 1654:	a1->VP += k*(*nodelist)[inode].q110;
    #####: 1655:	a1->dpx += k*(*nodelist)[inode].q010;
    #####: 1656:	a1->dpy += k*(*nodelist)[inode].q100;
    #####: 1657:	a1->qxy += k*(*nodelist)[inode].sqp;
    #####: 1658:	k = c2*xt*zt*a1->q;
    #####: 1659:	a1->VP += k*(*nodelist)[inode].q101;
    #####: 1660:	a1->dpx += k*(*nodelist)[inode].q001;
    #####: 1661:	a1->dpz += k*(*nodelist)[inode].q100;
    #####: 1662:	a1->qxz += k*(*nodelist)[inode].sqp;
    #####: 1663:	k = c2*yt*zt*a1->q;
    #####: 1664:	a1->VP += k*(*nodelist)[inode].q011;
    #####: 1665:	a1->dpy += k*(*nodelist)[inode].q001;
    #####: 1666:	a1->dpz += k*(*nodelist)[inode].q010;
    #####: 1667:	a1->qyz += k*(*nodelist)[inode].sqp;
        -: 1668:/* n=3 */
    #####: 1669:	k = (c3*xt3 +3*c2*xt)*a1->q;
    #####: 1670:	a1->VP += k*(*nodelist)[inode].q300;
    #####: 1671:	a1->dpx += k*(*nodelist)[inode].q200;
    #####: 1672:	a1->qxx += k*(*nodelist)[inode].q100;
    #####: 1673:	k = (c3*yt3 +3*c2*yt)*a1->q;
    #####: 1674:	a1->VP += k*(*nodelist)[inode].q030;
    #####: 1675:	a1->dpy += k*(*nodelist)[inode].q020;
    #####: 1676:	a1->qyy += k*(*nodelist)[inode].q010;
    #####: 1677:	k = (c3*zt3 +3*c2*zt)*a1->q;
    #####: 1678:	a1->VP += k*(*nodelist)[inode].q003;
    #####: 1679:	a1->dpz += k*(*nodelist)[inode].q002;
    #####: 1680:	a1->qzz += k*(*nodelist)[inode].q001;
    #####: 1681:	k = (c3*xt2*yt+c2*yt)*a1->q;
    #####: 1682:	a1->VP += k*(*nodelist)[inode].q210;
    #####: 1683:	a1->dpx += k*(*nodelist)[inode].q110;
    #####: 1684:	a1->dpy += k*(*nodelist)[inode].q200;
    #####: 1685:	a1->qxx += k*(*nodelist)[inode].q010;
    #####: 1686:	a1->qxy += k*(*nodelist)[inode].q100;
    #####: 1687:	k = (c3*yt2*xt+c2*xt)*a1->q;
    #####: 1688:	a1->VP += k*(*nodelist)[inode].q120;
    #####: 1689:	a1->dpx += k*(*nodelist)[inode].q020;
    #####: 1690:	a1->dpy += k*(*nodelist)[inode].q110;
    #####: 1691:	a1->qyy += k*(*nodelist)[inode].q100;
    #####: 1692:	a1->qxy += k*(*nodelist)[inode].q010;
    #####: 1693:	k = (c3*xt2*zt+c2*zt)*a1->q;
    #####: 1694:	a1->VP += k*(*nodelist)[inode].q201;
    #####: 1695:	a1->dpx += k*(*nodelist)[inode].q101;
    #####: 1696:	a1->dpz += k*(*nodelist)[inode].q200;
    #####: 1697:	a1->qxx += k*(*nodelist)[inode].q001;
    #####: 1698:	a1->qxz += k*(*nodelist)[inode].q100;
    #####: 1699:	k = (c3*zt2*xt+c2*xt)*a1->q;
    #####: 1700:	a1->VP += k*(*nodelist)[inode].q102;
    #####: 1701:	a1->dpx += k*(*nodelist)[inode].q002;
    #####: 1702:	a1->dpz += k*(*nodelist)[inode].q101;
    #####: 1703:	a1->qzz += k*(*nodelist)[inode].q100;
    #####: 1704:	a1->qxz += k*(*nodelist)[inode].q001;
    #####: 1705:	k = (c3*yt2*zt+c2*zt)*a1->q;
    #####: 1706:	a1->VP += k*(*nodelist)[inode].q021;
    #####: 1707:	a1->dpy += k*(*nodelist)[inode].q011;
    #####: 1708:	a1->dpz += k*(*nodelist)[inode].q020;
    #####: 1709:	a1->qyy += k*(*nodelist)[inode].q001;
    #####: 1710:	a1->qyz += k*(*nodelist)[inode].q010;
    #####: 1711:	k = (c3*zt2*yt+c2*yt)*a1->q;
    #####: 1712:	a1->VP += k*(*nodelist)[inode].q012;
    #####: 1713:	a1->dpy += k*(*nodelist)[inode].q002;
    #####: 1714:	a1->dpz += k*(*nodelist)[inode].q011;
    #####: 1715:	a1->qzz += k*(*nodelist)[inode].q010;
    #####: 1716:	a1->qyz += k*(*nodelist)[inode].q001;
    #####: 1717:	k = (c3*zt*yt*xt)*a1->q;
    #####: 1718:	a1->VP += k*(*nodelist)[inode].q111;
    #####: 1719:	a1->dpx += k*(*nodelist)[inode].q011;
    #####: 1720:	a1->dpy += k*(*nodelist)[inode].q101;
    #####: 1721:	a1->dpz += k*(*nodelist)[inode].q110;
        -: 1722:/* n=4 */
        -: 1723:#ifdef FOURTH
        -: 1724:	k = (c4*xt4 +six*c3*(xt2) +three*c2)*a1->q;
        -: 1725:	a1->VP += k*(*nodelist)[inode].q400;
        -: 1726:	a1->dpx += k*(*nodelist)[inode].q300;
        -: 1727:	a1->qxx += k*(*nodelist)[inode].q200;
        -: 1728:	k = (c4*yt4 +six*c3*(yt2) +three*c2)*a1->q;
        -: 1729:	a1->VP += k*(*nodelist)[inode].q040;
        -: 1730:	a1->dpy += k*(*nodelist)[inode].q030;
        -: 1731:	a1->qyy += k*(*nodelist)[inode].q020;
        -: 1732:	k = (c4*zt4 +six*c3*(zt2) +three*c2)*a1->q;
        -: 1733:	a1->VP += k*(*nodelist)[inode].q004;
        -: 1734:	a1->dpz += k*(*nodelist)[inode].q003;
        -: 1735:	a1->qzz += k*(*nodelist)[inode].q002;
        -: 1736:	k = (c4*xt3*yt + three*c3*xt*yt)*a1->q;
        -: 1737:	a1->VP += k*(*nodelist)[inode].q310;
        -: 1738:	a1->dpx += k*(*nodelist)[inode].q210;
        -: 1739:	a1->dpy += k*(*nodelist)[inode].q300;
        -: 1740:	a1->qxx += k*(*nodelist)[inode].q110;
        -: 1741:	a1->qxy += k*(*nodelist)[inode].q200;
        -: 1742:	k = (c4*yt3*xt + three*c3*xt*yt)*a1->q;
        -: 1743:	a1->VP += k*(*nodelist)[inode].q130;
        -: 1744:	a1->dpx += k*(*nodelist)[inode].q030;
        -: 1745:	a1->dpy += k*(*nodelist)[inode].q120;
        -: 1746:	a1->qyy += k*(*nodelist)[inode].q110;
        -: 1747:	a1->qxy += k*(*nodelist)[inode].q020;
        -: 1748:	k = (c4*xt3*zt + three*c3*xt*zt)*a1->q;
        -: 1749:	a1->VP += k*(*nodelist)[inode].q301;
        -: 1750:	a1->dpx += k*(*nodelist)[inode].q201;
        -: 1751:	a1->dpz += k*(*nodelist)[inode].q300;
        -: 1752:	a1->qxx += k*(*nodelist)[inode].q101;
        -: 1753:	a1->qxz += k*(*nodelist)[inode].q200;
        -: 1754:	k = (c4*zt3*yt + three*c3*xt*yt)*a1->q;
        -: 1755:	a1->VP += k*(*nodelist)[inode].q103;
        -: 1756:	a1->dpx += k*(*nodelist)[inode].q003;
        -: 1757:	a1->dpz += k*(*nodelist)[inode].q102;
        -: 1758:	a1->qzz += k*(*nodelist)[inode].q101;
        -: 1759:	a1->qxz += k*(*nodelist)[inode].q002;
        -: 1760:	k = (c4*yt3*zt + three*c3*zt*yt)*a1->q;
        -: 1761:	a1->VP += k*(*nodelist)[inode].q031;
        -: 1762:	a1->dpz += k*(*nodelist)[inode].q030;
        -: 1763:	a1->dpy += k*(*nodelist)[inode].q021;
        -: 1764:	a1->qyy += k*(*nodelist)[inode].q011;
        -: 1765:	a1->qyz += k*(*nodelist)[inode].q020;
        -: 1766:	k = (c4*zt3*yt + three*c3*zt*yt)*a1->q;
        -: 1767:	a1->VP += k*(*nodelist)[inode].q013;
        -: 1768:	a1->dpz += k*(*nodelist)[inode].q012;
        -: 1769:	a1->dpy += k*(*nodelist)[inode].q003;
        -: 1770:	a1->qzz += k*(*nodelist)[inode].q011;
        -: 1771:	a1->qyz += k*(*nodelist)[inode].q002;
        -: 1772:	k = (c4*xt2*yt2 + c3*(xt2+yt2) +c2)*a1->q;
        -: 1773:	a1->VP += k*(*nodelist)[inode].q220;
        -: 1774:	a1->dpx += k*(*nodelist)[inode].q120;
        -: 1775:	a1->dpy += k*(*nodelist)[inode].q210;
        -: 1776:	a1->qxx += k*(*nodelist)[inode].q020;
        -: 1777:	a1->qyy += k*(*nodelist)[inode].q200;
        -: 1778:	a1->qxy += k*(*nodelist)[inode].q110;
        -: 1779:	k = (c4*xt2*zt2 + c3*(xt2+zt2) +c2)*a1->q;
        -: 1780:	a1->VP += k*(*nodelist)[inode].q202;
        -: 1781:	a1->dpx += k*(*nodelist)[inode].q102;
        -: 1782:	a1->dpz += k*(*nodelist)[inode].q201;
        -: 1783:	a1->qxx += k*(*nodelist)[inode].q002;
        -: 1784:	a1->qzz += k*(*nodelist)[inode].q200;
        -: 1785:	a1->qxz += k*(*nodelist)[inode].q101;
        -: 1786:	k = (c4*zt2*yt2 + c3*(zt2+yt2) +c2)*a1->q;
        -: 1787:	a1->VP += k*(*nodelist)[inode].q022;
        -: 1788:	a1->dpz += k*(*nodelist)[inode].q021;
        -: 1789:	a1->dpy += k*(*nodelist)[inode].q012;
        -: 1790:	a1->qzz += k*(*nodelist)[inode].q020;
        -: 1791:	a1->qyy += k*(*nodelist)[inode].q002;
        -: 1792:	a1->qyz += k*(*nodelist)[inode].q011;
        -: 1793:	k = (c4*xt2*yt*zt +c3*yt*zt)*a1->q;
        -: 1794:	a1->VP += k*(*nodelist)[inode].q211;
        -: 1795:	a1->dpz += k*(*nodelist)[inode].q210;
        -: 1796:	a1->dpy += k*(*nodelist)[inode].q201;
        -: 1797:	a1->dpx += k*(*nodelist)[inode].q111;
        -: 1798:	a1->qxx += k*(*nodelist)[inode].q011;
        -: 1799:	a1->qxy += k*(*nodelist)[inode].q101;
        -: 1800:	a1->qyz += k*(*nodelist)[inode].q200;
        -: 1801:	a1->qxz += k*(*nodelist)[inode].q110;
        -: 1802:	k = (c4*xt*yt2*zt +c3*xt*zt)*a1->q;
        -: 1803:	a1->VP += k*(*nodelist)[inode].q121;
        -: 1804:	a1->dpz += k*(*nodelist)[inode].q120;
        -: 1805:	a1->dpy += k*(*nodelist)[inode].q111;
        -: 1806:	a1->dpx += k*(*nodelist)[inode].q021;
        -: 1807:	a1->qyy += k*(*nodelist)[inode].q101;
        -: 1808:	a1->qxy += k*(*nodelist)[inode].q011;
        -: 1809:	a1->qyz += k*(*nodelist)[inode].q110;
        -: 1810:	a1->qxz += k*(*nodelist)[inode].q020;
        -: 1811:	k = (c4*xt*yt*zt2 +c3*yt*xt)*a1->q;
        -: 1812:	a1->VP += k*(*nodelist)[inode].q112;
        -: 1813:	a1->dpz += k*(*nodelist)[inode].q111;
        -: 1814:	a1->dpy += k*(*nodelist)[inode].q102;
        -: 1815:	a1->dpx += k*(*nodelist)[inode].q012;
        -: 1816:	a1->qzz += k*(*nodelist)[inode].q110;
        -: 1817:	a1->qxy += k*(*nodelist)[inode].q002;
        -: 1818:	a1->qxz += k*(*nodelist)[inode].q011;
        -: 1819:	a1->qyz += k*(*nodelist)[inode].q101;
        -: 1820:#endif
        -: 1821:/* n=5 */
        -: 1822:#ifdef FIFTH
        -: 1823:	k = ((c5*xt+9*c4)*xt4  +15*c3*xt)*a1->q;
        -: 1824:	a1->VP += k*(*nodelist)[inode].q500;
        -: 1825:	a1->dpx += k*(*nodelist)[inode].q400;
        -: 1826:	a1->qxx += k*(*nodelist)[inode].q300;
        -: 1827:	k = ((c5*yt+9*c4)*yt4  +15*c3*yt)*a1->q;
        -: 1828:	a1->VP += k*(*nodelist)[inode].q050;
        -: 1829:	a1->dpy += k*(*nodelist)[inode].q040;
        -: 1830:	a1->qyy += k*(*nodelist)[inode].q030;
        -: 1831:	k = ((c5*zt+9*c4)*zt4  +15*c3*zt)*a1->q;
        -: 1832:	a1->VP += k*(*nodelist)[inode].q005;
        -: 1833:	a1->dpz += k*(*nodelist)[inode].q004;
        -: 1834:	a1->qzz += k*(*nodelist)[inode].q003;
        -: 1835:	k = (c5*xt4+six*c4*xt2 +three*c3)*yt*a1->q;
        -: 1836:	a1->VP += k*(*nodelist)[inode].q410;
        -: 1837:	a1->dpx += k*(*nodelist)[inode].q310;
        -: 1838:	a1->dpy += k*(*nodelist)[inode].q400;
        -: 1839:	a1->qxx += k*(*nodelist)[inode].q210;
        -: 1840:	a1->qxy += k*(*nodelist)[inode].q300;
        -: 1841:	k = (c5*yt4+six*c4*yt2 +three*c3)*xt*a1->q;
        -: 1842:	a1->VP += k*(*nodelist)[inode].q140;
        -: 1843:	a1->dpx += k*(*nodelist)[inode].q040;
        -: 1844:	a1->dpy += k*(*nodelist)[inode].q130;
        -: 1845:	a1->qyy += k*(*nodelist)[inode].q120;
        -: 1846:	a1->qxy += k*(*nodelist)[inode].q030;
        -: 1847:	k = (c5*xt4+six*c4*xt2 +three*c3)*zt*a1->q;
        -: 1848:	a1->VP += k*(*nodelist)[inode].q401;
        -: 1849:	a1->dpx += k*(*nodelist)[inode].q301;
        -: 1850:	a1->dpz += k*(*nodelist)[inode].q400;
        -: 1851:	a1->qxx += k*(*nodelist)[inode].q201;
        -: 1852:	a1->qxz += k*(*nodelist)[inode].q300;
        -: 1853:	k = (c5*zt4+six*c4*zt2 +three*c3)*xt*a1->q;
        -: 1854:	a1->VP += k*(*nodelist)[inode].q104;
        -: 1855:	a1->dpx += k*(*nodelist)[inode].q004;
        -: 1856:	a1->dpz += k*(*nodelist)[inode].q103;
        -: 1857:	a1->qzz += k*(*nodelist)[inode].q102;
        -: 1858:	a1->qxz += k*(*nodelist)[inode].q003;
        -: 1859:	k = (c5*yt4+six*c4*yt2 +three*c3)*zt*a1->q;
        -: 1860:	a1->VP += k*(*nodelist)[inode].q041;
        -: 1861:	a1->dpy += k*(*nodelist)[inode].q031;
        -: 1862:	a1->dpz += k*(*nodelist)[inode].q040;
        -: 1863:	a1->qyy += k*(*nodelist)[inode].q021;
        -: 1864:	a1->qyz += k*(*nodelist)[inode].q030;
        -: 1865:	k = (c5*zt4+six*c4*zt2 +three*c3)*yt*a1->q;
        -: 1866:	a1->VP += k*(*nodelist)[inode].q014;
        -: 1867:	a1->dpy += k*(*nodelist)[inode].q004;
        -: 1868:	a1->dpz += k*(*nodelist)[inode].q013;
        -: 1869:	a1->qzz += k*(*nodelist)[inode].q012;
        -: 1870:	a1->qyz += k*(*nodelist)[inode].q003;
        -: 1871:	k = (c5*xt3*yt2 +c4*(three*xt*yt2-xt3) +three*c3*xt)*a1->q;
        -: 1872:	a1->VP += k*(*nodelist)[inode].q320;
        -: 1873:	a1->dpx += k*(*nodelist)[inode].q220;
        -: 1874:	a1->dpy += k*(*nodelist)[inode].q310;
        -: 1875:	a1->qxx += k*(*nodelist)[inode].q120;
        -: 1876:	a1->qxy += k*(*nodelist)[inode].q210;
        -: 1877:	a1->qyy += k*(*nodelist)[inode].q300;
        -: 1878:	k = (c5*yt3*xt2 +c4*(three*yt*xt2-yt3) +three*c3*yt)*a1->q;
        -: 1879:	a1->VP += k*(*nodelist)[inode].q230;
        -: 1880:	a1->dpx += k*(*nodelist)[inode].q130;
        -: 1881:	a1->dpy += k*(*nodelist)[inode].q220;
        -: 1882:	a1->qxx += k*(*nodelist)[inode].q030;
        -: 1883:	a1->qxy += k*(*nodelist)[inode].q120;
        -: 1884:	a1->qyy += k*(*nodelist)[inode].q210;
        -: 1885:	k = (c5*xt3*zt2 +c4*(three*xt*zt2-xt3) +three*c3*xt)*a1->q;
        -: 1886:	a1->VP += k*(*nodelist)[inode].q302;
        -: 1887:	a1->dpx += k*(*nodelist)[inode].q202;
        -: 1888:	a1->dpz += k*(*nodelist)[inode].q301;
        -: 1889:	a1->qxx += k*(*nodelist)[inode].q102;
        -: 1890:	a1->qxz += k*(*nodelist)[inode].q201;
        -: 1891:	a1->qzz += k*(*nodelist)[inode].q300;
        -: 1892:	k = (c5*zt3*xt2 +c4*(three*zt*xt2-zt3) +three*c3*zt)*a1->q;
        -: 1893:	a1->VP += k*(*nodelist)[inode].q203;
        -: 1894:	a1->dpx += k*(*nodelist)[inode].q103;
        -: 1895:	a1->dpz += k*(*nodelist)[inode].q202;
        -: 1896:	a1->qxx += k*(*nodelist)[inode].q003;
        -: 1897:	a1->qxz += k*(*nodelist)[inode].q102;
        -: 1898:	a1->qzz += k*(*nodelist)[inode].q201;
        -: 1899:	k = (c5*yt3*zt2 +c4*(three*yt*zt2-yt3) +three*c3*yt)*a1->q;
        -: 1900:	a1->VP += k*(*nodelist)[inode].q032;
        -: 1901:	a1->dpy += k*(*nodelist)[inode].q022;
        -: 1902:	a1->dpz += k*(*nodelist)[inode].q031;
        -: 1903:	a1->qyy += k*(*nodelist)[inode].q012;
        -: 1904:	a1->qyz += k*(*nodelist)[inode].q021;
        -: 1905:	a1->qzz += k*(*nodelist)[inode].q030;
        -: 1906:	k = (c5*zt3*yt2 +c4*(three*zt*yt2-zt3) +three*c3*zt)*a1->q;
        -: 1907:	a1->VP += k*(*nodelist)[inode].q023;
        -: 1908:	a1->dpy += k*(*nodelist)[inode].q013;
        -: 1909:	a1->dpz += k*(*nodelist)[inode].q022;
        -: 1910:	a1->qyy += k*(*nodelist)[inode].q003;
        -: 1911:	a1->qyz += k*(*nodelist)[inode].q012;
        -: 1912:	a1->qzz += k*(*nodelist)[inode].q021;
        -: 1913:	k = (c5*xt2*yt2 +c4*(xt2+yt2) +c3)*zt*a1->q;
        -: 1914:	a1->VP += k*(*nodelist)[inode].q221;
        -: 1915:	a1->dpx += k*(*nodelist)[inode].q121;
        -: 1916:	a1->dpy += k*(*nodelist)[inode].q211;
        -: 1917:	a1->dpz += k*(*nodelist)[inode].q220;
        -: 1918:	a1->qxx += k*(*nodelist)[inode].q021;
        -: 1919:	a1->qyy += k*(*nodelist)[inode].q201;
        -: 1920:	a1->qxz += k*(*nodelist)[inode].q120;
        -: 1921:	a1->qyz += k*(*nodelist)[inode].q210;
        -: 1922:	k = (c5*xt2*zt2 +c4*(xt2+zt2) +c3)*yt*a1->q;
        -: 1923:	a1->VP += k*(*nodelist)[inode].q212;
        -: 1924:	a1->dpx += k*(*nodelist)[inode].q112;
        -: 1925:	a1->dpy += k*(*nodelist)[inode].q202;
        -: 1926:	a1->dpz += k*(*nodelist)[inode].q211;
        -: 1927:	a1->qxx += k*(*nodelist)[inode].q012;
        -: 1928:	a1->qzz += k*(*nodelist)[inode].q210;
        -: 1929:	a1->qxz += k*(*nodelist)[inode].q111;
        -: 1930:	a1->qyz += k*(*nodelist)[inode].q201;
        -: 1931:	k = (c5*zt2*yt2 +c4*(zt2+yt2) +c3)*xt*a1->q;
        -: 1932:	a1->VP += k*(*nodelist)[inode].q122;
        -: 1933:	a1->dpx += k*(*nodelist)[inode].q022;
        -: 1934:	a1->dpy += k*(*nodelist)[inode].q112;
        -: 1935:	a1->dpz += k*(*nodelist)[inode].q121;
        -: 1936:	a1->qzz += k*(*nodelist)[inode].q120;
        -: 1937:	a1->qyy += k*(*nodelist)[inode].q102;
        -: 1938:	a1->qxy += k*(*nodelist)[inode].q022;
        -: 1939:	a1->qxz += k*(*nodelist)[inode].q022;
        -: 1940:	k = (c5*xt3+three*c4*xt)*yt*zt*a1->q;
        -: 1941:	a1->VP += k*(*nodelist)[inode].q311;
        -: 1942:	a1->dpx += k*(*nodelist)[inode].q211;
        -: 1943:	a1->dpy += k*(*nodelist)[inode].q301;
        -: 1944:	a1->dpz += k*(*nodelist)[inode].q310;
        -: 1945:	a1->qxx += k*(*nodelist)[inode].q211;
        -: 1946:	a1->qxy += k*(*nodelist)[inode].q201;
        -: 1947:	a1->qxz += k*(*nodelist)[inode].q210;
        -: 1948:	k = (c5*yt3+three*c4*yt)*xt*zt*a1->q;
        -: 1949:	a1->VP += k*(*nodelist)[inode].q131;
        -: 1950:	a1->dpx += k*(*nodelist)[inode].q031;
        -: 1951:	a1->dpy += k*(*nodelist)[inode].q121;
        -: 1952:	a1->dpz += k*(*nodelist)[inode].q130;
        -: 1953:	a1->qyy += k*(*nodelist)[inode].q111;
        -: 1954:	a1->qxy += k*(*nodelist)[inode].q021;
        -: 1955:	a1->qyz += k*(*nodelist)[inode].q120;
        -: 1956:	k = (c5*zt3+three*c4*zt)*yt*xt*a1->q;
        -: 1957:	a1->VP += k*(*nodelist)[inode].q113;
        -: 1958:	a1->dpx += k*(*nodelist)[inode].q013;
        -: 1959:	a1->dpy += k*(*nodelist)[inode].q103;
        -: 1960:	a1->dpz += k*(*nodelist)[inode].q112;
        -: 1961:	a1->qzz += k*(*nodelist)[inode].q111;
        -: 1962:	a1->qyz += k*(*nodelist)[inode].q102;
        -: 1963:	a1->qxz += k*(*nodelist)[inode].q012;
        -: 1964:#endif
        -: 1965:
        -: 1966:	} /* if innode > 0  end if */
    #####: 1967:	} else if( (*nodelist)[inode].innode > 0) 
branch  0 never executed
branch  1 never executed
        -: 1968:		{ /* if not mm use explicit */
        -: 1969:/* first load the atoms onto atomall */
    #####: 1970:	imax = 0;
    #####: 1971:	i = (*nodelist)[inode].first;
    #####: 1972:	 if( (*nodelist)[inode].innode > 0  && 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1973:	    ((*atomlist)[i].who)->serial > a1->serial)
    #####: 1974:	 {  (*atomall)[imax++] = (*atomlist)[i].who;}
    #####: 1975:	for( j=1; j< (*nodelist)[inode].innode -1 ; j++)
branch  0 never executed
branch  1 never executed
        -: 1976:	{
    #####: 1977:	 i = (*atomlist)[i].next;
    #####: 1978:	 if( ((*atomlist)[i].who)->serial > a1->serial)
branch  0 never executed
branch  1 never executed
    #####: 1979:	 {  (*atomall)[imax++] = (*atomlist)[i].who;}
        -: 1980:	}
        -: 1981:	/*
        -: 1982:	for( j=0; j< jj; j++)
        -: 1983:	{
        -: 1984:		if( (*atomlist)[j].which == inode && 
        -: 1985:		    (*atomlist)[j].who->serial > a1->serial)
        -: 1986:		    {(*atomall)[imax] = (*atomlist)[j].who;
        -: 1987:		    imax+= 1;}
        -: 1988:	}
        -: 1989:	*/
    #####: 1990:	for( i=0; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 1991:	{
    #####: 1992:	a2 = (*atomall)[i];
    #####: 1993:	j = i*4;
    #####: 1994:	(*vector)[j  ] = a2->px - a1->px ;
    #####: 1995:	(*vector)[j+1] = a2->py - a1->py ;
    #####: 1996:	(*vector)[j+2] = a2->pz - a1->pz ;
        -: 1997:	}
    #####: 1998:	for( i=0; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 1999:	{
    #####: 2000:		j = i*4;
    #####: 2001:		(*vector)[j+3] = sqrt((*vector)[j]*(*vector)[j] +
    #####: 2002:				 (*vector)[j+1]*(*vector)[j+1] +
    #####: 2003:				 (*vector)[j+2]*(*vector)[j+2]);
        -: 2004:	}
        -: 2005:/* add the new components */
    #####: 2006:	for( i=0; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 2007:	{
    #####: 2008:	a2 = (*atomall)[i];
    #####: 2009:	for( j=0; j< a1->dontuse; j++)
branch  0 never executed
branch  1 never executed
    #####: 2010:	{ if( a2 == a1->excluded[j]) goto SKIPNEW;}
branch  0 never executed
branch  1 never executed
    #####: 2011:	j = i*4;
    #####: 2012:	if( (*vector)[j+3] > mxcut || inclose > NCLOSE )
branch  0 never executed
branch  1 never executed
        -: 2013:	{
    #####: 2014:	r0 = one/(*vector)[j+3];  
    #####: 2015:	r = r0*r0;
    #####: 2016:	r = r*r*r; /* r0^-6 */
    #####: 2017:	xt = a1->q*a2->q*dielectric*r0;
    #####: 2018:	yt = a1->a*a2->a*r;
    #####: 2019:	zt = a1->b*a2->b*r*r;
    #####: 2020:	k = xt - yt + zt;
    #####: 2021:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
    #####: 2022:	k1 = xt - yt*six + zt*twelve;
    #####: 2023:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
    #####: 2024:	k2 = xt*three; ka2 = - yt*six*eight; kb2 =  zt*twelve*14;
        -: 2025:#ifdef CUBIC
        -: 2026:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
        -: 2027:	k3 = -xt*5*3; ka3 =   yt*6*8*10 ; kb3 =  -zt*12*14*16;
        -: 2028:#endif
    #####: 2029:	k1 = -k1;
    #####: 2030:	xt = (*vector)[j]*r0 ;
    #####: 2031:	yt = (*vector)[j+1]*r0 ;
    #####: 2032:	zt = (*vector)[j+2] *r0;
        -: 2033:	/*
        -: 2034:	xt = (*vector)[j] ;
        -: 2035:	yt = (*vector)[j+1] ;
        -: 2036:	zt = (*vector)[j+2] ;
        -: 2037:	*/
    #####: 2038:	a1->VP += k;
    #####: 2039:	a2->dpx -= k1*xt;
    #####: 2040:	a1->dpx += k1*xt;
    #####: 2041:	a2->dpy -= k1*yt;
    #####: 2042:	a1->dpy += k1*yt;
    #####: 2043:	a2->dpz -= k1*zt;
    #####: 2044:	a1->dpz += k1*zt;
    #####: 2045:	xt2 = xt*xt; yt2 = yt*yt; zt2 = zt*zt;
    #####: 2046:	a2->qxx -= k2*(xt2 - third) + ka2*(xt2 - eightth)+kb2*(xt2-fourteenth) ;
    #####: 2047:	a1->qxx -= k2*(xt2 - third) + ka2*(xt2 - eightth)+kb2*(xt2-fourteenth) ;
    #####: 2048:	a2->qxy -= (k2+ka2+kb2)*yt*xt;
    #####: 2049:	a1->qxy -= (k2+ka2+kb2)*yt*xt;
    #####: 2050:	a2->qxz -= (k2+ka2+kb2)*zt*xt;
    #####: 2051:	a1->qxz -= (k2+ka2+kb2)*zt*xt;
    #####: 2052:	a2->qyy -= k2*(yt2 - third) + ka2*(yt2 - eightth)+kb2*(yt2-fourteenth) ;
    #####: 2053:	a1->qyy -= k2*(yt2 - third) + ka2*(yt2 - eightth)+kb2*(yt2-fourteenth) ;
    #####: 2054:	a2->qyz -= (k2+ka2+kb2)*yt*zt;
    #####: 2055:	a1->qyz -= (k2+ka2+kb2)*yt*zt;
    #####: 2056:	a2->qzz -= k2*(zt2 - third) + ka2*(zt2 - eightth)+kb2*(zt2-fourteenth) ;
    #####: 2057:	a1->qzz -= k2*(zt2 - third) + ka2*(zt2 - eightth)+kb2*(zt2-fourteenth) ;
        -: 2058:#ifdef CUBIC
        -: 2059:	a2->qxxx -= k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 2060:	a2->qxxx -= ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 2061:	a2->qxxx -= kb3*(xt*xt*xt - xt*( 42./(14*18))); 
        -: 2062:	a1->qxxx += k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 2063:	a1->qxxx += ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 2064:	a1->qxxx += kb3*(xt*xt*xt - xt*( 42./(14*18))); 
        -: 2065:	a2->qxxy -= k3*(yt*xt*xt - yt*( 6./ 15));
        -: 2066:	a2->qxxy -= ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 2067:	a2->qxxy -= kb3*(yt*xt*xt - yt*( 17./ (14*18)));
        -: 2068:	a1->qxxy += k3*(yt*xt*xt - yt*( 6./ 15));
        -: 2069:	a1->qxxy += ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 2070:	a1->qxxy += kb3*(yt*xt*xt - yt*( 17./ (14*18)));
        -: 2071:	a2->qxxz -= k3*(zt*xt*xt - zt*( 6./ 15));
        -: 2072:	a2->qxxz -= ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 2073:	a2->qxxz -= kb3*(zt*xt*xt - zt*( 17./ (14*18)));
        -: 2074:	a1->qxxz += k3*(zt*xt*xt - zt*( 6./ 15));
        -: 2075:	a1->qxxz += ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 2076:	a1->qxxz += kb3*(zt*xt*xt - zt*( 17./ (14*18)));
        -: 2077:	a2->qxyy -= k3*(yt*yt*xt - xt*( 6./ 15));
        -: 2078:	a2->qxyy -= ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 2079:	a2->qxyy -= kb3*(yt*yt*xt - xt*( 17./ (14*18)));
        -: 2080:	a1->qxyy += k3*(yt*yt*xt - xt*( 6./ 15));
        -: 2081:	a1->qxyy += ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 2082:	a1->qxyy += kb3*(yt*yt*xt - xt*( 17./ (14*18)));
        -: 2083:	a2->qxyz -= (k3+ka3+kb3)*yt*zt*xt;
        -: 2084:	a1->qxyz += (k3+ka3+kb3)*yt*zt*xt;
        -: 2085:	a2->qxzz -= k3*(zt*zt*xt - xt*( 6./ 15));
        -: 2086:	a2->qxzz -= ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 2087:	a2->qxzz -= kb3*(zt*zt*xt - xt*( 17./ (14*18)));
        -: 2088:	a1->qxzz += k3*(zt*zt*xt - xt*( 6./ 15));
        -: 2089:	a1->qxzz += ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 2090:	a1->qxzz += kb3*(zt*zt*xt - xt*( 17./ (14*18)));
        -: 2091:	a2->qyyy -= k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 2092:	a2->qyyy -= ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 2093:	a2->qyyy -= kb3*(yt*yt*yt - yt*( 42./(14*18))); 
        -: 2094:	a1->qyyy += k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 2095:	a1->qyyy += ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 2096:	a1->qyyy += kb3*(yt*yt*yt - yt*( 42./(14*18))); 
        -: 2097:	a2->qyyz -= k3*(yt*yt*zt - zt*( 6./ 15));
        -: 2098:	a2->qyyz -= ka3*(yt*yt*zt - zt*( 11./ 80));
        -: 2099:	a2->qyyz -= kb3*(yt*yt*zt - zt*( 17./ (14*18)));
        -: 2100:	a1->qyyz += k3*(yt*yt*zt - zt*( 6./ 15));
        -: 2101:	a1->qyyz += ka3*(yt*yt*zt - zt*(11./ 80));
        -: 2102:	a1->qyyz += kb3*(yt*yt*zt - zt*( 17./ (14*18)));
        -: 2103:	a2->qyzz -= k3*(zt*zt*yt - yt*( 6./ 15));
        -: 2104:	a2->qyzz -= ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 2105:	a2->qyzz -= kb3*(zt*zt*yt - yt*( 17./ (14*18)));
        -: 2106:	a1->qyzz += k3*(zt*zt*yt - yt*( 6./ 15));
        -: 2107:	a1->qyzz += ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 2108:	a1->qyzz += kb3*(zt*zt*yt - yt*( 17./ (14*18)));
        -: 2109:	a2->qzzz -= k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 2110:	a2->qzzz -= ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 2111:	a2->qzzz -= kb3*(zt*zt*zt - zt*( 42./(14*18))); 
        -: 2112:	a1->qzzz += k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 2113:	a1->qzzz += ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 2114:	a1->qzzz += kb3*(zt*zt*zt - zt*( 42./(14*18))); 
        -: 2115:#endif
        -: 2116:	}else {
    #####: 2117:	a1->close[inclose++] = (*atomall)[i];
        -: 2118:/* debugging
        -: 2119:	j = i *4;
        -: 2120:	fprintf(stderr," mxcut %f %f inclose %d who %d \n",mxcut,(*vector)[j+3],inclose,(*atomall)[i]->serial);
        -: 2121:	fprintf(stderr," vector %f %f %f \n", (*vector)[j],(*vector)[j+1],(*vector)[j+2]);
        -: 2122:*/
    #####: 2123:	if( inclose == NCLOSE)
branch  0 never executed
branch  1 never executed
        -: 2124:	{
        -: 2125:	aaerror(
    #####: 2126:	" fv_update_nonbon> too many atoms increase NCLOSE or decrease mxcut");
call    0 never executed
        -: 2127:/*		exit(0); 
        -: 2128:*/
        -: 2129:	}
        -: 2130:	}
    #####: 2131:SKIPNEW:  j =  j;
        -: 2132:	}/* end of loop i */
        -: 2133:	}/* end of if in close MM node */
        -: 2134:	}/* end of loop inode */
        -: 2135:/* merge the non-bond mxcut lists */
        -: 2136:        /* SPEC remove following line which causes compiler warnings.
        -: 2137:         * The line was a no-op anyway, since double equals is a 
        -: 2138:         * compare.  The author of AMMP says that we should
        -: 2139:         * NOT change it to a single equals, as that would "cause a
        -: 2140:         * failure under certain odd conditions.  The actual array is
        -: 2141:         * preinitialized above to NULL and is filled during these
        -: 2142:         * routines" - jh/9/24/99 */
        -: 2143:	/* a1->close[inclose] == NULL; */
        -: 2144:/* set the position */
    #####: 2145:	a1->px = a1->dx*lambda + a1->x;
    #####: 2146:	a1->py = a1->dy*lambda + a1->y;
    #####: 2147:	a1->pz = a1->dz*lambda + a1->z;
        -: 2148:
        -: 2149:	}  /* end of ii loop */
        -: 2150:	
    #####: 2151:	a_inactive_f_zero();
call    0 never executed
        -: 2152:
    #####: 2153:	free( atomlist);
    #####: 2154:	free( nodelist);
    #####: 2155:	free( vector);
    #####: 2156:	free (atomall);
    #####: 2157:	return 1;
        -: 2158:
        -: 2159:}
        -: 2160:
        -: 2161:	float loop_lambda;
        -: 2162:	float r,r0,xt,yt,zt;
        -: 2163:	float xt2,xt3,xt4,yt2,yt3,yt4,zt2,zt3,zt4;
        -: 2164:	float k,k1,k2,k3,k4,k5;
        -: 2165:	float ka2,ka3;
        -: 2166:	float kb2,kb3;
        -: 2167:	float c1,c2,c3,c4,c5; /* constants for the mm expansion */
        -: 2168:	float get_f_variable(char*);
        -: 2169:	int inbond,inangle,i_loop;
        -: 2170:	ATOM *ap,*a1,*a2,*bonded[10],*angled[10];
        -: 2171:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 2172:	int a_number();
        -: 2173:	int ii,j,jj,imax,inclose;
        -: 2174:	float (*vector_loop)[];
        -: 2175:/* */
        -: 2176:	ATOM *close_loop[NCLOSE],*(*atomall)[];
        -: 2177:	float mxdq,dielectric,mxcut; 
        -: 2178:	float mmbox;
        -: 2179:	float xmax,xmin,ymax,ymin,zmax,zmin;
        -: 2180:	int nx,ny,nz;
        -: 2181:	int ix,iy,iz,inode;
        -: 2182:	int naybor[27];
        -: 2183:	char line[80];
        -: 2184:	MMNODE (*nodelist)[];
        -: 2185:	MMATOM (*atomlist)[];
        -: 2186:
function _Z6loop_0v called 88 returned 100% blocks executed 100%
       88: 2187:void loop_0(){
   843304: 2188:for(i_loop=0; i_loop< imax; i_loop++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2189:	{
   843216: 2190:		(*atomall)[i_loop] = a_next(i_loop);
call    0 returned 100%
   843216: 2191:		(*atomlist)[i_loop].who = (*atomall)[i_loop];
        -: 2192:	}
       88: 2193:}
function _Z6loop_1v called 88 returned 100% blocks executed 100%
       88: 2194:void loop_1(){
   843304: 2195:	for( ii=0; ii< imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2196:	{
   843216: 2197:	        a1 = (*atomall)[ii];
   843216: 2198:		j = ii*4;
   843216: 2199:	        (*vector_loop)[j] = a1->dx*loop_lambda +a1->x ;
   843216: 2200:	        (*vector_loop)[j+1] = a1->dy*loop_lambda +a1->y;
   843216: 2201:	        (*vector_loop)[j+2] = a1->dz*loop_lambda +a1->z;
        -: 2202:	}
       88: 2203:}
function _Z6loop_2v called 88 returned 100% blocks executed 100%
       88: 2204:void loop_2(){
        -: 2205:	/*SECOND II FOR*/	
        -: 2206:
   843304: 2207:	for( ii= 0; ii< imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2208:	{
   843216: 2209:		j = ii*4;
   843216: 2210:	  if( xmax < (*vector_loop)[j] ) xmax = (*vector_loop)[j];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   843216: 2211:	  if( ymax < (*vector_loop)[j+1] ) ymax = (*vector_loop)[j+1];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   843216: 2212:	  if( zmax < (*vector_loop)[j+2] ) zmax = (*vector_loop)[j+2];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   843216: 2213:	  if( xmin > (*vector_loop)[j] ) xmin = (*vector_loop)[j];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   843216: 2214:	  if( ymin > (*vector_loop)[j+1] ) ymin = (*vector_loop)[j+1];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   843216: 2215:	  if( zmin > (*vector_loop)[j+2] ) zmin = (*vector_loop)[j+2];
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 2216:	}
        -: 2217:
       88: 2218:}
function _Z6loop_3v called 88 returned 100% blocks executed 100%
       88: 2219:void loop_3(){
        -: 2220:	/*IX, IY, IZ FOR*/
      616: 2221:	for( ix=0; ix< nx; ix++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
     4446: 2222:		for( iy=0; iy< ny; iy++)
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
    31344: 2223:			for( iz=0; iz< nz; iz++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -: 2224:			{
    27426: 2225:				inode = ((iz*ny)+iy)*nx + ix;
    27426: 2226:				(*nodelist)[inode].xc = ix*mmbox + .5*mmbox + xmin;
    27426: 2227:				(*nodelist)[inode].yc = iy*mmbox + .5*mmbox + ymin;
    27426: 2228:				(*nodelist)[inode].zc = iz*mmbox + .5*mmbox + zmin;
        -: 2229:			}
       88: 2230:}
function _Z6loop_4v called 88 returned 100% blocks executed 100%
       88: 2231:void loop_4(){
        -: 2232:	/*THIRD II FOR*/
    27514: 2233:	for( ii=0; ii < nx*ny*nz; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2234:	{
    27426: 2235:		(*nodelist)[ii].sqp = 0.;
    27426: 2236:		(*nodelist)[ii].sa = 0.;
    27426: 2237:		(*nodelist)[ii].xa = 0.;
    27426: 2238:		(*nodelist)[ii].ya = 0.;
    27426: 2239:		(*nodelist)[ii].za = 0.;
    27426: 2240:		(*nodelist)[ii].q100 = 0.;
    27426: 2241:		(*nodelist)[ii].q010 = 0.;
    27426: 2242:		(*nodelist)[ii].q001 = 0.;
    27426: 2243:		(*nodelist)[ii].q200 = 0.;
    27426: 2244:		(*nodelist)[ii].q020 = 0.;
    27426: 2245:		(*nodelist)[ii].q002 = 0.;
    27426: 2246:		(*nodelist)[ii].q101 = 0.;
    27426: 2247:		(*nodelist)[ii].q110 = 0.;
    27426: 2248:		(*nodelist)[ii].q011 = 0.;
    27426: 2249:		(*nodelist)[ii].q300 = 0.;
    27426: 2250:		(*nodelist)[ii].q030 = 0.;
    27426: 2251:		(*nodelist)[ii].q003 = 0.;
    27426: 2252:		(*nodelist)[ii].q210 = 0.;
    27426: 2253:		(*nodelist)[ii].q120 = 0.;
    27426: 2254:		(*nodelist)[ii].q201 = 0.;
    27426: 2255:		(*nodelist)[ii].q102 = 0.;
    27426: 2256:		(*nodelist)[ii].q021 = 0.;
    27426: 2257:		(*nodelist)[ii].q012 = 0.;
    27426: 2258:		(*nodelist)[ii].q111 = 0.;
        -: 2259:#ifdef FOURTH
        -: 2260:		(*nodelist)[ii].q400 = 0.;
        -: 2261:		(*nodelist)[ii].q040 = 0.;
        -: 2262:		(*nodelist)[ii].q004 = 0.;
        -: 2263:		(*nodelist)[ii].q310 = 0.;
        -: 2264:		(*nodelist)[ii].q130 = 0.;
        -: 2265:		(*nodelist)[ii].q301 = 0.;
        -: 2266:		(*nodelist)[ii].q103 = 0.;
        -: 2267:		(*nodelist)[ii].q031 = 0.;
        -: 2268:		(*nodelist)[ii].q013 = 0.;
        -: 2269:		(*nodelist)[ii].q220 = 0.;
        -: 2270:		(*nodelist)[ii].q202 = 0.;
        -: 2271:		(*nodelist)[ii].q022 = 0.;
        -: 2272:		(*nodelist)[ii].q211 = 0.;
        -: 2273:		(*nodelist)[ii].q121 = 0.;
        -: 2274:		(*nodelist)[ii].q112 = 0.;
        -: 2275:#endif
        -: 2276:#ifdef FIFTH
        -: 2277:		(*nodelist)[ii].q500 = 0.;
        -: 2278:		(*nodelist)[ii].q050 = 0.;
        -: 2279:		(*nodelist)[ii].q005 = 0.;
        -: 2280:		(*nodelist)[ii].q410 = 0.;
        -: 2281:		(*nodelist)[ii].q140 = 0.;
        -: 2282:		(*nodelist)[ii].q401 = 0.;
        -: 2283:		(*nodelist)[ii].q104 = 0.;
        -: 2284:		(*nodelist)[ii].q041 = 0.;
        -: 2285:		(*nodelist)[ii].q014 = 0.;
        -: 2286:		(*nodelist)[ii].q320 = 0.;
        -: 2287:		(*nodelist)[ii].q230 = 0.;
        -: 2288:		(*nodelist)[ii].q302 = 0.;
        -: 2289:		(*nodelist)[ii].q203 = 0.;
        -: 2290:		(*nodelist)[ii].q032 = 0.;
        -: 2291:		(*nodelist)[ii].q023 = 0.;
        -: 2292:		(*nodelist)[ii].q221 = 0.;
        -: 2293:		(*nodelist)[ii].q212 = 0.;
        -: 2294:		(*nodelist)[ii].q122 = 0.;
        -: 2295:		(*nodelist)[ii].q311 = 0.;
        -: 2296:		(*nodelist)[ii].q131 = 0.;
        -: 2297:		(*nodelist)[ii].q113 = 0.;
        -: 2298:#endif
    27426: 2299:		(*nodelist)[ii].first = -1;
    27426: 2300:		(*nodelist)[ii].last = -1;
    27426: 2301:		(*nodelist)[ii].innode = 0;
        -: 2302:	}
       88: 2303:}
function _Z6loop_5v called 88 returned 100% blocks executed 100%
       88: 2304:void loop_5(){
   843304: 2305:	for( ii=0; ii< imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2306:	{
   843216: 2307:		j = ii*4;
   843216: 2308:		ix = ((*vector_loop)[j] - xmin )/mmbox;
   843216: 2309:		iy = ((*vector_loop)[j+1] - ymin )/mmbox;
   843216: 2310:		iz = ((*vector_loop)[j+2] - zmin )/mmbox;
   843216: 2311:		inode = ((iz*ny)+iy)*nx + ix;
   843216: 2312:		(*atomlist)[ii].which = inode;
        -: 2313:/* DEBUG
        -: 2314:	printf(" error %f %f %f %d %d %d %d\n",
        -: 2315:		(*vector_loop)[j],(*vector_loop)[j+1],(*vector_loop)[j+2],ix,iy,iz,inode);
        -: 2316:
        -: 2317:ENDDEBUG */
        -: 2318:	}
        -: 2319:
       88: 2320:}
function _Z6loop_6v called 88 returned 100% blocks executed 100%
       88: 2321:void loop_6(){
    27514: 2322:	for( inode = 0; inode < nx*ny*nz; inode++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2323:	{
        -: 2324:	/* first find the first atom which belongs to me */
143312009: 2325:		for( ii = 0; ii< imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2326:		{
143303720: 2327:			if( (*atomlist)[ii].which == inode)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 2328:			{
    19137: 2329:				(*nodelist)[inode].first = ii;
    19137: 2330:				(*nodelist)[inode].last = ii;
    19137: 2331:				(*nodelist)[inode].innode += 1;
    19137: 2332:				ap = (*atomlist)[ii].who;
    19137: 2333:				break;
        -: 2334:			}
        -: 2335:		}
        -: 2336:	/* only if i_loop'm not null */
    27426: 2337:		if( ii != imax )
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -: 2338:		{	
119530486: 2339:			for( ii= (*nodelist)[inode].first; ii < imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2340:			{
119511349: 2341:				if( (*atomlist)[ii].which == inode)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 2342:				{
   843216: 2343:					(*atomlist)[(*nodelist)[inode].last].next  = ii;
   843216: 2344:					(*nodelist)[inode].last = ii;
   843216: 2345:					(*nodelist)[inode].innode += 1;
   843216: 2346:					ap = (*atomlist)[ii].who;
   843216: 2347:					xt = ap->x + loop_lambda*ap->dx - (*nodelist)[inode].xc;
   843216: 2348:					yt = ap->y + loop_lambda*ap->dy - (*nodelist)[inode].yc;
   843216: 2349:					zt = ap->z + loop_lambda*ap->dz - (*nodelist)[inode].zc;
   843216: 2350:					(*nodelist)[inode].sqp +=  ap->q;
   843216: 2351:					(*nodelist)[inode].sa +=  ap->a;
   843216: 2352:					(*nodelist)[inode].xa +=  ap->a*xt;
   843216: 2353:					(*nodelist)[inode].ya +=  ap->a*yt;
   843216: 2354:					(*nodelist)[inode].za +=  ap->a*zt;
   843216: 2355:					xt2 = xt*xt;
   843216: 2356:					xt3 = xt2*xt;
   843216: 2357:					xt4 = xt3*xt;
   843216: 2358:					yt2 = yt*yt;
   843216: 2359:					yt3 = yt2*yt;
   843216: 2360:					yt4 = yt3*yt;
   843216: 2361:					zt2 = zt*zt;
   843216: 2362:					zt3 = zt2*zt;
   843216: 2363:					zt4 = zt3*zt;
   843216: 2364:					(*nodelist)[inode].q100 += ap->q*xt;
   843216: 2365:					(*nodelist)[inode].q010 += ap->q*yt;
   843216: 2366:					(*nodelist)[inode].q001 += ap->q*zt;
   843216: 2367:					(*nodelist)[inode].q200 += ap->q*xt2;
   843216: 2368:					(*nodelist)[inode].q020 += ap->q*yt2;
   843216: 2369:					(*nodelist)[inode].q002 += ap->q*zt2;
   843216: 2370:					(*nodelist)[inode].q101 += ap->q*xt*zt;
   843216: 2371:					(*nodelist)[inode].q110 += ap->q*xt*yt;
   843216: 2372:					(*nodelist)[inode].q011 += ap->q*yt*zt;
   843216: 2373:					(*nodelist)[inode].q300 += ap->q*xt3;
   843216: 2374:					(*nodelist)[inode].q030 += ap->q*yt3;
   843216: 2375:					(*nodelist)[inode].q003 += ap->q*zt3;
   843216: 2376:					(*nodelist)[inode].q210 += ap->q*xt2*yt;
   843216: 2377:					(*nodelist)[inode].q120 += ap->q*xt*yt2;
   843216: 2378:					(*nodelist)[inode].q201 += ap->q*xt2*zt;
   843216: 2379:					(*nodelist)[inode].q102 += ap->q*xt*zt2;
   843216: 2380:					(*nodelist)[inode].q021 += ap->q*yt2*zt;
   843216: 2381:					(*nodelist)[inode].q012 += ap->q*yt*zt2;
   843216: 2382:					(*nodelist)[inode].q111 += ap->q*xt*yt*zt;
        -: 2383:#ifdef FOURTH
        -: 2384:					(*nodelist)[inode].q400 += ap->q*xt4;
        -: 2385:					(*nodelist)[inode].q040 += ap->q*yt4;
        -: 2386:					(*nodelist)[inode].q004 += ap->q*zt4;
        -: 2387:					(*nodelist)[inode].q310 += ap->q*xt3*yt;
        -: 2388:					(*nodelist)[inode].q130 += ap->q*xt*yt3;
        -: 2389:					(*nodelist)[inode].q301 += ap->q*xt3*zt;
        -: 2390:					(*nodelist)[inode].q103 += ap->q*xt*zt3;
        -: 2391:					(*nodelist)[inode].q031 += ap->q*yt3*zt;
        -: 2392:					(*nodelist)[inode].q013 += ap->q*yt*zt3;
        -: 2393:					(*nodelist)[inode].q220 += ap->q*xt2*yt2;
        -: 2394:					(*nodelist)[inode].q202 += ap->q*xt2*zt2;
        -: 2395:					(*nodelist)[inode].q022 += ap->q*yt2*zt2;
        -: 2396:					(*nodelist)[inode].q211 += ap->q*xt2*yt*zt;
        -: 2397:					(*nodelist)[inode].q121 += ap->q*xt*yt2*zt;
        -: 2398:					(*nodelist)[inode].q112 += ap->q*xt*yt*zt2;
        -: 2399:#endif
        -: 2400:#ifdef FIFTH
        -: 2401:					(*nodelist)[inode].q500 += ap->q*xt4*xt;
        -: 2402:					(*nodelist)[inode].q050 += ap->q*yt4*yt;
        -: 2403:					(*nodelist)[inode].q005 += ap->q*zt4*zt;
        -: 2404:					(*nodelist)[inode].q410 += ap->q*xt4*yt;
        -: 2405:					(*nodelist)[inode].q140 += ap->q*yt4*xt;
        -: 2406:					(*nodelist)[inode].q401 += ap->q*xt4*zt;
        -: 2407:					(*nodelist)[inode].q104 += ap->q*zt4*xt;
        -: 2408:					(*nodelist)[inode].q041 += ap->q*yt4*zt;
        -: 2409:					(*nodelist)[inode].q014 += ap->q*zt4*yt;
        -: 2410:					(*nodelist)[inode].q320 += ap->q*xt3*yt2;
        -: 2411:					(*nodelist)[inode].q230 += ap->q*yt3*xt2;
        -: 2412:					(*nodelist)[inode].q302 += ap->q*xt3*zt2;
        -: 2413:					(*nodelist)[inode].q203 += ap->q*zt3*xt2;
        -: 2414:					(*nodelist)[inode].q032 += ap->q*yt3*zt2;
        -: 2415:					(*nodelist)[inode].q023 += ap->q*zt3*yt2;
        -: 2416:					(*nodelist)[inode].q221 += ap->q*xt2*yt2*zt;
        -: 2417:					(*nodelist)[inode].q212 += ap->q*xt2*yt*zt2;
        -: 2418:					(*nodelist)[inode].q122 += ap->q*xt*yt2*zt2;
        -: 2419:					(*nodelist)[inode].q311 += ap->q*xt3*yt*zt;
        -: 2420:					(*nodelist)[inode].q131 += ap->q*xt*yt3*zt;
        -: 2421:					(*nodelist)[inode].q113 += ap->q*xt*yt*zt3;
        -: 2422:#endif
        -: 2423:				}
        -: 2424:			}/* ii */
        -: 2425:		}/* checking if ii != imax */
        -: 2426:	}/* inode */
        -: 2427:
        -: 2428:	/*END OF THE INODE FOR*/
       88: 2429:}
function _Z6loop_7v called 88 returned 100% blocks executed 100%
       88: 2430:void loop_7(){
    27514: 2431:	for( ii = 0; ii < nx*ny*nz; ii ++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2432:	{
    27426: 2433:		(*nodelist)[ii].sqp *= k;
    27426: 2434:		(*nodelist)[ii].q100 *= k;
    27426: 2435:		(*nodelist)[ii].q010 *= k;
    27426: 2436:		(*nodelist)[ii].q001 *= k;
    27426: 2437:		(*nodelist)[ii].q200 *= .5*k;
    27426: 2438:		(*nodelist)[ii].q020 *= .5*k;
    27426: 2439:		(*nodelist)[ii].q002 *= .5*k;
    27426: 2440:		(*nodelist)[ii].q101 *= k;
    27426: 2441:		(*nodelist)[ii].q110 *= k;
    27426: 2442:		(*nodelist)[ii].q011 *= k;
    27426: 2443:		(*nodelist)[ii].q300 *= xt*k;
    27426: 2444:		(*nodelist)[ii].q030 *= xt*k;
    27426: 2445:		(*nodelist)[ii].q003 *= xt*k;
    27426: 2446:		(*nodelist)[ii].q210 *= 0.5*k;
    27426: 2447:		(*nodelist)[ii].q120 *= 0.5*k;
    27426: 2448:		(*nodelist)[ii].q201 *= 0.5*k;
    27426: 2449:		(*nodelist)[ii].q102 *= 0.5*k;
    27426: 2450:		(*nodelist)[ii].q021 *= 0.5*k;
    27426: 2451:		(*nodelist)[ii].q012 *= 0.5*k;
    27426: 2452:		(*nodelist)[ii].q111 *= k;
        -: 2453:#ifdef FOURTH
        -: 2454:		(*nodelist)[ii].q400 *= yt*k;
        -: 2455:		(*nodelist)[ii].q040 *= yt*k;
        -: 2456:		(*nodelist)[ii].q004 *= yt*k;
        -: 2457:		(*nodelist)[ii].q310 *= xt*k;
        -: 2458:		(*nodelist)[ii].q130 *= xt*k;
        -: 2459:		(*nodelist)[ii].q301 *= xt*k;
        -: 2460:		(*nodelist)[ii].q103 *= xt*k;
        -: 2461:		(*nodelist)[ii].q031 *= xt*k;
        -: 2462:		(*nodelist)[ii].q013 *= xt*k;
        -: 2463:		(*nodelist)[ii].q220 *= .25*k;
        -: 2464:		(*nodelist)[ii].q202 *= .25*k;
        -: 2465:		(*nodelist)[ii].q022 *= .25*k;
        -: 2466:		(*nodelist)[ii].q211 *= .5*k;
        -: 2467:		(*nodelist)[ii].q121 *= .5*k;
        -: 2468:		(*nodelist)[ii].q112 *= .5*k;
        -: 2469:#endif
        -: 2470:#ifdef FIFTH
        -: 2471:		(*nodelist)[ii].q500 *= zt*k;
        -: 2472:		(*nodelist)[ii].q050 *= zt*k;
        -: 2473:		(*nodelist)[ii].q005 *= zt*k;
        -: 2474:		(*nodelist)[ii].q410 *= yt*k;
        -: 2475:		(*nodelist)[ii].q140 *= yt*k;
        -: 2476:		(*nodelist)[ii].q401 *= yt*k;
        -: 2477:		(*nodelist)[ii].q104 *= yt*k;
        -: 2478:		(*nodelist)[ii].q041 *= yt*k;
        -: 2479:		(*nodelist)[ii].q014 *= yt*k;
        -: 2480:		(*nodelist)[ii].q320 *= .5*xt*k;
        -: 2481:		(*nodelist)[ii].q230 *= .5*xt*k;
        -: 2482:		(*nodelist)[ii].q302 *= .5*xt*k;
        -: 2483:		(*nodelist)[ii].q203 *= .5*xt*k;
        -: 2484:		(*nodelist)[ii].q032 *= .5*xt*k;
        -: 2485:		(*nodelist)[ii].q023 *= .5*xt*k;
        -: 2486:		(*nodelist)[ii].q221 *= .25*k;
        -: 2487:		(*nodelist)[ii].q212 *= .25*k;
        -: 2488:		(*nodelist)[ii].q122 *= .25*k;
        -: 2489:		(*nodelist)[ii].q311 *= xt*k;
        -: 2490:		(*nodelist)[ii].q131 *= xt*k;
        -: 2491:		(*nodelist)[ii].q113 *= xt*k;
        -: 2492:#endif
        -: 2493:	/*debug
        -: 2494:	printf("%d %f %f\n",ii,(*nodelist)[ii].sqp,(*nodelist)[ii].q100);
        -: 2495:	*/
    27426: 2496:		if( (*nodelist)[ii].sa != 0.)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -: 2497:		{
    19137: 2498:			(*nodelist)[ii].xa = (*nodelist)[ii].xa/(*nodelist)[ii].sa;
    19137: 2499:			(*nodelist)[ii].ya = (*nodelist)[ii].ya/(*nodelist)[ii].sa;
    19137: 2500:			(*nodelist)[ii].za = (*nodelist)[ii].za/(*nodelist)[ii].sa;
        -: 2501:		}
    27426: 2502:		(*nodelist)[ii].xa += (*nodelist)[ii].xc;
    27426: 2503:		(*nodelist)[ii].ya += (*nodelist)[ii].yc;
    27426: 2504:		(*nodelist)[ii].za += (*nodelist)[ii].zc;
        -: 2505:/* correct for double counting */
    27426: 2506:		(*nodelist)[ii].sa  *= .5;
        -: 2507:	}
        -: 2508:
       88: 2509:}
function _Z6loop_8v called 88 returned 100% blocks executed 100%
       88: 2510:void loop_8(){
   843304: 2511:	for( ii=0; ii< jj; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2512:	{
   843216: 2513:		a1 = (*atomall)[ii];
   843216: 2514:		a1-> px = a1->x + loop_lambda*a1->dx;
   843216: 2515:		a1-> py = a1->y + loop_lambda*a1->dy;
   843216: 2516:		a1-> pz = a1->z + loop_lambda*a1->dz;
   843216: 2517:		a1 -> VP = 0.;
   843216: 2518:		a1 -> dpx = 0.;
   843216: 2519:		a1 -> dpy = 0.;
   843216: 2520:		a1 -> dpz = 0.;
   843216: 2521:		a1 -> qxx = 0.;
   843216: 2522:		a1 -> qxy = 0.;
   843216: 2523:		a1 -> qxz = 0.;
   843216: 2524:		a1 -> qyy = 0.;
   843216: 2525:		a1 -> qyz = 0.;
   843216: 2526:		a1 -> qzz = 0.;
        -: 2527:#ifdef CUBIC
        -: 2528:		a1 -> qxxx = 0.;
        -: 2529:		a1 -> qxxy = 0.;
        -: 2530:		a1 -> qxxz = 0.;
        -: 2531:		a1 -> qxyy = 0.;
        -: 2532:		a1 -> qxyz = 0.;
        -: 2533:		a1 -> qxzz = 0.;
        -: 2534:		a1 -> qyyy = 0.;
        -: 2535:		a1 -> qyyz = 0.;
        -: 2536:		a1 -> qyzz = 0.;
        -: 2537:		a1 -> qzzz = 0.;
        -: 2538:#endif
169486416: 2539:		for( j=0; j< NCLOSE; j++) 
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
168643200: 2540:			a1->close[j] = NULL;
        -: 2541:
        -: 2542:	}/* end of initializations */
        -: 2543:
       88: 2544:}
function _Z6loop_9v called 88 returned 100% blocks executed 98%
       88: 2545:void loop_9(){
   843304: 2546:	for( ii=0; ii<  jj; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2547:	{ /* if this is met we update the expansion for this atom */
        -: 2548:/*	a1 = (*atomall)[ii];
        -: 2549:	atomall will be reused in this loop so we refer to atomlist
        -: 2550:	*/
   843216: 2551:		a1 = (*atomlist)[ii].who;
   843216: 2552:		inclose = 0;
        -: 2553:/* loop over the nodes 
        -: 2554:   if the node is mine or a neighbor then use an
        -: 2555:   explicit summation
        -: 2556:   otherwise use the MM node */
   843216: 2557:		ix = (a1->px  - xmin )/mmbox ;
   843216: 2558:		iy = (a1->py  - ymin )/mmbox ;
   843216: 2559:		iz = (a1->pz  - zmin )/mmbox ;
   843216: 2560:		naybor[0] = ((iz*ny)+iy)*nx + ix;
   843216: 2561:		naybor[1] = ((iz*ny)+iy)*nx + ix+1;
   843216: 2562:		naybor[2] = ((iz*ny)+iy)*nx + ix-1;
   843216: 2563:		naybor[3] = ((iz*ny)+iy)*nx+nx + ix;
   843216: 2564:		naybor[4] = ((iz*ny)+iy)*nx-nx + ix;
   843216: 2565:		naybor[5] = ((iz*ny)+iy)*nx+nx + ix+1;
   843216: 2566:		naybor[6] = ((iz*ny)+iy)*nx+nx + ix-1;
   843216: 2567:		naybor[7] = ((iz*ny)+iy)*nx-nx + ix+1;
   843216: 2568:		naybor[8] = ((iz*ny)+iy)*nx-nx + ix-1;
   843216: 2569:		naybor[9] = ((iz*ny)+ny+iy)*nx + ix;
   843216: 2570:		naybor[10] = ((iz*ny)+ny+iy)*nx + ix+1;
   843216: 2571:		naybor[11] = ((iz*ny)+ny+iy)*nx + ix-1;
   843216: 2572:		naybor[12] = ((iz*ny)+ny+iy)*nx+nx + ix;
   843216: 2573:		naybor[13] = ((iz*ny)+ny+iy)*nx-nx + ix;
   843216: 2574:		naybor[14] = ((iz*ny)+ny+iy)*nx+nx + ix+1;
   843216: 2575:		naybor[15] = ((iz*ny)+ny+iy)*nx+nx + ix-1;
   843216: 2576:		naybor[16] = ((iz*ny)+ny+iy)*nx-nx + ix+1;
   843216: 2577:		naybor[17] = ((iz*ny)+ny+iy)*nx-nx + ix-1;
   843216: 2578:		naybor[18] = ((iz*ny)-ny+iy)*nx + ix;
   843216: 2579:		naybor[19] = ((iz*ny)-ny+iy)*nx + ix+1;
   843216: 2580:		naybor[20] = ((iz*ny)-ny+iy)*nx + ix-1;
   843216: 2581:		naybor[21] = ((iz*ny)-ny+iy)*nx+nx + ix;
   843216: 2582:		naybor[22] = ((iz*ny)-ny+iy)*nx-nx + ix;
   843216: 2583:		naybor[23] = ((iz*ny)-ny+iy)*nx+nx + ix+1;
   843216: 2584:		naybor[24] = ((iz*ny)-ny+iy)*nx+nx + ix-1;
   843216: 2585:		naybor[25] = ((iz*ny)-ny+iy)*nx-nx + ix+1;
   843216: 2586:		naybor[26] = ((iz*ny)-ny+iy)*nx-nx + ix-1;
        -: 2587:		
        -: 2588:	/*INNER INODE FOR*/	
263639148: 2589:		for( inode = 0; inode < nx*ny*nz; inode ++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2590:		{/* loop over all mm nodes */
        -: 2591:	/* check the origin */
7043382034: 2592:			for(j=0; j< 27; j++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 2593:			{  
6802647797: 2594:				if( inode == naybor[j]) break; 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 2595:			}
262795932: 2596:			if( j == 27  )
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 2597:			{ /* then use mm */
240734237: 2598:				if( (*nodelist)[inode].innode > 0 )
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -: 2599:				{
        -: 2600:/* $%$%$%$%$  the expansion for f(r) goes here */
        -: 2601:/* first the a terms */
        -: 2602:	/*
        -: 2603:	xt = (*nodelist)[inode].xa - a1->px;
        -: 2604:	yt = (*nodelist)[inode].ya - a1->py;
        -: 2605:	zt = (*nodelist)[inode].za - a1->pz;
        -: 2606:	r = one/(xt*xt + yt*yt + zt*zt);
        -: 2607:	r0 = sqrt(r);
        -: 2608:	r = r*r*r;
        -: 2609:	k = -(*nodelist)[inode].sa *a1->a*r;
        -: 2610:	a1->VP  += k/r;
        -: 2611:	k *= six*r0; 
        -: 2612:	xt *= r0;
        -: 2613:	yt *= r0;
        -: 2614:	zt *= r0;
        -: 2615:	a1->dpx += k*xt;
        -: 2616:	a1->dpy += k*yt;
        -: 2617:	a1->dpz += k*zt;
        -: 2618:	k *= eight*r0;
        -: 2619:	a1->qxx -= k *(xt*xt -eightth);
        -: 2620:	a1->qxy -= k*xt*yt;
        -: 2621:	a1->qxz -= k*xt*zt;
        -: 2622:	a1->qyy -= k *(yt*yt -eightth);
        -: 2623:	a1->qyz -= k*yt*zt;
        -: 2624:	a1->qzz -= k *(zt*zt -eightth);
        -: 2625:	*/
        -: 2626:/* now do the multipole expansion for the electrostatic terms */
        -: 2627:/* note that dielectric is included in the multipole expansion */
163494878: 2628:					xt = (*nodelist)[inode].xc - a1->px;
163494878: 2629:					yt = (*nodelist)[inode].yc - a1->py;
163494878: 2630:					zt = (*nodelist)[inode].zc - a1->pz;
163494878: 2631:					r = one/(xt*xt + yt*yt + zt*zt);
163494878: 2632:					r0 = sqrt(r);
163494878: 2633:					c1 =  -r*r0;
163494878: 2634:					c2 = -three*c1*r;
163494878: 2635:					c3 = -five*c2*r;
163494878: 2636:					c4 = -seven*c3*r;
163494878: 2637:					c5 = -nine*c4*r;
163494878: 2638:					xt2 = xt*xt;
163494878: 2639:					xt3 = xt2*xt;
163494878: 2640:					xt4 = xt3*xt;
163494878: 2641:					yt2 = yt*yt;
163494878: 2642:					yt3 = yt2*yt;
163494878: 2643:					yt4 = yt3*yt;
163494878: 2644:					zt2 = zt*zt;
163494878: 2645:					zt3 = zt2*zt;
163494878: 2646:					zt4 = zt3*zt;
163494878: 2647:					a1->VP += (*nodelist)[inode].sqp*a1->q*r0;
163494878: 2648:					k = c1*a1->q*xt;
163494878: 2649:					a1->VP += k*(*nodelist)[inode].q100;
163494878: 2650:					a1->dpx += k*(*nodelist)[inode].sqp;
163494878: 2651:					k = c1*a1->q*yt;
163494878: 2652:					a1->VP += k*(*nodelist)[inode].q010;
163494878: 2653:					a1->dpy += k*(*nodelist)[inode].sqp;
163494878: 2654:					k = c1*a1->q*zt;
163494878: 2655:					a1->VP += k*(*nodelist)[inode].q001;
163494878: 2656:					a1->dpz += k*(*nodelist)[inode].sqp;
        -: 2657:/* n=2 */	
163494878: 2658:					k = (c2*xt2 +c1)*a1->q;
163494878: 2659:					a1->VP += k*(*nodelist)[inode].q200;
163494878: 2660:					a1->dpx += k*(*nodelist)[inode].q100;
163494878: 2661:					a1->qxx += k*(*nodelist)[inode].sqp;
163494878: 2662:					k = (c2*yt2 +c1)*a1->q;
163494878: 2663:					a1->VP += k*(*nodelist)[inode].q020;
163494878: 2664:					a1->dpy += k*(*nodelist)[inode].q010;
163494878: 2665:					a1->qyy += k*(*nodelist)[inode].sqp;
163494878: 2666:					k = (c2*zt2 +c1)*a1->q;
163494878: 2667:					a1->VP += k*(*nodelist)[inode].q002;
163494878: 2668:					a1->dpz += k*(*nodelist)[inode].q001;
163494878: 2669:					a1->qzz += k*(*nodelist)[inode].sqp;
163494878: 2670:					k = c2*xt*yt*a1->q;
163494878: 2671:					a1->VP += k*(*nodelist)[inode].q110;
163494878: 2672:					a1->dpx += k*(*nodelist)[inode].q010;
163494878: 2673:					a1->dpy += k*(*nodelist)[inode].q100;
163494878: 2674:					a1->qxy += k*(*nodelist)[inode].sqp;
163494878: 2675:					k = c2*xt*zt*a1->q;
163494878: 2676:					a1->VP += k*(*nodelist)[inode].q101;
163494878: 2677:					a1->dpx += k*(*nodelist)[inode].q001;
163494878: 2678:					a1->dpz += k*(*nodelist)[inode].q100;
163494878: 2679:					a1->qxz += k*(*nodelist)[inode].sqp;
163494878: 2680:					k = c2*yt*zt*a1->q;
163494878: 2681:					a1->VP += k*(*nodelist)[inode].q011;
163494878: 2682:					a1->dpy += k*(*nodelist)[inode].q001;
163494878: 2683:					a1->dpz += k*(*nodelist)[inode].q010;
163494878: 2684:					a1->qyz += k*(*nodelist)[inode].sqp;
        -: 2685:/* n=3 */	
163494878: 2686:					k = (c3*xt3 +3*c2*xt)*a1->q;
163494878: 2687:					a1->VP += k*(*nodelist)[inode].q300;
163494878: 2688:					a1->dpx += k*(*nodelist)[inode].q200;
163494878: 2689:					a1->qxx += k*(*nodelist)[inode].q100;
163494878: 2690:					k = (c3*yt3 +3*c2*yt)*a1->q;
163494878: 2691:					a1->VP += k*(*nodelist)[inode].q030;
163494878: 2692:					a1->dpy += k*(*nodelist)[inode].q020;
163494878: 2693:					a1->qyy += k*(*nodelist)[inode].q010;
163494878: 2694:					k = (c3*zt3 +3*c2*zt)*a1->q;
163494878: 2695:					a1->VP += k*(*nodelist)[inode].q003;
163494878: 2696:					a1->dpz += k*(*nodelist)[inode].q002;
163494878: 2697:					a1->qzz += k*(*nodelist)[inode].q001;
163494878: 2698:					k = (c3*xt2*yt+c2*yt)*a1->q;
163494878: 2699:					a1->VP += k*(*nodelist)[inode].q210;
163494878: 2700:					a1->dpx += k*(*nodelist)[inode].q110;
163494878: 2701:					a1->dpy += k*(*nodelist)[inode].q200;
163494878: 2702:					a1->qxx += k*(*nodelist)[inode].q010;
163494878: 2703:					a1->qxy += k*(*nodelist)[inode].q100;
163494878: 2704:					k = (c3*yt2*xt+c2*xt)*a1->q;
163494878: 2705:					a1->VP += k*(*nodelist)[inode].q120;
163494878: 2706:					a1->dpx += k*(*nodelist)[inode].q020;
163494878: 2707:					a1->dpy += k*(*nodelist)[inode].q110;
163494878: 2708:					a1->qyy += k*(*nodelist)[inode].q100;
163494878: 2709:					a1->qxy += k*(*nodelist)[inode].q010;
163494878: 2710:					k = (c3*xt2*zt+c2*zt)*a1->q;
163494878: 2711:					a1->VP += k*(*nodelist)[inode].q201;
163494878: 2712:					a1->dpx += k*(*nodelist)[inode].q101;
163494878: 2713:					a1->dpz += k*(*nodelist)[inode].q200;
163494878: 2714:					a1->qxx += k*(*nodelist)[inode].q001;
163494878: 2715:					a1->qxz += k*(*nodelist)[inode].q100;
163494878: 2716:					k = (c3*zt2*xt+c2*xt)*a1->q;
163494878: 2717:					a1->VP += k*(*nodelist)[inode].q102;
163494878: 2718:					a1->dpx += k*(*nodelist)[inode].q002;
163494878: 2719:					a1->dpz += k*(*nodelist)[inode].q101;
163494878: 2720:					a1->qzz += k*(*nodelist)[inode].q100;
163494878: 2721:					a1->qxz += k*(*nodelist)[inode].q001;
163494878: 2722:					k = (c3*yt2*zt+c2*zt)*a1->q;
163494878: 2723:					a1->VP += k*(*nodelist)[inode].q021;
163494878: 2724:					a1->dpy += k*(*nodelist)[inode].q011;
163494878: 2725:					a1->dpz += k*(*nodelist)[inode].q020;
163494878: 2726:					a1->qyy += k*(*nodelist)[inode].q001;
163494878: 2727:					a1->qyz += k*(*nodelist)[inode].q010;
163494878: 2728:					k = (c3*zt2*yt+c2*yt)*a1->q;
163494878: 2729:					a1->VP += k*(*nodelist)[inode].q012;
163494878: 2730:					a1->dpy += k*(*nodelist)[inode].q002;
163494878: 2731:					a1->dpz += k*(*nodelist)[inode].q011;
163494878: 2732:					a1->qzz += k*(*nodelist)[inode].q010;
163494878: 2733:					a1->qyz += k*(*nodelist)[inode].q001;
163494878: 2734:					k = (c3*zt*yt*xt)*a1->q;
163494878: 2735:					a1->VP += k*(*nodelist)[inode].q111;
163494878: 2736:					a1->dpx += k*(*nodelist)[inode].q011;
163494878: 2737:					a1->dpy += k*(*nodelist)[inode].q101;
163494878: 2738:					a1->dpz += k*(*nodelist)[inode].q110;
        -: 2739:/* n=4 */	
        -: 2740:#ifdef FOURTH
        -: 2741:					k = (c4*xt4 +six*c3*(xt2) +three*c2)*a1->q;
        -: 2742:					a1->VP += k*(*nodelist)[inode].q400;
        -: 2743:					a1->dpx += k*(*nodelist)[inode].q300;
        -: 2744:					a1->qxx += k*(*nodelist)[inode].q200;
        -: 2745:					k = (c4*yt4 +six*c3*(yt2) +three*c2)*a1->q;
        -: 2746:					a1->VP += k*(*nodelist)[inode].q040;
        -: 2747:					a1->dpy += k*(*nodelist)[inode].q030;
        -: 2748:					a1->qyy += k*(*nodelist)[inode].q020;
        -: 2749:					k = (c4*zt4 +six*c3*(zt2) +three*c2)*a1->q;
        -: 2750:					a1->VP += k*(*nodelist)[inode].q004;
        -: 2751:					a1->dpz += k*(*nodelist)[inode].q003;
        -: 2752:					a1->qzz += k*(*nodelist)[inode].q002;
        -: 2753:					k = (c4*xt3*yt + three*c3*xt*yt)*a1->q;
        -: 2754:					a1->VP += k*(*nodelist)[inode].q310;
        -: 2755:					a1->dpx += k*(*nodelist)[inode].q210;
        -: 2756:					a1->dpy += k*(*nodelist)[inode].q300;
        -: 2757:					a1->qxx += k*(*nodelist)[inode].q110;
        -: 2758:					a1->qxy += k*(*nodelist)[inode].q200;
        -: 2759:					k = (c4*yt3*xt + three*c3*xt*yt)*a1->q;
        -: 2760:					a1->VP += k*(*nodelist)[inode].q130;
        -: 2761:					a1->dpx += k*(*nodelist)[inode].q030;
        -: 2762:					a1->dpy += k*(*nodelist)[inode].q120;
        -: 2763:					a1->qyy += k*(*nodelist)[inode].q110;
        -: 2764:					a1->qxy += k*(*nodelist)[inode].q020;
        -: 2765:					k = (c4*xt3*zt + three*c3*xt*zt)*a1->q;
        -: 2766:					a1->VP += k*(*nodelist)[inode].q301;
        -: 2767:					a1->dpx += k*(*nodelist)[inode].q201;
        -: 2768:					a1->dpz += k*(*nodelist)[inode].q300;
        -: 2769:					a1->qxx += k*(*nodelist)[inode].q101;
        -: 2770:					a1->qxz += k*(*nodelist)[inode].q200;
        -: 2771:					k = (c4*zt3*yt + three*c3*xt*yt)*a1->q;
        -: 2772:					a1->VP += k*(*nodelist)[inode].q103;
        -: 2773:					a1->dpx += k*(*nodelist)[inode].q003;
        -: 2774:					a1->dpz += k*(*nodelist)[inode].q102;
        -: 2775:					a1->qzz += k*(*nodelist)[inode].q101;
        -: 2776:					a1->qxz += k*(*nodelist)[inode].q002;
        -: 2777:					k = (c4*yt3*zt + three*c3*zt*yt)*a1->q;
        -: 2778:					a1->VP += k*(*nodelist)[inode].q031;
        -: 2779:					a1->dpz += k*(*nodelist)[inode].q030;
        -: 2780:					a1->dpy += k*(*nodelist)[inode].q021;
        -: 2781:					a1->qyy += k*(*nodelist)[inode].q011;
        -: 2782:					a1->qyz += k*(*nodelist)[inode].q020;
        -: 2783:					k = (c4*zt3*yt + three*c3*zt*yt)*a1->q;
        -: 2784:					a1->VP += k*(*nodelist)[inode].q013;
        -: 2785:					a1->dpz += k*(*nodelist)[inode].q012;
        -: 2786:					a1->dpy += k*(*nodelist)[inode].q003;
        -: 2787:					a1->qzz += k*(*nodelist)[inode].q011;
        -: 2788:					a1->qyz += k*(*nodelist)[inode].q002;
        -: 2789:					k = (c4*xt2*yt2 + c3*(xt2+yt2) +c2)*a1->q;
        -: 2790:					a1->VP += k*(*nodelist)[inode].q220;
        -: 2791:					a1->dpx += k*(*nodelist)[inode].q120;
        -: 2792:					a1->dpy += k*(*nodelist)[inode].q210;
        -: 2793:					a1->qxx += k*(*nodelist)[inode].q020;
        -: 2794:					a1->qyy += k*(*nodelist)[inode].q200;
        -: 2795:					a1->qxy += k*(*nodelist)[inode].q110;
        -: 2796:					k = (c4*xt2*zt2 + c3*(xt2+zt2) +c2)*a1->q;
        -: 2797:					a1->VP += k*(*nodelist)[inode].q202;
        -: 2798:					a1->dpx += k*(*nodelist)[inode].q102;
        -: 2799:					a1->dpz += k*(*nodelist)[inode].q201;
        -: 2800:					a1->qxx += k*(*nodelist)[inode].q002;
        -: 2801:					a1->qzz += k*(*nodelist)[inode].q200;
        -: 2802:					a1->qxz += k*(*nodelist)[inode].q101;
        -: 2803:					k = (c4*zt2*yt2 + c3*(zt2+yt2) +c2)*a1->q;
        -: 2804:					a1->VP += k*(*nodelist)[inode].q022;
        -: 2805:					a1->dpz += k*(*nodelist)[inode].q021;
        -: 2806:					a1->dpy += k*(*nodelist)[inode].q012;
        -: 2807:					a1->qzz += k*(*nodelist)[inode].q020;
        -: 2808:					a1->qyy += k*(*nodelist)[inode].q002;
        -: 2809:					a1->qyz += k*(*nodelist)[inode].q011;
        -: 2810:					k = (c4*xt2*yt*zt +c3*yt*zt)*a1->q;
        -: 2811:					a1->VP += k*(*nodelist)[inode].q211;
        -: 2812:					a1->dpz += k*(*nodelist)[inode].q210;
        -: 2813:					a1->dpy += k*(*nodelist)[inode].q201;
        -: 2814:					a1->dpx += k*(*nodelist)[inode].q111;
        -: 2815:					a1->qxx += k*(*nodelist)[inode].q011;
        -: 2816:					a1->qxy += k*(*nodelist)[inode].q101;
        -: 2817:					a1->qyz += k*(*nodelist)[inode].q200;
        -: 2818:					a1->qxz += k*(*nodelist)[inode].q110;
        -: 2819:					k = (c4*xt*yt2*zt +c3*xt*zt)*a1->q;
        -: 2820:					a1->VP += k*(*nodelist)[inode].q121;
        -: 2821:					a1->dpz += k*(*nodelist)[inode].q120;
        -: 2822:					a1->dpy += k*(*nodelist)[inode].q111;
        -: 2823:					a1->dpx += k*(*nodelist)[inode].q021;
        -: 2824:					a1->qyy += k*(*nodelist)[inode].q101;
        -: 2825:					a1->qxy += k*(*nodelist)[inode].q011;
        -: 2826:					a1->qyz += k*(*nodelist)[inode].q110;
        -: 2827:					a1->qxz += k*(*nodelist)[inode].q020;
        -: 2828:					k = (c4*xt*yt*zt2 +c3*yt*xt)*a1->q;
        -: 2829:					a1->VP += k*(*nodelist)[inode].q112;
        -: 2830:					a1->dpz += k*(*nodelist)[inode].q111;
        -: 2831:					a1->dpy += k*(*nodelist)[inode].q102;
        -: 2832:					a1->dpx += k*(*nodelist)[inode].q012;
        -: 2833:					a1->qzz += k*(*nodelist)[inode].q110;
        -: 2834:					a1->qxy += k*(*nodelist)[inode].q002;
        -: 2835:					a1->qxz += k*(*nodelist)[inode].q011;
        -: 2836:					a1->qyz += k*(*nodelist)[inode].q101;
        -: 2837:#endif	
        -: 2838:/* n=5 */	
        -: 2839:#ifdef FIFTH	
        -: 2840:					k = ((c5*xt+9*c4)*xt4  +15*c3*xt)*a1->q;
        -: 2841:					a1->VP += k*(*nodelist)[inode].q500;
        -: 2842:					a1->dpx += k*(*nodelist)[inode].q400;
        -: 2843:					a1->qxx += k*(*nodelist)[inode].q300;
        -: 2844:					k = ((c5*yt+9*c4)*yt4  +15*c3*yt)*a1->q;
        -: 2845:					a1->VP += k*(*nodelist)[inode].q050;
        -: 2846:					a1->dpy += k*(*nodelist)[inode].q040;
        -: 2847:					a1->qyy += k*(*nodelist)[inode].q030;
        -: 2848:					k = ((c5*zt+9*c4)*zt4  +15*c3*zt)*a1->q;
        -: 2849:					a1->VP += k*(*nodelist)[inode].q005;
        -: 2850:					a1->dpz += k*(*nodelist)[inode].q004;
        -: 2851:					a1->qzz += k*(*nodelist)[inode].q003;
        -: 2852:					k = (c5*xt4+six*c4*xt2 +three*c3)*yt*a1->q;
        -: 2853:					a1->VP += k*(*nodelist)[inode].q410;
        -: 2854:					a1->dpx += k*(*nodelist)[inode].q310;
        -: 2855:					a1->dpy += k*(*nodelist)[inode].q400;
        -: 2856:					a1->qxx += k*(*nodelist)[inode].q210;
        -: 2857:					a1->qxy += k*(*nodelist)[inode].q300;
        -: 2858:					k = (c5*yt4+six*c4*yt2 +three*c3)*xt*a1->q;
        -: 2859:					a1->VP += k*(*nodelist)[inode].q140;
        -: 2860:					a1->dpx += k*(*nodelist)[inode].q040;
        -: 2861:					a1->dpy += k*(*nodelist)[inode].q130;
        -: 2862:					a1->qyy += k*(*nodelist)[inode].q120;
        -: 2863:					a1->qxy += k*(*nodelist)[inode].q030;
        -: 2864:					k = (c5*xt4+six*c4*xt2 +three*c3)*zt*a1->q;
        -: 2865:					a1->VP += k*(*nodelist)[inode].q401;
        -: 2866:					a1->dpx += k*(*nodelist)[inode].q301;
        -: 2867:					a1->dpz += k*(*nodelist)[inode].q400;
        -: 2868:					a1->qxx += k*(*nodelist)[inode].q201;
        -: 2869:					a1->qxz += k*(*nodelist)[inode].q300;
        -: 2870:					k = (c5*zt4+six*c4*zt2 +three*c3)*xt*a1->q;
        -: 2871:					a1->VP += k*(*nodelist)[inode].q104;
        -: 2872:					a1->dpx += k*(*nodelist)[inode].q004;
        -: 2873:					a1->dpz += k*(*nodelist)[inode].q103;
        -: 2874:					a1->qzz += k*(*nodelist)[inode].q102;
        -: 2875:					a1->qxz += k*(*nodelist)[inode].q003;
        -: 2876:					k = (c5*yt4+six*c4*yt2 +three*c3)*zt*a1->q;
        -: 2877:					a1->VP += k*(*nodelist)[inode].q041;
        -: 2878:					a1->dpy += k*(*nodelist)[inode].q031;
        -: 2879:					a1->dpz += k*(*nodelist)[inode].q040;
        -: 2880:					a1->qyy += k*(*nodelist)[inode].q021;
        -: 2881:					a1->qyz += k*(*nodelist)[inode].q030;
        -: 2882:					k = (c5*zt4+six*c4*zt2 +three*c3)*yt*a1->q;
        -: 2883:					a1->VP += k*(*nodelist)[inode].q014;
        -: 2884:					a1->dpy += k*(*nodelist)[inode].q004;
        -: 2885:					a1->dpz += k*(*nodelist)[inode].q013;
        -: 2886:					a1->qzz += k*(*nodelist)[inode].q012;
        -: 2887:					a1->qyz += k*(*nodelist)[inode].q003;
        -: 2888:					k = (c5*xt3*yt2 +c4*(three*xt*yt2-xt3) +three*c3*xt)*a1->q;
        -: 2889:					a1->VP += k*(*nodelist)[inode].q320;
        -: 2890:					a1->dpx += k*(*nodelist)[inode].q220;
        -: 2891:					a1->dpy += k*(*nodelist)[inode].q310;
        -: 2892:					a1->qxx += k*(*nodelist)[inode].q120;
        -: 2893:					a1->qxy += k*(*nodelist)[inode].q210;
        -: 2894:					a1->qyy += k*(*nodelist)[inode].q300;
        -: 2895:					k = (c5*yt3*xt2 +c4*(three*yt*xt2-yt3) +three*c3*yt)*a1->q;
        -: 2896:					a1->VP += k*(*nodelist)[inode].q230;
        -: 2897:					a1->dpx += k*(*nodelist)[inode].q130;
        -: 2898:					a1->dpy += k*(*nodelist)[inode].q220;
        -: 2899:					a1->qxx += k*(*nodelist)[inode].q030;
        -: 2900:					a1->qxy += k*(*nodelist)[inode].q120;
        -: 2901:					a1->qyy += k*(*nodelist)[inode].q210;
        -: 2902:					k = (c5*xt3*zt2 +c4*(three*xt*zt2-xt3) +three*c3*xt)*a1->q;
        -: 2903:					a1->VP += k*(*nodelist)[inode].q302;
        -: 2904:					a1->dpx += k*(*nodelist)[inode].q202;
        -: 2905:					a1->dpz += k*(*nodelist)[inode].q301;
        -: 2906:					a1->qxx += k*(*nodelist)[inode].q102;
        -: 2907:					a1->qxz += k*(*nodelist)[inode].q201;
        -: 2908:					a1->qzz += k*(*nodelist)[inode].q300;
        -: 2909:					k = (c5*zt3*xt2 +c4*(three*zt*xt2-zt3) +three*c3*zt)*a1->q;
        -: 2910:					a1->VP += k*(*nodelist)[inode].q203;
        -: 2911:					a1->dpx += k*(*nodelist)[inode].q103;
        -: 2912:					a1->dpz += k*(*nodelist)[inode].q202;
        -: 2913:					a1->qxx += k*(*nodelist)[inode].q003;
        -: 2914:					a1->qxz += k*(*nodelist)[inode].q102;
        -: 2915:					a1->qzz += k*(*nodelist)[inode].q201;
        -: 2916:					k = (c5*yt3*zt2 +c4*(three*yt*zt2-yt3) +three*c3*yt)*a1->q;
        -: 2917:					a1->VP += k*(*nodelist)[inode].q032;
        -: 2918:					a1->dpy += k*(*nodelist)[inode].q022;
        -: 2919:					a1->dpz += k*(*nodelist)[inode].q031;
        -: 2920:					a1->qyy += k*(*nodelist)[inode].q012;
        -: 2921:					a1->qyz += k*(*nodelist)[inode].q021;
        -: 2922:					a1->qzz += k*(*nodelist)[inode].q030;
        -: 2923:					k = (c5*zt3*yt2 +c4*(three*zt*yt2-zt3) +three*c3*zt)*a1->q;
        -: 2924:					a1->VP += k*(*nodelist)[inode].q023;
        -: 2925:					a1->dpy += k*(*nodelist)[inode].q013;
        -: 2926:					a1->dpz += k*(*nodelist)[inode].q022;
        -: 2927:					a1->qyy += k*(*nodelist)[inode].q003;
        -: 2928:					a1->qyz += k*(*nodelist)[inode].q012;
        -: 2929:					a1->qzz += k*(*nodelist)[inode].q021;
        -: 2930:					k = (c5*xt2*yt2 +c4*(xt2+yt2) +c3)*zt*a1->q;
        -: 2931:					a1->VP += k*(*nodelist)[inode].q221;
        -: 2932:					a1->dpx += k*(*nodelist)[inode].q121;
        -: 2933:					a1->dpy += k*(*nodelist)[inode].q211;
        -: 2934:					a1->dpz += k*(*nodelist)[inode].q220;
        -: 2935:					a1->qxx += k*(*nodelist)[inode].q021;
        -: 2936:					a1->qyy += k*(*nodelist)[inode].q201;
        -: 2937:					a1->qxz += k*(*nodelist)[inode].q120;
        -: 2938:					a1->qyz += k*(*nodelist)[inode].q210;
        -: 2939:					k = (c5*xt2*zt2 +c4*(xt2+zt2) +c3)*yt*a1->q;
        -: 2940:					a1->VP += k*(*nodelist)[inode].q212;
        -: 2941:					a1->dpx += k*(*nodelist)[inode].q112;
        -: 2942:					a1->dpy += k*(*nodelist)[inode].q202;
        -: 2943:					a1->dpz += k*(*nodelist)[inode].q211;
        -: 2944:					a1->qxx += k*(*nodelist)[inode].q012;
        -: 2945:					a1->qzz += k*(*nodelist)[inode].q210;
        -: 2946:					a1->qxz += k*(*nodelist)[inode].q111;
        -: 2947:					a1->qyz += k*(*nodelist)[inode].q201;
        -: 2948:					k = (c5*zt2*yt2 +c4*(zt2+yt2) +c3)*xt*a1->q;
        -: 2949:					a1->VP += k*(*nodelist)[inode].q122;
        -: 2950:					a1->dpx += k*(*nodelist)[inode].q022;
        -: 2951:					a1->dpy += k*(*nodelist)[inode].q112;
        -: 2952:					a1->dpz += k*(*nodelist)[inode].q121;
        -: 2953:					a1->qzz += k*(*nodelist)[inode].q120;
        -: 2954:					a1->qyy += k*(*nodelist)[inode].q102;
        -: 2955:					a1->qxy += k*(*nodelist)[inode].q022;
        -: 2956:					a1->qxz += k*(*nodelist)[inode].q022;
        -: 2957:					k = (c5*xt3+three*c4*xt)*yt*zt*a1->q;
        -: 2958:					a1->VP += k*(*nodelist)[inode].q311;						
        -: 2959:					a1->dpx += k*(*nodelist)[inode].q211;
        -: 2960:					a1->dpy += k*(*nodelist)[inode].q301;
        -: 2961:					a1->dpz += k*(*nodelist)[inode].q310;
        -: 2962:					a1->qxx += k*(*nodelist)[inode].q211;
        -: 2963:					a1->qxy += k*(*nodelist)[inode].q201;
        -: 2964:					a1->qxz += k*(*nodelist)[inode].q210;
        -: 2965:					k = (c5*yt3+three*c4*yt)*xt*zt*a1->q;
        -: 2966:					a1->VP += k*(*nodelist)[inode].q131;
        -: 2967:					a1->dpx += k*(*nodelist)[inode].q031;
        -: 2968:					a1->dpy += k*(*nodelist)[inode].q121;
        -: 2969:					a1->dpz += k*(*nodelist)[inode].q130;
        -: 2970:					a1->qyy += k*(*nodelist)[inode].q111;
        -: 2971:					a1->qxy += k*(*nodelist)[inode].q021;
        -: 2972:					a1->qyz += k*(*nodelist)[inode].q120;
        -: 2973:					k = (c5*zt3+three*c4*zt)*yt*xt*a1->q;
        -: 2974:					a1->VP += k*(*nodelist)[inode].q113;
        -: 2975:					a1->dpx += k*(*nodelist)[inode].q013;
        -: 2976:					a1->dpy += k*(*nodelist)[inode].q103;
        -: 2977:					a1->dpz += k*(*nodelist)[inode].q112;
        -: 2978:					a1->qzz += k*(*nodelist)[inode].q111;
        -: 2979:					a1->qyz += k*(*nodelist)[inode].q102;
        -: 2980:					a1->qxz += k*(*nodelist)[inode].q012;
        -: 2981:#endif
        -: 2982:				} /* if innode > 0  end if */
 22061695: 2983:			} else if( (*nodelist)[inode].innode > 0) 
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
        -: 2984:			{ /* if not mm use explicit */
        -: 2985:/* first load the atoms onto atomall */
 19875856: 2986:				imax = 0;
 19875856: 2987:				i_loop = (*nodelist)[inode].first;
 19875856: 2988:				 if( (*nodelist)[inode].innode > 0  && ((*atomlist)[i_loop].who)->serial > a1->serial)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 21% (fallthrough)
branch  3 taken 79%
        -: 2989:				 {  
  4246547: 2990:					(*atomall)[imax++] = (*atomlist)[i_loop].who;
        -: 2991:				 }
        -: 2992:
1176723752: 2993:				for( j=1; j< (*nodelist)[inode].innode -1 ; j++)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -: 2994:				{
1156847896: 2995:					 i_loop = (*atomlist)[i_loop].next;
1156847896: 2996:					 if( ((*atomlist)[i_loop].who)->serial > a1->serial)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 2997:					 {  
583693721: 2998:						(*atomall)[imax++] = (*atomlist)[i_loop].who;
        -: 2999:					 }
        -: 3000:				}
        -: 3001:	/*
        -: 3002:	for( j=0; j< jj; j++)
        -: 3003:	{
        -: 3004:		if( (*atomlist)[j].which == inode && 
        -: 3005:		    (*atomlist)[j].who->serial > a1->serial)
        -: 3006:		    {(*atomall)[imax] = (*atomlist)[j].who;
        -: 3007:		    imax+= 1;}
        -: 3008:	}
        -: 3009:	*/
607816124: 3010:				for( i_loop=0; i_loop< imax; i_loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 3011:				{	
587940268: 3012:					a2 = (*atomall)[i_loop];
587940268: 3013:					j = i_loop*4;
587940268: 3014:					(*vector_loop)[j  ] = a2->px - a1->px ;
587940268: 3015:					(*vector_loop)[j+1] = a2->py - a1->py ;
587940268: 3016:					(*vector_loop)[j+2] = a2->pz - a1->pz ;
        -: 3017:				}
        -: 3018:						
607816124: 3019:				for( i_loop=0; i_loop< imax; i_loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 3020:
        -: 3021:				{
587940268: 3022:					j = i_loop*4;
1175880536: 3023:					(*vector_loop)[j+3] = sqrt((*vector_loop)[j]*(*vector_loop)[j] + (*vector_loop)[j+1]*(*vector_loop)[j+1] +
1175880536: 3024:					 (*vector_loop)[j+2]*(*vector_loop)[j+2]);
        -: 3025:				}
        -: 3026:/* add the new components */
607816124: 3027:				for( i_loop=0; i_loop< imax; i_loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 3028:				{
587940268: 3029:					a2 = (*atomall)[i_loop];
3772713211: 3030:					for( j=0; j< a1->dontuse; j++)
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
3186141607: 3031:					{ if( a2 == a1->excluded[j]) goto SKIPNEW;}
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
586571604: 3032:					j = i_loop*4;
586571604: 3033:					if( (*vector_loop)[j+3] > mxcut || inclose > NCLOSE )
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 3034:					{
559726942: 3035:						r0 = one/(*vector_loop)[j+3];  
559726942: 3036:						r = r0*r0;
559726942: 3037:						r = r*r*r; /* r0^-6 */
559726942: 3038:						xt = a1->q*a2->q*dielectric*r0;
559726942: 3039:						yt = a1->a*a2->a*r;
559726942: 3040:						zt = a1->b*a2->b*r*r;
559726942: 3041:						k = xt - yt + zt;
559726942: 3042:						xt = xt*r0; yt = yt*r0; zt = zt*r0;
559726942: 3043:						k1 = xt - yt*six + zt*twelve;
559726942: 3044:						xt = xt*r0; yt = yt*r0; zt = zt*r0;
559726942: 3045:						k2 = xt*three; ka2 = - yt*six*eight; kb2 =  zt*twelve*14;
        -: 3046:#ifdef CUBIC
        -: 3047:						xt = xt*r0; yt = yt*r0; zt = zt*r0;
        -: 3048:						k3 = -xt*5*3; ka3 =   yt*6*8*10 ; kb3 =  -zt*12*14*16;
        -: 3049:#endif
559726942: 3050:						k1 = -k1;
559726942: 3051:						xt = (*vector_loop)[j]*r0 ;
559726942: 3052:						yt = (*vector_loop)[j+1]*r0 ;
559726942: 3053:						zt = (*vector_loop)[j+2] *r0;
        -: 3054:/*
        -: 3055:	xt = (*vector_loop)[j] ;
        -: 3056:	yt = (*vector_loop)[j+1] ;
        -: 3057:	zt = (*vector_loop)[j+2] ;
        -: 3058:	*/
559726942: 3059:						a1->VP += k;
559726942: 3060:						a2->dpx -= k1*xt;
559726942: 3061:						a1->dpx += k1*xt;
559726942: 3062:						a2->dpy -= k1*yt;
559726942: 3063:						a1->dpy += k1*yt;
559726942: 3064:						a2->dpz -= k1*zt;
559726942: 3065:						a1->dpz += k1*zt;
559726942: 3066:						xt2 = xt*xt; yt2 = yt*yt; zt2 = zt*zt;
559726942: 3067:						a2->qxx -= k2*(xt2 - third) + ka2*(xt2 - eightth)+kb2*(xt2-fourteenth) ;
559726942: 3068:						a1->qxx -= k2*(xt2 - third) + ka2*(xt2 - eightth)+kb2*(xt2-fourteenth) ;
559726942: 3069:						a2->qxy -= (k2+ka2+kb2)*yt*xt;
559726942: 3070:						a1->qxy -= (k2+ka2+kb2)*yt*xt;
559726942: 3071:						a2->qxz -= (k2+ka2+kb2)*zt*xt;
559726942: 3072:						a1->qxz -= (k2+ka2+kb2)*zt*xt;
559726942: 3073:						a2->qyy -= k2*(yt2 - third) + ka2*(yt2 - eightth)+kb2*(yt2-fourteenth) ;
559726942: 3074:						a1->qyy -= k2*(yt2 - third) + ka2*(yt2 - eightth)+kb2*(yt2-fourteenth) ;
559726942: 3075:						a2->qyz -= (k2+ka2+kb2)*yt*zt;
559726942: 3076:						a1->qyz -= (k2+ka2+kb2)*yt*zt;
559726942: 3077:						a2->qzz -= k2*(zt2 - third) + ka2*(zt2 - eightth)+kb2*(zt2-fourteenth) ;
559726942: 3078:						a1->qzz -= k2*(zt2 - third) + ka2*(zt2 - eightth)+kb2*(zt2-fourteenth) ;
        -: 3079:#ifdef CUBIC
        -: 3080:						a2->qxxx -= k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 3081:						a2->qxxx -= ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 3082:						a2->qxxx -= kb3*(xt*xt*xt - xt*( 42./(14*18))); 
        -: 3083:						a1->qxxx += k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 3084:						a1->qxxx += ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 3085:						a1->qxxx += kb3*(xt*xt*xt - xt*( 42./(14*18))); 
        -: 3086:						a2->qxxy -= k3*(yt*xt*xt - yt*( 6./ 15));
        -: 3087:						a2->qxxy -= ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 3088:						a2->qxxy -= kb3*(yt*xt*xt - yt*( 17./ (14*18)));
        -: 3089:						a1->qxxy += k3*(yt*xt*xt - yt*( 6./ 15));
        -: 3090:						a1->qxxy += ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 3091:						a1->qxxy += kb3*(yt*xt*xt - yt*( 17./ (14*18)));
        -: 3092:						a2->qxxz -= k3*(zt*xt*xt - zt*( 6./ 15));
        -: 3093:						a2->qxxz -= ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 3094:						a2->qxxz -= kb3*(zt*xt*xt - zt*( 17./ (14*18)));
        -: 3095:						a1->qxxz += k3*(zt*xt*xt - zt*( 6./ 15));
        -: 3096:						a1->qxxz += ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 3097:						a1->qxxz += kb3*(zt*xt*xt - zt*( 17./ (14*18)));
        -: 3098:						a2->qxyy -= k3*(yt*yt*xt - xt*( 6./ 15));
        -: 3099:						a2->qxyy -= ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 3100:						a2->qxyy -= kb3*(yt*yt*xt - xt*( 17./ (14*18)));
        -: 3101:						a1->qxyy += k3*(yt*yt*xt - xt*( 6./ 15));
        -: 3102:						a1->qxyy += ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 3103:						a1->qxyy += kb3*(yt*yt*xt - xt*( 17./ (14*18)));
        -: 3104:						a2->qxyz -= (k3+ka3+kb3)*yt*zt*xt;
        -: 3105:						a1->qxyz += (k3+ka3+kb3)*yt*zt*xt;
        -: 3106:						a2->qxzz -= k3*(zt*zt*xt - xt*( 6./ 15));
        -: 3107:						a2->qxzz -= ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 3108:						a2->qxzz -= kb3*(zt*zt*xt - xt*( 17./ (14*18)));
        -: 3109:						a1->qxzz += k3*(zt*zt*xt - xt*( 6./ 15));
        -: 3110:						a1->qxzz += ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 3111:						a1->qxzz += kb3*(zt*zt*xt - xt*( 17./ (14*18)));
        -: 3112:						a2->qyyy -= k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 3113:						a2->qyyy -= ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 3114:						a2->qyyy -= kb3*(yt*yt*yt - yt*( 42./(14*18))); 
        -: 3115:						a1->qyyy += k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 3116:						a1->qyyy += ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 3117:						a1->qyyy += kb3*(yt*yt*yt - yt*( 42./(14*18))); 
        -: 3118:						a2->qyyz -= k3*(yt*yt*zt - zt*( 6./ 15));
        -: 3119:						a2->qyyz -= ka3*(yt*yt*zt - zt*( 11./ 80));
        -: 3120:						a2->qyyz -= kb3*(yt*yt*zt - zt*( 17./ (14*18)));
        -: 3121:						a1->qyyz += k3*(yt*yt*zt - zt*( 6./ 15));
        -: 3122:						a1->qyyz += ka3*(yt*yt*zt - zt*(11./ 80));
        -: 3123:						a1->qyyz += kb3*(yt*yt*zt - zt*( 17./ (14*18)));
        -: 3124:						a2->qyzz -= k3*(zt*zt*yt - yt*( 6./ 15));
        -: 3125:						a2->qyzz -= ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 3126:						a2->qyzz -= kb3*(zt*zt*yt - yt*( 17./ (14*18)));
        -: 3127:						a1->qyzz += k3*(zt*zt*yt - yt*( 6./ 15));
        -: 3128:						a1->qyzz += ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 3129:						a1->qyzz += kb3*(zt*zt*yt - yt*( 17./ (14*18)));
        -: 3130:						a2->qzzz -= k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 3131:						a2->qzzz -= ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 3132:						a2->qzzz -= kb3*(zt*zt*zt - zt*( 42./(14*18))); 
        -: 3133:						a1->qzzz += k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 3134:						a1->qzzz += ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 3135:						a1->qzzz += kb3*(zt*zt*zt - zt*( 42./(14*18))); 
        -: 3136:#endif
        -: 3137:					}
        -: 3138:					else {
 26844662: 3139:						a1->close[inclose++] = (*atomall)[i_loop];
        -: 3140:/* debugging
        -: 3141:	j = i_loop *4;
        -: 3142:	fprintf(stderr," mxcut %f %f inclose %d who %d \n",mxcut,(*vector_loop)[j+3],inclose,(*atomall)[i_loop]->serial);
        -: 3143:	fprintf(stderr," vector_loop %f %f %f \n", (*vector_loop)[j],(*vector_loop)[j+1],(*vector_loop)[j+2]);
        -: 3144:*/
 26844662: 3145:						if( inclose == NCLOSE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3146:						{
        -: 3147:							aaerror(
    #####: 3148:							" fv_update_nonbon> too many atoms increase NCLOSE or decrease mxcut");
call    0 never executed
        -: 3149:/*		exit(0); 
        -: 3150:*/
        -: 3151:						}
        -: 3152:					}
587940268: 3153:					SKIPNEW:  j =  j;
        -: 3154:				}/* end of loop i_loop */
        -: 3155:			}/* end of if in close_loop MM node */
        -: 3156:		}/* end of loop inode */
        -: 3157:
        -: 3158:		/*END OF INNER INODE FOR*/
        -: 3159:/* merge the non-bond mxcut lists */
        -: 3160:        /* SPEC remove following line which causes compiler warnings.
        -: 3161:         * The line was a no-op anyway, since double equals is a 
        -: 3162:         * compare.  The author of AMMP says that we should
        -: 3163:         * NOT change it to a single equals, as that would "cause a
        -: 3164:         * failure under certain odd conditions.  The actual array is
        -: 3165:         * preinitialized above to NULL and is filled during these
        -: 3166:         * routines" - jh/9/24/99 */
        -: 3167:	/* a1->close_loop[inclose] == NULL; */
        -: 3168:/* set the position */
        -: 3169:
   843216: 3170:		a1->px = a1->dx*loop_lambda + a1->x;
   843216: 3171:		a1->py = a1->dy*loop_lambda + a1->y;
   843216: 3172:		a1->pz = a1->dz*loop_lambda + a1->z;
        -: 3173:
        -: 3174:	}  /* end of ii loop */
        -: 3175:
       88: 3176:}
        -: 3177:
function _Z21parallel_mm_fv_updatef called 88 returned 100% blocks executed 64%
       88: 3178:int parallel_mm_fv_update (float lambda)
        -: 3179:{
        -: 3180:
       88: 3181:	loop_lambda=lambda;
       88: 3182:	mmbox = get_f_variable("mmbox");
call    0 returned 100%
       88: 3183:	mxcut = get_f_variable("mxcut");
call    0 returned 100%
       88: 3184:	if( mxcut < 0.) mxcut= 5.;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3185:
       88: 3186:	dielectric = get_f_variable("dielec");
call    0 returned 100%
       88: 3187:	if( dielectric <= 0.) dielectric = 1.;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       88: 3188:	dielectric = 332.17752/dielectric;
        -: 3189:	
        -: 3190:/*  get the number of atoms and allocate the memory for the array space */
       88: 3191:	i_loop = a_number();
call    0 returned 100%
       88: 3192:	vector_loop = (float (*)[])  malloc( 4*i_loop*sizeof(float) );
       88: 3193:	if( vector_loop == NULL) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3194:	{ aaerror("cannot allocate memory in mm_fv_update\n");
call    0 never executed
    #####: 3195:	return 0;}
       88: 3196:	atomall = (ATOM*(*)[]) malloc( i_loop*sizeof(ATOM *) );
       88: 3197:	if( atomall == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3198:	{aaerror("cannot allocate memory in mm_fv_update\n"); 
call    0 never executed
    #####: 3199:	return 0;}
       88: 3200:	atomlist = (MMATOM (*)[]) malloc( i_loop * sizeof( MMATOM ));
       88: 3201:	if( atomlist == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3202:	{ aaerror("cannot allocate memory in mm_fv_update\n"); 
call    0 never executed
    #####: 3203:	return 0;}
        -: 3204:
       88: 3205:	imax = a_number();
call    0 returned 100%
       88: 3206:	jj = imax;
        -: 3207:
       88: 3208:	loop_0();
call    0 returned 100%
        -: 3209:/* first check if anyone's moved and update the lists */
        -: 3210:/* note that this must be a look-ahead rather than
        -: 3211:*  look back search because
        -: 3212:* we cannot update ->px until we've used that atom !!! */
        -: 3213:
        -: 3214:
        -: 3215:	/*FIRST II FOR*/
        -: 3216:
       88: 3217:	loop_1();
call    0 returned 100%
        -: 3218:/* determine the bounds of box which surrounds all of the atoms */
       88: 3219:	xmax = -10e10;
       88: 3220:	ymax = -10e10;
       88: 3221:	zmax = -10e10;
       88: 3222:	xmin =  10e10;
       88: 3223:	ymin =  10e10;
       88: 3224:	zmin =  10e10;
        -: 3225:
       88: 3226:	loop_2();
call    0 returned 100%
        -: 3227:
       88: 3228:	nx = (xmax - xmin)/mmbox + 1 ;
       88: 3229:	ny = (ymax - ymin)/mmbox + 1 ;
       88: 3230:	nz = (zmax - zmin)/mmbox + 1 ;
        -: 3231:
        -: 3232:/* DEBUG	
        -: 3233:	sprintf(line,"before allocation mmbox %f nx %d ny %d nz %d \n",mmbox,nx,ny,nz);
        -: 3234:	aaerror( line);
        -: 3235:	sprintf(line," xmin xmax %f %f ymin ymax %f %f zmin zmax %f %f\n",
        -: 3236:	xmin,xmax,ymin,ymax,zmin,zmax);
        -: 3237:	aaerror( line);
        -: 3238:end of DEBUG */
        -: 3239:
        -: 3240:/* now try to malloc the mmnodes */
       88: 3241:	nodelist = (MMNODE (*)[]) malloc( nx*ny*nz * sizeof( MMNODE ));
       88: 3242:	if( nodelist == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3243:	{ aaerror("cannot allocate node memory in mm_fv_update (doubling grid )\n"); 
call    0 never executed
    #####: 3244:	sprintf(line,"mmbox %f nx %d ny %d nz %d ",mmbox,nx,ny,nz);
    #####: 3245:	aaerror( line);
call    0 never executed
        -: 3246:	sprintf(line," xmin xmax %f %f ymin ymax %f %f zmin zmax %f %f",
    #####: 3247:	xmin,xmax,ymin,ymax,zmin,zmax);
    #####: 3248:	aaerror( line);
call    0 never executed
    #####: 3249:	mmbox = mmbox *2;
    #####: 3250:	set_f_variable( "mmbox",mmbox);
call    0 never executed
    #####: 3251:	nx = (xmax - xmin)/mmbox + 1;
    #####: 3252:	ny = (ymax - ymin)/mmbox + 1;
    #####: 3253:	nz = (zmax - zmin)/mmbox + 1;
    #####: 3254:	nodelist = (MMNODE(*)[])malloc( nx*ny*nz * sizeof( MMNODE ));
    #####: 3255:	if( nodelist == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3256:	{ aaerror("cannot allocate node memory in mm_fv_update (cannot do it)\n");
call    0 never executed
    #####: 3257:	return 0; }
        -: 3258:	}
        -: 3259:
       88: 3260:	loop_3();
call    0 returned 100%
        -: 3261:
       88: 3262:	loop_4();
call    0 returned 100%
        -: 3263:
        -: 3264:/* now decide for each atom who he belongs to */	
        -: 3265:
       88: 3266:	loop_5();
call    0 returned 100%
        -: 3267:
        -: 3268:	/*FOURTH II FOR*/
        -: 3269:
        -: 3270:/* and generate the links */ 
        -: 3271:	
        -: 3272:	/*FIRST INODE FOR*/
        -: 3273:
       88: 3274:	loop_6();
call    0 returned 100%
        -: 3275:
        -: 3276:/* and now (almost done with the MM setup)
        -: 3277:* normalize the accumulated nodal data */
        -: 3278:	/* multiplied by .5 to correct for double counting */
       88: 3279:	k = dielectric *.5;
       88: 3280:	xt = .5/3.;
       88: 3281:	yt = xt/4.;
       88: 3282:	zt = yt/5.;
        -: 3283:
        -: 3284:
        -: 3285:	/*FIFTH II FOR*/
        -: 3286:	
       88: 3287:	loop_7();
call    0 returned 100%
        -: 3288:
        -: 3289:
        -: 3290:/* initiallization of the mmnodes is done !!! */
        -: 3291:
        -: 3292:/*  initialize the data for every atom */
        -: 3293:
       88: 3294:	loop_8();
call    0 returned 100%
        -: 3295:
        -: 3296:	/*SIXTH II FOR*/
        -: 3297:
        -: 3298:	/*SEVENTH II FOR*/
        -: 3299:
        -: 3300:
       88: 3301:	loop_9();
call    0 returned 100%
        -: 3302:
        -: 3303:	
        -: 3304:	/*END OF SEVENTH II FOR*/
       88: 3305:	a_inactive_f_zero();
call    0 returned 100%
        -: 3306:
       88: 3307:	free( atomlist);
       88: 3308:	free( nodelist);
       88: 3309:	free( vector_loop);
       88: 3310:	free (atomall);
       88: 3311:	return 1;
        -: 3312:
        -: 3313:}
        -: 3314:
        -: 3315:
        -: 3316:
        -: 3317:/* vnonbon.c
        -: 3318:*
        -: 3319:* collection of routines to service nonbonded potentials
        -: 3320:*
        -: 3321:* POOP (Poor-mans Object Oriented Programming) using scope rules
        -: 3322:*
        -: 3323:* the routines for potential value, force and (eventually) second
        -: 3324:* derivatives are here also
        -: 3325:*
        -: 3326:* force and 2nd derivative routines assume zero'd arrays for output
        -: 3327:* this allows for parralellization if needed (on a PC?)
        -: 3328:*
        -: 3329:* forces are symmetric - so we don't have to mess around with
        -: 3330:* s matrices and the like.
        -: 3331:*
        -: 3332:* note that the non-bonded information is in the ATOM structures 
        -: 3333:*
        -: 3334:*
        -: 3335:* attempts at vectorization
        -: 3336:*/
        -: 3337:/*
        -: 3338:*  copyright 1992, 1993 Robert W. Harrison
        -: 3339:*  
        -: 3340:*  This notice may not be removed
        -: 3341:*  This program may be copied for scientific use
        -: 3342:*  It may not be sold for profit without explicit
        -: 3343:*  permission of the author(s) who retain any
        -: 3344:*  commercial rights including the right to modify 
        -: 3345:*  this notice
        -: 3346:*/
        -: 3347:
        -: 3348:/* SPEC add function proto to reduce compiler warnings jh/9/21/99 */
        -: 3349:void a_inactive_f_zero ();
        -: 3350:
        -: 3351:/* ATOM structure contains a serial number for indexing into
        -: 3352:* arrays and the like (a Hessian)
        -: 3353:* but otherwise is self-contained. Note the hooks for Non-nonboned potentials
        -: 3354:*/
        -: 3355:
        -: 3356:/* v_nonbon()
        -: 3357:* this function sums up the potentials
        -: 3358:* for the atoms defined in the nonbon data structure.
        -: 3359:*/
        -: 3360:/* standard returns 0 if error (any) 1 if ok
        -: 3361:* V is the potential */
        -: 3362:
function _Z16fv_update_nonbonf called 1005 returned 100% blocks executed 39%
     1005: 3363:int fv_update_nonbon(float lambda)
        -: 3364:{
        -: 3365:	float r,r0,xt,yt,zt;
        -: 3366:	float k,k1,k2,k3,k4,k5;
        -: 3367:	float ka3,ka2;
        -: 3368:	float kb3,kb2;
        -: 3369:	float get_f_variable(char*);
        -: 3370:	int inbond,inangle,i;
        -: 3371:	ATOM *a1,*a2,*bonded[10],*angled[10];
        -: 3372:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 3373:	int (*indexes)[],inindex,in;
        -: 3374:	int a_number();
        -: 3375:	int ii,j,jj,imax,inclose;
        -: 3376:	float (*vector)[];
        -: 3377:/*	float (*vecold)[];
        -: 3378:*/
        -: 3379:	ATOM *close[NCLOSE],*(*atomall)[];
        -: 3380:	float mxdq,dielectric,mxcut; 
        -: 3381:	static float dielecold = -1.;
        -: 3382:
        -: 3383:
     1005: 3384:	mxdq = get_f_variable("mxdq");
call    0 returned 100%
        -: 3385:/*	if( mxdq < 0.) mxdq = 0.;
        -: 3386:*/
     1005: 3387:	mxcut = get_f_variable("mxcut");
call    0 returned 100%
     1005: 3388:	if( mxcut < 0.) mxcut= 5.;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1005: 3389:	if( mxdq > 0.) mxdq = mxdq*mxdq;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3390:
     1005: 3391:	dielectric = get_f_variable("dielec");
call    0 returned 100%
     1005: 3392:	if( dielectric < 1.) dielectric = 1.;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1005: 3393:	if( dielecold != dielectric)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 3394:	{
        1: 3395:	 dielecold = dielectric;
        1: 3396:	mxdq = -1.;
        -: 3397:	}
     1005: 3398:	dielectric = 332.17752/dielectric;
        -: 3399:	
        -: 3400:/*  get the number of atoms and allocate the memory for the array space */
     1005: 3401:	i = a_number();
call    0 returned 100%
     1005: 3402:	vector = (float (*)[]) malloc( 4*i*sizeof(float) );
     1005: 3403:	if( vector == NULL) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3404:	{ aaerror("cannot allocate memory in v_nonbon\n"); return 0;}
call    0 never executed
        -: 3405:/*
        -: 3406:	vecold = malloc( 4*i*sizeof(float) );
        -: 3407:	if( vecold == NULL) 
        -: 3408:	{ aaerror("cannot allocate memory in v_nonbon\n"); return 0;}
        -: 3409:*/
     1005: 3410:	atomall = (ATOM* (*)[]) malloc( i*sizeof(ATOM *) );
     1005: 3411:	if( atomall == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3412:	{aaerror("cannot allocate memory in v_nonbon\n"); return 0;}
call    0 never executed
        -: 3413:
     1005: 3414:	imax = a_number();
call    0 returned 100%
  9630915: 3415:	for( i=0; i< imax; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3416:	{
  9629910: 3417:		(*atomall)[i] = a_next(i);
call    0 returned 100%
        -: 3418:	}
        -: 3419:/* first check if anyone's moved and update the lists */
        -: 3420:/* note that this must be a look-ahead rather than
        -: 3421:*  look back search because
        -: 3422:* we cannot update ->px until we've used that atom !!! */
  9258490: 3423:	for( ii=0; ii< imax; ii++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3424:	{
  9257573: 3425:        a1 = (*atomall)[ii];
  9257573: 3426:        xt = a1->dx*lambda +a1->x - a1->px;
  9257573: 3427:        yt = a1->dy*lambda +a1->y - a1->py;
  9257573: 3428:        zt = a1->dz*lambda +a1->z - a1->pz;
  9257573: 3429:        r = xt*xt + yt*yt + zt*zt;
  9257573: 3430:	if( r > mxdq ) goto DOIT;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 3431:	}
        -: 3432:	
      917: 3433:	free( vector);
        -: 3434:/*	free( vecold);
        -: 3435:*/
      917: 3436:	free (atomall);
      917: 3437:	return 1;
        -: 3438:DOIT:
       88: 3439:	xt = get_f_variable("mmbox");
call    0 returned 100%
       88: 3440:	if( xt > 0.)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3441:	{ 
       88: 3442:	free(vector); 
       88: 3443:	free(atomall);
        -: 3444:	//parallel_mm_fv_update.append(parallel_mm_fv_update_f, (void*)&extra_float);
       88: 3445:	parallel_mm_fv_update (lambda);
call    0 returned 100%
        -: 3446:	//mm_fv_update_nonbon(lambda); //Parte mas costosa...
       88: 3447:                  return 1;}
    #####: 3448:	indexes = (int(*)[])malloc( imax* sizeof(int) );
    #####: 3449:	if( indexes == NULL ){
branch  0 never executed
branch  1 never executed
    #####: 3450:	aaerror(" cannot allocate memory in fv_update\n");
call    0 never executed
    #####: 3451:	return 0;}
    #####: 3452:	for( ii=0; ii< imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 3453:	{
    #####: 3454:	a1 = (*atomall)[ii];
    #####: 3455:	a1 -> VP = 0.;
    #####: 3456:	a1 -> dpx = 0.;
    #####: 3457:	a1 -> dpy = 0.;
    #####: 3458:	a1 -> dpz = 0.;
    #####: 3459:	a1 -> qxx = 0.;
    #####: 3460:	a1 -> qxy = 0.;
    #####: 3461:	a1 -> qxz = 0.;
    #####: 3462:	a1 -> qyy = 0.;
    #####: 3463:	a1 -> qyz = 0.;
    #####: 3464:	a1 -> qzz = 0.;
        -: 3465:#ifdef CUBIC
        -: 3466:	a1 -> qxxx = 0.;
        -: 3467:	a1 -> qxxy = 0.;
        -: 3468:	a1 -> qxxz = 0.;
        -: 3469:	a1 -> qxyy = 0.;
        -: 3470:	a1 -> qxyz = 0.;
        -: 3471:	a1 -> qxzz = 0.;
        -: 3472:	a1 -> qyyy = 0.;
        -: 3473:	a1 -> qyyz = 0.;
        -: 3474:	a1 -> qyzz = 0.;
        -: 3475:	a1 -> qzzz = 0.;
        -: 3476:#endif
    #####: 3477:	for( j=0; j< NCLOSE; j++) 
branch  0 never executed
branch  1 never executed
    #####: 3478:		a1->close[j] = NULL;
        -: 3479:
        -: 3480:	}
    #####: 3481:	for( ii=0; ii<  imax; ii++)
branch  0 never executed
branch  1 never executed
        -: 3482:	{ /* if this is met we update the expansion for this atom */
    #####: 3483:	a1 = (*atomall)[ii];
    #####: 3484:	inclose = 0;
    #####: 3485:	if( lambda != 0.)
branch  0 never executed
branch  1 never executed
        -: 3486:	{
    #####: 3487:	for( i=ii+1; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 3488:	{
    #####: 3489:	a2 = (*atomall)[i];
    #####: 3490:	j = i*4;
    #####: 3491:	(*vector)[j  ] = a2->x - a1->x + lambda*(a2->dx -a1->dx);
    #####: 3492:	(*vector)[j+1] = a2->y - a1->y + lambda*(a2->dy -a1->dy);
    #####: 3493:	(*vector)[j+2] = a2->z - a1->z + lambda*(a2->dz -a1->dz);
        -: 3494:	}
        -: 3495:	}else {
    #####: 3496:	for( i=ii+1; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 3497:	{
    #####: 3498:	a2 = (*atomall)[i];
    #####: 3499:	j = i*4;
    #####: 3500:	(*vector)[j  ] = a2->x - a1->x ;
    #####: 3501:	(*vector)[j+1] = a2->y - a1->y ;
    #####: 3502:	(*vector)[j+2] = a2->z - a1->z ;
        -: 3503:	}
        -: 3504:	} /* end of difference position into vector loops */
    #####: 3505:	for( i=ii+1; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 3506:	{
    #####: 3507:		j = i*4;
    #####: 3508:		(*vector)[j+3] = sqrt((*vector)[j]*(*vector)[j] +
    #####: 3509:				 (*vector)[j+1]*(*vector)[j+1] +
    #####: 3510:				 (*vector)[j+2]*(*vector)[j+2]);
        -: 3511:	}
        -: 3512:/* add the new components */
        -: 3513:/* first extract indexes */
    #####: 3514:	inindex = 0;
    #####: 3515:	for( i=ii+1; i< imax; i++)
branch  0 never executed
branch  1 never executed
        -: 3516:	{
    #####: 3517:	a2 = (*atomall)[i];
    #####: 3518:	for( j=0; j< a1->dontuse; j++)
branch  0 never executed
branch  1 never executed
    #####: 3519:	{ if( a2 == a1->excluded[j]) goto SKIPNEW;}
branch  0 never executed
branch  1 never executed
    #####: 3520:	j = i*4;
    #####: 3521:	if( (*vector)[j+3] > mxcut || inclose > NCLOSE)
branch  0 never executed
branch  1 never executed
        -: 3522:	{
    #####: 3523:	(*indexes)[inindex++] = i;
        -: 3524:	}else {
    #####: 3525:	a1->close[inclose++] = (*atomall)[i];
        -: 3526:	}
    #####: 3527:	if( inclose == NCLOSE)
branch  0 never executed
branch  1 never executed
        -: 3528:	{
        -: 3529:	aaerror(
    #####: 3530:	" fv_update_nonbon> too many atoms increase NCLOSE or decrease mxcut");
call    0 never executed
        -: 3531:	}
    #####: 3532:SKIPNEW:   i = i;
        -: 3533:	}
        -: 3534:	/* and then use them */
    #####: 3535:	for( in=0; in< inindex; in++)
branch  0 never executed
branch  1 never executed
        -: 3536:	{
    #####: 3537:	i = (*indexes)[in];
    #####: 3538:	a2 = (*atomall)[i];
    #####: 3539:	j = i*4;
    #####: 3540:	r0 = one/(*vector)[j+3];  
    #####: 3541:	r = r0*r0;
    #####: 3542:	r = r*r*r; /* r0^-6 */
    #####: 3543:	xt = a1->q*a2->q*dielectric*r0;
    #####: 3544:	yt = a1->a*a2->a*r;
    #####: 3545:	zt = a1->b*a2->b*r*r;
    #####: 3546:	k = xt - yt + zt;
    #####: 3547:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
    #####: 3548:	k1 = xt - yt*six + zt*twelve;
    #####: 3549:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
        -: 3550:	/*
        -: 3551:	k2 = xt*three; ka2 = - yt*6*8; kb2 =  zt*12*14;
        -: 3552:	*/
    #####: 3553:	k2 = xt*three; ka2 = - yt*48.; kb2 =  zt*168.;
        -: 3554:#ifdef CUBIC
        -: 3555:	xt = xt*r0; yt = yt*r0; zt = zt*r0;
        -: 3556:	k3 = -xt*5*3; ka3 =   yt*6*8*10 ; kb3 =  -zt*12*14*16;
        -: 3557:#endif
    #####: 3558:	k1 = -k1;
    #####: 3559:	xt = (*vector)[j]*r0 ;
    #####: 3560:	yt = (*vector)[j+1]*r0 ;
    #####: 3561:	zt = (*vector)[j+2] *r0;
        -: 3562:	/*
        -: 3563:	xt = (*vector)[j] ;
        -: 3564:	yt = (*vector)[j+1] ;
        -: 3565:	zt = (*vector)[j+2] ;
        -: 3566:	*/
    #####: 3567:	a1->VP += k;
    #####: 3568:	a2->dpx -= k1*xt;
    #####: 3569:	a1->dpx += k1*xt;
    #####: 3570:	a2->dpy -= k1*yt;
    #####: 3571:	a1->dpy += k1*yt;
    #####: 3572:	a2->dpz -= k1*zt;
    #####: 3573:	a1->dpz += k1*zt;
        -: 3574:/*  note that xt has the 1/r in it so k2*xt*xt is 1/r^5 */
    #####: 3575:	a2->qxx -= k2*(xt*xt - third) + ka2*(xt*xt - eightth) + kb2*(xt*xt-fourteenth) ;
    #####: 3576:	a1->qxx -= k2*(xt*xt - third) + ka2*(xt*xt - eightth) + kb2*(xt*xt-fourteenth) ;
    #####: 3577:	a2->qxy -= (k2+ka2+kb2)*yt*xt;
    #####: 3578:	a1->qxy -= (k2+ka2+kb2)*yt*xt;
    #####: 3579:	a2->qxz -= (k2+ka2+kb2)*zt*xt;
    #####: 3580:	a1->qxz -= (k2+ka2+kb2)*zt*xt;
    #####: 3581:	a2->qyy -= k2*(yt*yt - third) + ka2*(yt*yt - eightth) + kb2*(yt*yt-fourteenth) ;
    #####: 3582:	a1->qyy -= k2*(yt*yt - third) + ka2*(yt*yt - eightth) + kb2*(yt*yt-fourteenth) ;
    #####: 3583:	a2->qyz -= (k2+ka2+kb2)*yt*zt;
    #####: 3584:	a1->qyz -= (k2+ka2+kb2)*yt*zt;
    #####: 3585:	a2->qzz -= k2*(zt*zt - third) + ka2*(zt*zt - eightth) + kb2*(zt*zt-fourteenth) ;
    #####: 3586:	a1->qzz -= k2*(zt*zt - third) + ka2*(zt*zt - eightth) + kb2*(zt*zt-fourteenth) ;
        -: 3587:#ifdef CUBIC
        -: 3588:	a2->qxxx -= k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 3589:	a2->qxxx -= ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 3590:	a2->qxxx -= kb3*(xt*xt*xt - xt*( 42./(14*16))); 
        -: 3591:	a1->qxxx += k3*(xt*xt*xt - xt*( 9./15 )) ;
        -: 3592:	a1->qxxx += ka3*(xt*xt*xt - xt*( 24./80 )) ;
        -: 3593:	a1->qxxx += kb3*(xt*xt*xt - xt*( 42./(14*16))); 
        -: 3594:	a2->qxxy -= k3*(yt*xt*xt - yt*( 6./ 15));
        -: 3595:	a2->qxxy -= ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 3596:	a2->qxxy -= kb3*(yt*xt*xt - yt*( 17./ (14*16)));
        -: 3597:	a1->qxxy += k3*(yt*xt*xt - yt*( 6./ 15));
        -: 3598:	a1->qxxy += ka3*(yt*xt*xt - yt*( 11./ 80));
        -: 3599:	a1->qxxy += kb3*(yt*xt*xt - yt*( 17./ (14*16)));
        -: 3600:	a2->qxxz -= k3*(zt*xt*xt - zt*( 6./ 15));
        -: 3601:	a2->qxxz -= ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 3602:	a2->qxxz -= kb3*(zt*xt*xt - zt*( 17./ (14*16)));
        -: 3603:	a1->qxxz += k3*(zt*xt*xt - zt*( 6./ 15));
        -: 3604:	a1->qxxz += ka3*(zt*xt*xt - zt*( 11./ 80));
        -: 3605:	a1->qxxz += kb3*(zt*xt*xt - zt*( 17./ (14*16)));
        -: 3606:	a2->qxyy -= k3*(yt*yt*xt - xt*( 6./ 15));
        -: 3607:	a2->qxyy -= ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 3608:	a2->qxyy -= kb3*(yt*yt*xt - xt*( 17./ (14*16)));
        -: 3609:	a1->qxyy += k3*(yt*yt*xt - xt*( 6./ 15));
        -: 3610:	a1->qxyy += ka3*(yt*yt*xt - xt*( 11./ 80));
        -: 3611:	a1->qxyy += kb3*(yt*yt*xt - xt*( 17./ (14*16)));
        -: 3612:	a2->qxyz -= (k3+ka3+kb3)*yt*zt*xt;
        -: 3613:	a1->qxyz += (k3+ka3+kb3)*yt*zt*xt;
        -: 3614:	a2->qxzz -= k3*(zt*zt*xt - xt*( 6./ 15));
        -: 3615:	a2->qxzz -= ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 3616:	a2->qxzz -= kb3*(zt*zt*xt - xt*( 17./ (14*16)));
        -: 3617:	a1->qxzz += k3*(zt*zt*xt - xt*( 6./ 15));
        -: 3618:	a1->qxzz += ka3*(zt*zt*xt - xt*( 11./ 80));
        -: 3619:	a1->qxzz += kb3*(zt*zt*xt - xt*( 17./ (14*16)));
        -: 3620:	a2->qyyy -= k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 3621:	a2->qyyy -= ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 3622:	a2->qyyy -= kb3*(yt*yt*yt - yt*( 42./(14*16))); 
        -: 3623:	a1->qyyy += k3*(yt*yt*yt - yt*( 9./15 )) ;
        -: 3624:	a1->qyyy += ka3*(yt*yt*yt - yt*( 24./80 )) ;
        -: 3625:	a1->qyyy += kb3*(yt*yt*yt - yt*( 42./(14*16))); 
        -: 3626:	a2->qyyz -= k3*(yt*yt*zt - zt*( 6./ 15));
        -: 3627:	a2->qyyz -= ka3*(yt*yt*zt - zt*( 11./ 80));
        -: 3628:	a2->qyyz -= kb3*(yt*yt*zt - zt*( 17./ (14*16)));
        -: 3629:	a1->qyyz += k3*(yt*yt*zt - zt*( 6./ 15));
        -: 3630:	a1->qyyz += ka3*(yt*yt*zt - zt*( 11./ 80));
        -: 3631:	a1->qyyz += kb3*(yt*yt*zt - zt*( 17./ (14*16)));
        -: 3632:	a2->qyzz -= k3*(zt*zt*yt - yt*( 6./ 15));
        -: 3633:	a2->qyzz -= ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 3634:	a2->qyzz -= kb3*(zt*zt*yt - yt*( 17./ (14*16)));
        -: 3635:	a1->qyzz += k3*(zt*zt*yt - yt*( 6./ 15));
        -: 3636:	a1->qyzz += ka3*(zt*zt*yt - yt*( 11./ 80));
        -: 3637:	a1->qyzz += kb3*(zt*zt*yt - yt*( 17./ (14*16)));
        -: 3638:	a2->qzzz -= k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 3639:	a2->qzzz -= ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 3640:	a2->qzzz -= kb3*(zt*zt*zt - zt*( 42./(14*16))); 
        -: 3641:	a1->qzzz += k3*(zt*zt*zt - zt*( 9./15 )) ;
        -: 3642:	a1->qzzz += ka3*(zt*zt*zt - zt*( 24./80 )) ;
        -: 3643:	a1->qzzz += kb3*(zt*zt*zt - zt*( 42./(14*16))); 
        -: 3644:#endif
        -: 3645:
        -: 3646:/* debugging
        -: 3647:	j = i *4;
        -: 3648:	fprintf(stderr," mxcut %f %f inclose %d who %d \n",mxcut,(*vector)[j+3],inclose,(*atomall)[i]->serial);
        -: 3649:	fprintf(stderr," vector %f %f %f \n", (*vector)[j],(*vector)[j+1],(*vector)[j+2]);
        -: 3650:*/
        -: 3651:	}/* end of loop i */
        -: 3652:/* merge the non-bond mxcut lists */
        -: 3653:        /* SPEC remove following line which causes compiler warnings.
        -: 3654:         * The line was a no-op anyway, since double equals is a 
        -: 3655:         * compare.  The author of AMMP says that we should
        -: 3656:         * NOT change it to a single equals, as that would "cause a
        -: 3657:         * failure under certain odd conditions.  The actual array is
        -: 3658:         * preinitialized above to NULL and is filled during these
        -: 3659:         * routines" - jh/9/24/99 */
        -: 3660:	/* a1->close[inclose] == NULL; */
        -: 3661:/* set the position */
    #####: 3662:	a1->px = a1->dx*lambda + a1->x;
    #####: 3663:	a1->py = a1->dy*lambda + a1->y;
    #####: 3664:	a1->pz = a1->dz*lambda + a1->z;
        -: 3665:
        -: 3666:	}  /* end of ii loop */
        -: 3667:	
    #####: 3668:	a_inactive_f_zero();
call    0 never executed
        -: 3669:
    #####: 3670:	free( indexes);
    #####: 3671:	free( vector);
        -: 3672:/*	free( vecold);
        -: 3673:*/
    #####: 3674:	free (atomall);
    #####: 3675:	return 1;
        -: 3676:
        -: 3677:}
        -: 3678:
        -: 3679:
        -: 3680:/* f_nonbon()
        -: 3681:*
        -: 3682:* f_nonbon increments the forces in the atom structures by the force
        -: 3683:* due to the nonbon components.  NOTE THE WORD increment.
        -: 3684:* the forces should first be zero'd.
        -: 3685:* if not then this code will be invalid.  THIS IS DELIBERATE.
        -: 3686:* on bigger (and better?) machines the different potential terms
        -: 3687:* may be updated at random or in parrellel, if we assume that this routine
        -: 3688:* will initialize the forces then we can't do this.
        -: 3689:*/
function _Z8f_nonbonf called 1002 returned 100% blocks executed 92%
     1002: 3690:int f_nonbon(float lambda)
        -: 3691:/*  returns 0 if error, 1 if OK */
        -: 3692:{
        -: 3693:	float ux,uy,uz;
        -: 3694:	float k,r,r0,xt,yt,zt;
        -: 3695:	float lcutoff,cutoff,get_f_variable(char*);
        -: 3696:	int inbond,inangle,i,test;
        -: 3697:	ATOM *a1,*a2,*bonded[10],*angled[10];
        -: 3698:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 3699:	int a_number(),inbuffer,imax;
        -: 3700:	float (*buffer)[];
        -: 3701:	int invector,atomsused,ii,jj;
        -: 3702:	float (*vector)[];
        -: 3703:	ATOM *(*atms)[],*(*atomall)[];
        -: 3704:        float dielectric;
        -: 3705:	float fx,fy,fz;
        -: 3706:	float xt2,xt3,xt4;
        -: 3707:	float yt2,yt3,yt4;
        -: 3708:	float zt2,zt3,zt4;
        -: 3709:
        -: 3710:/* first update the lists 
        -: 3711:*  this routine checks if any atom has
        -: 3712:*   broken the mxdq barrier and updates the
        -: 3713:* forces, potentials and expansions thereof */
     1002: 3714:	fv_update_nonbon( lambda); //La parte mas costosa...
call    0 returned 100%
        -: 3715:
     1002: 3716:        dielectric = get_f_variable("dielec");
call    0 returned 100%
     1002: 3717:        if( dielectric < 1.) dielectric = 1.;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1002: 3718:        dielectric = 332.17752/dielectric;
        -: 3719:
        -: 3720:/*  get the number of atoms and allocate the memory for the array space */
     1002: 3721:        i = a_number();
call    0 returned 100%
     1002: 3722:        atomall = (ATOM*(*)[])malloc( i*sizeof(ATOM *) );
     1002: 3723:        if( atomall == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3724:        {aaerror("cannot allocate memory in f_nonbon"); return 0;}
call    0 never executed
        -: 3725:
     1002: 3726:        imax = a_number();
call    0 returned 100%
  9602166: 3727:        for( i=0; i< imax; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3728:        {
  9601164: 3729:                (*atomall)[i] = a_next(i);
call    0 returned 100%
        -: 3730:        }
  9602166: 3731:        for( i= 0; i< imax; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3732:        {
  9601164: 3733:	fx = 0.; fy = 0.; fz = 0.;
  9601164: 3734:                a1 = (*atomall)[i];
  9601164: 3735:        xt = a1->dx*lambda +a1->x - a1->px;
  9601164: 3736:        yt = a1->dy*lambda +a1->y - a1->py;
  9601164: 3737:        zt = a1->dz*lambda +a1->z - a1->pz;
        -: 3738:
        -: 3739:
        -: 3740:        fx = (a1->qxx*xt + a1->qxy*yt
  9601164: 3741:                        + a1->qxz*zt) ;
        -: 3742:        fy = (a1->qxy*xt + a1->qyy*yt
  9601164: 3743:                        + a1->qyz*zt) ;
        -: 3744:        fz = (a1->qxz*xt + a1->qyz*yt
  9601164: 3745:                        + a1->qzz*zt) ;
        -: 3746:#ifdef CUBIC
        -: 3747:	xt2 = xt*xt; yt2 = yt*yt; zt2 = zt*zt;
        -: 3748:	fx += a1->qxxx*xt2/2. + a1->qxxy*xt*yt + a1->qxxz*xt*zt
        -: 3749:		+ a1->qxyy*yt/2. + a1->qxyz*yt*zt + a1->qxzz*zt2/2.;
        -: 3750:	fy += a1->qxxy*xt2/2. + a1->qxyy*xt*yt + a1->qxyz*xt*zt
        -: 3751:		+ a1->qyyy*yt/2. + a1->qyyz*yt*zt + a1->qyzz*zt2/2.;
        -: 3752:	fz += a1->qxxz*xt2/2. + a1->qxyz*xt*yt + a1->qxzz*xt*zt
        -: 3753:		+ a1->qyyz*yt/2. + a1->qyzz*yt*zt + a1->qzzz*zt2/2.;
        -: 3754:#endif
        -: 3755:#ifdef QUARTIC
        -: 3756:	xt3 = xt*xt2; yt3 = yt*yt2; zt3 = zt*zt2;
        -: 3757:	fx +=  a1->qxxxx*xt3/6. + a1->qxxxy*xt2*yt/2. + a1->qxxxz*xt2*zt/2.
        -: 3758:		+ a1->qxxyy*xt*yt/2. + a1->qxxyz*xt*yt*zt + a1->qxxzz*xt*zt2/2.
        -: 3759:		+ a1->qxyyy*yt3/6. + a1->qxyyz*yt2*zt/2. + a1->qxyzz*yt*zt2/2.
        -: 3760:		+ a1->qxzzz*zt3/6.;
        -: 3761:	fy +=  a1->qxxxy*xt3/6. + a1->qxxyy*xt2*yt/2. + a1->qxxyz*xt2*zt/2.
        -: 3762:		+ a1->qxyyy*xt*yt/2. + a1->qxyyz*xt*yt*zt + a1->qxyzz*xt*zt2/2.
        -: 3763:		+ a1->qyyyy*yt3/6. + a1->qyyyz*yt2*zt/2. + a1->qyyzz*yt*zt2/2.
        -: 3764:		+ a1->qyzzz*zt3/6.;
        -: 3765:	fz +=  a1->qxxxz*xt3/6. + a1->qxxyz*xt2*yt/2. + a1->qxxzz*xt2*zt/2.
        -: 3766:		+ a1->qxyyz*xt*yt/2. + a1->qxyzz*xt*yt*zt + a1->qxzzz*xt*zt2/2.
        -: 3767:		+ a1->qyyyz*yt3/6. + a1->qyyzz*yt2*zt/2. + a1->qyzzz*yt*zt2/2.
        -: 3768:		+ a1->qzzzz*zt3/6.;
        -: 3769:#endif
        -: 3770:#ifdef QUINTIC
        -: 3771:	xt4 = xt*xt3; yt4 = yt*yt3; zt4 = zt*zt3;
        -: 3772:	fx += a1->qxxxxx*xt4/24. + a1->qxxxxy*xt3*yt/6. + a1->qxxxxz*xt3*zt/6.
        -: 3773:		+ a1->qxxxyy*xt2*yt2/4. + a1->qxxxyz*xt2*yt*zt/2. + a1->qxxxzz*xt2*zt2/4.
        -: 3774:		+ a1->qxxyyy*xt*yt3/6. + a1->qxxyyz*xt*yt2*zt/2. + a1->qxxyzz*xt*yt*zt2/2.
        -: 3775:		+ a1->qxxzzz*xt*zt3/6. + a1->qxyyyy*yt4/24. + a1->qxyyyz*yt3*zt/6. 
        -: 3776:		+ a1->qxyyzz*yt2*zt2/4. + a1->qxyzzz*yt*zt3/6. + a1->qxzzzz*zt4/24.;
        -: 3777:	fy += a1->qxxxxy*xt4/24. + a1->qxxxyy*xt3*yt/6. + a1->qxxxyz*xt3*zt/6.
        -: 3778:		+ a1->qxxyyy*xt2*yt2/4. + a1->qxxyyz*xt2*yt*zt/2. + a1->qxxyzz*xt2*zt2/4.
        -: 3779:		+ a1->qxyyyy*xt*yt3/6. + a1->qxyyyz*xt*yt2*zt/2. + a1->qxyyzz*xt*yt*zt2/2.
        -: 3780:		+ a1->qxyzzz*xt*zt3/6. + a1->qyyyyy*yt4/24. + a1->qyyyyz*yt3*zt/6. 
        -: 3781:		+ a1->qyyyzz*yt2*zt2/4. + a1->qyyzzz*yt*zt3/6. + a1->qyzzzz*zt4/24.;
        -: 3782:	fz += a1->qxxxxz*xt4/24. + a1->qxxxyz*xt3*yt/6. + a1->qxxxzz*xt3*zt/6.
        -: 3783:		+ a1->qxxyyz*xt2*yt2/4. + a1->qxxyzz*xt2*yt*zt/2. + a1->qxxzzz*xt2*zt2/4.
        -: 3784:		+ a1->qxyyyz*xt*yt3/6. + a1->qxyyzz*xt*yt2*zt/2. + a1->qxyzzz*xt*yt*zt2/2.
        -: 3785:		+ a1->qxzzzz*xt*zt3/6. + a1->qyyyyz*yt4/24. + a1->qyyyzz*yt3*zt/6. 
        -: 3786:		+ a1->qyyzzz*yt2*zt2/4. + a1->qyzzzz*yt*zt3/6. + a1->qzzzzz*zt4/24.;
        -: 3787:#endif
  9601164: 3788:	a1->fx += fx  + a1->dpx;
  9601164: 3789:	a1->fy += fy  + a1->dpy;
  9601164: 3790:	a1->fz += fz  + a1->dpz;
        -: 3791:/* do the close atoms */
315166109: 3792:	for( jj=0; jj< NCLOSE; jj++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
315166109: 3793:	{ if( a1->close[jj] == NULL) break; }
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
315166109: 3794:        for( ii=0; ii< jj;ii++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 3795:        {
305564945: 3796:        a2 = (ATOM*) a1->close[ii]; 
        -: 3797:/* note ux is backwards from below */
305564945: 3798:        ux = (a2->dx -a1->dx)*lambda +(a2->x -a1->x);
305564945: 3799:        uy = (a2->dy -a1->dy)*lambda +(a2->y -a1->y);
305564945: 3800:        uz = (a2->dz -a1->dz)*lambda +(a2->z -a1->z);
305564945: 3801:        r =one/( ux*ux + uy*uy + uz*uz); r0 = sqrt(r);
305564945: 3802:        ux = ux*r0; uy = uy*r0; uz = uz*r0;
305564945: 3803:        k = -dielectric*a1->q*a2->q*r;
305564945: 3804:        r = r*r*r;
305564945: 3805:        k += a1->a*a2->a*r*r0*six;
305564945: 3806:        k -= a1->b*a2->b*r*r*r0*twelve;
305564945: 3807:        a1->fx += ux*k;
305564945: 3808:        a1->fy += uy*k;
305564945: 3809:        a1->fz += uz*k;
305564945: 3810:        a2->fx -= ux*k;
305564945: 3811:        a2->fy -= uy*k;
305564945: 3812:        a2->fz -= uz*k;
        -: 3813:        }
        -: 3814:        } 
        -: 3815:
     1002: 3816:	a_inactive_f_zero();
call    0 returned 100%
     1002: 3817:        free( atomall); return 1;
        -: 3818:
        -: 3819:}
        -: 3820:/* v_nonbon()
        -: 3821:* this function sums up the potentials
        -: 3822:* for the atoms defined in the nonbon data structure.
        -: 3823:*/
        -: 3824:/* standard returns 0 if error (any) 1 if ok
        -: 3825:* V is the potential */
function _Z8v_nonbonPff called 3 returned 100% blocks executed 92%
        3: 3826:int v_nonbon( float *V, float lambda)
        -: 3827:{
        -: 3828:        float r,r0,xt,yt,zt;
        -: 3829:        float get_f_variable(char*);
        -: 3830:        float k;
        -: 3831:        int inbond,inangle,i;
        -: 3832:        ATOM *a1,*a2,*bonded[10],*angled[10];
        -: 3833:        ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 3834:        int a_number(),inbuffer;
        -: 3835:        int invector,atomsused,ii,jj,imax;
        -: 3836:        float (*vector)[];
        -: 3837:        float vx;
        -: 3838:        float k2;
        -: 3839:        ATOM *(*atomall)[];
        -: 3840:        float dielectric;
        -: 3841:	float xt2,xt3,xt4,xt5;
        -: 3842:	float yt2,yt3,yt4,yt5;
        -: 3843:	float zt2,zt3,zt4,zt5;
        -: 3844:
        3: 3845:	fv_update_nonbon( lambda);
call    0 returned 100%
        -: 3846:
        3: 3847:        dielectric = get_f_variable("dielec");
call    0 returned 100%
        3: 3848:        if( dielectric < 1.) dielectric = 1.;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 3849:        dielectric = 332.17752/dielectric;
        -: 3850:
        -: 3851:/*  get the number of atoms and allocate the memory for the array space */
        3: 3852:        i = a_number();
call    0 returned 100%
        3: 3853:        atomall = (ATOM* (*)[])malloc( i*sizeof(ATOM *) );
        3: 3854:        if( atomall == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3855:        {aaerror("cannot allocate memory in v_nonbon"); return 0;}
call    0 never executed
        -: 3856:
        3: 3857:        imax = a_number();
call    0 returned 100%
    28749: 3858:        for( i=0; i< imax; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3859:        {
    28746: 3860:                (*atomall)[i] = a_next(i);
call    0 returned 100%
        -: 3861:        }
    28749: 3862:        for( i= 0; i< imax; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3863:        {
    28746: 3864:                a1 = (*atomall)[i];
    28746: 3865:		vx = a1->VP;
    28746: 3866:                xt = a1->dx*lambda +a1->x - a1->px;
    28746: 3867:                yt = a1->dy*lambda +a1->y - a1->py;
    28746: 3868:                zt = a1->dz*lambda +a1->z - a1->pz;
        -: 3869:                vx -= (a1->dpx*xt + a1->dpy*yt
    28746: 3870:                        + a1->dpz*zt) ;
        -: 3871:                vx -= ( (xt*(.5*a1->qxx*xt + a1->qxy*yt + a1->qxz*zt)
    28746: 3872:                + yt*(.5*a1->qyy*yt + a1->qyz*zt) + .5*zt*a1->qzz*zt));
        -: 3873:#ifdef CUBIC
        -: 3874:		xt2 = xt*xt; yt2 = yt*yt;  zt2 = zt*zt;
        -: 3875:		xt3 = xt2*xt; yt3 = yt2*yt; zt3 = zt2*zt;
        -: 3876:
        -: 3877:	vx -= a1->qxxx*xt3/6. + a1->qxxy*xt2*yt/2 + a1->qxxz*xt2*zt/2
        -: 3878:		+ a1->qxyy*xt*yt2/2 + a1->qxyz*xt*yt*zt + a1->qxzz*xt*zt2/2
        -: 3879:		+ a1->qyyy*yt3/6 + a1->qyyz*yt2*zt/2 + a1->qyzz*yt*zt2/2 
        -: 3880:		+ a1->qzzz*zt3/6.;
        -: 3881:#endif
        -: 3882:#ifdef QUARTIC
        -: 3883:		xt4 = xt3*xt; yt4 = yt3*yt; zt4 = zt3*zt;
        -: 3884:	vx -= a1->qxxxx*xt4/24. + a1->qxxxy*xt3*yt/6. + a1->qxxxz*xt3*yt/6. + a1->qxxyy*xt2*yt2/4.
        -: 3885:		+ a1->qxxyz*xt2*yt*zt/2. + a1->qxxzz*xt2*zt2/4. + a1->qxyyy*xt*yt3/6.
        -: 3886:		+ a1->qxyyz*xt*yt2*zt/2. + a1->qxyzz*xt*yt*zt2/2. + a1->qxzzz*xt*zt3/6.
        -: 3887:		+ a1->qyyyy*yt4/24. + a1->qyyyz*yt3*zt/6. + a1->qyyzz*yt2*zt2/4. + a1->qyzzz*yt*zt3/6.
        -: 3888:		+ a1->qzzzz*zt4/24.;
        -: 3889:#endif
        -: 3890:#ifdef QUINTIC
        -: 3891:		xt5 = xt4*xt; yt5 = yt4*yt; zt5 = zt4*zt;
        -: 3892:	vx -= a1->qxxxxx*xt5/120. + a1->qxxxxy*xt4*yt/24. + a1->qxxxxz*xt4*zt/24.
        -: 3893:		+ a1->qxxxyy*xt3*yt2/12. + a1->qxxxyz*xt3*yt*zt/6. + a1->qxxxzz*xt3*zt2/12.
        -: 3894:		+ a1->qxxyyy*xt2*yt3/12. + a1->qxxyyz*xt2*yt2*zt/4. + a1->qxxyzz*xt2*yt*zt2/4.
        -: 3895:		+ a1->qxxzzz*xt2*zt3/12. + a1->qxyyyy*xt*yt4/24.  + a1->qxyyyz*xt*yt3*zt/6.
        -: 3896:		+ a1->qxyyzz*xt*yt2*zt2/4. + a1->qxyzzz*xt*yt*zt3/6. + a1->qxzzzz*xt*zt4/24.
        -: 3897:		+ a1->qyyyyy*yt5/120. + a1->qyyyyz*yt4*zt/24 + a1->qyyyzz*yt3*zt2/12.
        -: 3898:		+ a1->qyyzzz*yt2*zt3/12. + a1->qyzzzz*yt*zt4/24. + a1->qzzzzz*zt5/120.;
        -: 3899:
        -: 3900:#endif
        -: 3901:/* do the close atoms */
   965557: 3902:	for( jj=0; jj< NCLOSE; jj++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   965557: 3903:	{ if( a1->close[jj] == NULL) break; }
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
   965557: 3904:        for( ii=0; ii< jj;ii++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 3905:        {
   936811: 3906:        a2 = (ATOM*)a1->close[ii]; 
   936811: 3907:        xt = (a2->dx -a1->dx)*lambda +(a2->x -a1->x);
   936811: 3908:        yt = (a2->dy -a1->dy)*lambda +(a2->y -a1->y);
   936811: 3909:        zt = (a2->dz -a1->dz)*lambda +(a2->z -a1->z);
   936811: 3910:        r = one/(xt*xt + yt*yt + zt*zt); r0 = sqrt(r);
        -: 3911:/*      xt = xt/r0; yt = yt/r0; zt = zt/r0;
        -: 3912:*/
   936811: 3913:        k = dielectric*a1->q*a2->q*r0;
   936811: 3914:        r = r*r*r;
   936811: 3915:        k -= a1->a*a2->a*r;
   936811: 3916:        k += a1->b*a2->b*r*r;
   936811: 3917:	vx += k;
        -: 3918:        }
    28746: 3919:        *V += vx;
        -: 3920:	}
        3: 3921:	a_inactive_f_zero();
call    0 returned 100%
        3: 3922:        free( atomall); return 1;
        -: 3923:}
        -: 3924:
        -: 3925:/*zone_nonbon()
        -: 3926:* this function sums up the potentials
        -: 3927:* for the atoms defined in the nonbon data structure.
        -: 3928:*/
        -: 3929:/* standard returns 0 if error (any) 1 if ok
        -: 3930:* V is the potential */
function _Z11zone_nonbonPffPA10_P4ATOMi called 0 returned 0% blocks executed 0%
    #####: 3931:int zone_nonbon(float *V,float lambda, ATOM *( *alist)[10], int inalist)
        -: 3932:{
        -: 3933:	float r,r0,xt,yt,zt;
        -: 3934:	float lcutoff,cutoff,get_f_variable(char*);
        -: 3935:	int inbond,inangle,i,ii;
        -: 3936:	ATOM *a1,*a2;
        -: 3937:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 3938:	float dielectric,ve,va,vh;
        -: 3939:	ATOM *a_m_serial(int);
        -: 3940:
        -: 3941:/* nonbonded potentials 
        -: 3942:* do a double loop starting from the first atom to the 
        -: 3943:* last 
        -: 3944:* then from the second to the last 
        -: 3945:* etc
        -: 3946:*
        -: 3947:* also check to avoid bonded and 1-3 bonded atoms
        -: 3948:*/
    #####: 3949:	if( inalist <= 0 ) return 1;
branch  0 never executed
branch  1 never executed
    #####: 3950:	dielectric = get_f_variable("dielec");
call    0 never executed
    #####: 3951:	if( dielectric < 1.) dielectric = 1.;
branch  0 never executed
branch  1 never executed
    #####: 3952:	dielectric = 332.17752/dielectric;
    #####: 3953:	cutoff = get_f_variable("cutoff");
call    0 never executed
    #####: 3954:	if( cutoff < 1.) cutoff = 1.e10;
branch  0 never executed
branch  1 never executed
    #####: 3955:	lcutoff = -cutoff;
    #####: 3956:	for( ii=0; ii< inalist; ii++)
branch  0 never executed
branch  1 never executed
        -: 3957:	{
    #####: 3958:	a1 = (*alist)[ii];
    #####: 3959:	if( a1 == NULL ) goto NOTANATOM;
branch  0 never executed
branch  1 never executed
    #####: 3960:	ve = 0.; va = 0.; vh = 0.;
    #####: 3961:	a2 = a_next(-1);
call    0 never executed
        -: 3962:/*	
        -: 3963:*	for(i = 0; i< a1->dontuse; i++)
        -: 3964:*	printf("%d ",a1->excluded[i]->serial);
        -: 3965:*	printf("\n");
        -: 3966:*/
        -: 3967:/*
        -: 3968:	while(  (a2->next != a2) && (a2->next != NULL))
        -: 3969:	*/
    #####: 3970:	while(  (a2 != NULL) && (a2->next != NULL) && a2->next != a2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 3971:	{
        -: 3972:/* goto SKIP is used because this is one case where it makes sense */
        -: 3973:/*	if( a2 == a1) break;  */
    #####: 3974:	if( a2 == a1) goto SKIP;
branch  0 never executed
branch  1 never executed
    #####: 3975:	for(i = 0; i< a1->dontuse; i++)
branch  0 never executed
branch  1 never executed
    #####: 3976:		if( a2 == a1->excluded[i]) goto SKIP;
branch  0 never executed
branch  1 never executed
        -: 3977:/* non - bonded are only used when the atoms arent bonded */
        -: 3978:
    #####: 3979:	xt = (a1->x -a2->x) + lambda*(a1->dx - a2->dx);
    #####: 3980:	if( (xt > cutoff) || (xt < lcutoff) ) goto SKIP;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3981:	yt = (a1->y -a2->y) + lambda*(a1->dy - a2->dy);
    #####: 3982:	if( (yt > cutoff) || (yt < lcutoff) ) goto SKIP;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3983:	zt = (a1->z -a2->z) + lambda*(a1->dz - a2->dz);
    #####: 3984:	if( (zt > cutoff) || (zt < lcutoff) ) goto SKIP;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3985:
    #####: 3986:	r = xt*xt+yt*yt+zt*zt;
    #####: 3987:	if( r < 1.) r = 1.;  
branch  0 never executed
branch  1 never executed
        -: 3988:
    #####: 3989:	r0 = sqrt(r); r = r*r*r ;
        -: 3990:/* debugging
        -: 3991:	printf(" %d %d %f %f %f \n", a1->serial,a2->serial,a1->q,a2->q,
        -: 3992:	332.17752*a1->q*a2->q/r0);
        -: 3993:*/
    #####: 3994:	ve += dielectric*a1->q*a2->q/r0; 
    #####: 3995:	va -= a1->a*a2->a/r;
    #####: 3996:	vh += a1->b*a2->b/r/r; 
        -: 3997:
        -: 3998:SKIP:
        -: 3999:/*	if( a2->next == a1) break; */
    #####: 4000:	if( (ATOM*) a2->next == a2) break;  
branch  0 never executed
branch  1 never executed
    #####: 4001:	a2 = (ATOM*)a2->next;
        -: 4002:	}
    #####: 4003:	*V += ve + va + vh;
        -: 4004:NOTANATOM:
    #####: 4005:	i = i;
        -: 4006:	}
    #####: 4007:	return 1;
        -: 4008:
        -: 4009:}
        -: 4010:
        -: 4011:
        -: 4012:/* unonbon.c
        -: 4013:*
        -: 4014:* collection of routines to service nonbonded potentials
        -: 4015:*
        -: 4016:* POOP (Poor-mans Object Oriented Programming) using scope rules
        -: 4017:*
        -: 4018:* the routines for potential value, force and (eventually) second
        -: 4019:* derivatives are here also
        -: 4020:*
        -: 4021:* force and 2nd derivative routines assume zero'd arrays for output
        -: 4022:* this allows for parralellization if needed (on a PC?)
        -: 4023:*
        -: 4024:* forces are symmetric - so we don't have to mess around with
        -: 4025:* s matrices and the like.
        -: 4026:*
        -: 4027:* note that the non-bonded information is in the ATOM structures 
        -: 4028:*
        -: 4029:* unonbon uses a 'use list' for the interactions
        -: 4030:*
        -: 4031:*  this is physically incorrect, but often done.
        -: 4032:*  the use list is coded as
        -: 4033:*  ap ... bp's for interaction ... ap
        -: 4034:* a single array is malloc'd, it is 20 a_number() long
        -: 4035:*  the global variable (in variable storage) nbdeep will allowriding
        -: 4036:*  every nsteps ( 10 default ) will recalculate the list
        -: 4037:*  again this may be over ridden with  nbstep
        -: 4038:*  and if cutoff is not set (== 0) these routines silently call the
        -: 4039:*  regular routines which don't care about cutoff
        -: 4040:*  will always redo the list if a_number() changes
        -: 4041:*
        -: 4042:*/
        -: 4043:/*
        -: 4044:*  copyright 1992 Robert W. Harrison
        -: 4045:*  
        -: 4046:*  This notice may not be removed
        -: 4047:*  This program may be copied for scientific use
        -: 4048:*  It may not be sold for profit without explicit
        -: 4049:*  permission of the author(s) who retain any
        -: 4050:*  commercial rights including the right to modify 
        -: 4051:*  this notice
        -: 4052:*/
        -: 4053:
        -: 4054:/* ATOM structure contains a serial number for indexing into
        -: 4055:* arrays and the like (a Hessian)
        -: 4056:* but otherwise is self-contained. Note the hooks for Non-nonboned potentials
        -: 4057:*/
        -: 4058:
        -: 4059:/* uselist()
        -: 4060:*  returns a pointer to an array of ATOM structure pointers
        -: 4061:*  these are encoded as
        -: 4062:*  a,bcdsfg,a where a is the outer most atom in the N^2 -N tree.
        -: 4063:*
        -: 4064:* not over brilliant
        -: 4065:*
        -: 4066:*  checks for change in atom number
        -: 4067:*  other wise redoes the list every (nbstep (default= 10)) steps
        -: 4068:*  makes a list with total storage (nbdeep (default = 20)) time a_number
        -: 4069:*/
function _Z7uselistv called 0 returned 0% blocks executed 0%
    #####: 4070:int uselist(){
        -: 4071://Used to be: int uselist(ATOM *(*thelist)[],int *thesize, float cutoff)
        -: 4072:/* static stuff used to keep information about status */
        -: 4073:/*static int  oldatomnumber = 0;
        -: 4074:static int  since = 0,lsize;
        -: 4075:static ATOM *(*local)[];
        -: 4076:static float oldcutoff = -1;
        -: 4077:int a_number();
        -: 4078:ATOM *a_next(int),*a1,*a2,*ap,*bp;
        -: 4079:int i,j,k,max;
        -: 4080:int get_i_variable(char*),set_i_variable(char*, int);
        -: 4081:float lcutoff;
        -: 4082:float x,y,z,r,rcut;
        -: 4083:
        -: 4084:/* check on wether to redo it or not  */
        -: 4085:/*i = a_number();
        -: 4086:j = get_i_variable("nbstep");
        -: 4087:if( j <= 0) j= 10;
        -: 4088:if( (i == oldatomnumber) && (since < j) && (cutoff == oldcutoff) )
        -: 4089:{
        -: 4090:	*thelist = local;
        -: 4091:	*thesize = lsize;
        -: 4092:	since += 1;
        -: 4093:	return 1;
        -: 4094:}
        -: 4095:/* a free and malloc are used because nbdeep may change */
        -: 4096:/*RESET:
        -: 4097:/* don't free if it hasn't been malloc'd */
        -: 4098:/*if( oldatomnumber > 0) free(local);
        -: 4099:oldcutoff = cutoff;
        -: 4100:lcutoff = -cutoff;
        -: 4101:since = 0;
        -: 4102:oldatomnumber = i;
        -: 4103:j = get_i_variable("nbdeep");
        -: 4104:if( j<= 0) j = 20;
        -: 4105:max = i*j;
        -: 4106:local = (ATOM* (*)[])  malloc( max*sizeof(ATOM * ) );
        -: 4107:if( local == NULL )
        -: 4108:{ aaerror("cannot allocate uselist memory"); exit(0);}
        -: 4109:/* now have the uselist allocated */
        -: 4110:/**thelist = local;
        -: 4111:
        -: 4112:*thesize = 0;
        -: 4113:rcut = cutoff*cutoff;
        -: 4114:a1 = a_next(-1);
        -: 4115:a1 = (ATOM*) a1->next;
        -: 4116:for( i=1; i< oldatomnumber; i++,a1=ap)
        -: 4117:{
        -: 4118:	ap = (ATOM*) a1->next;
        -: 4119:	(*local)[*thesize] = a1;
        -: 4120:	*thesize += 1;
        -: 4121:	a2 = a_next(-1);
        -: 4122:	for( j=0;j<i; j++,a2=bp)
        -: 4123:	{
        -: 4124:	for(k=0; k< a1->dontuse; k++)
        -: 4125:	{
        -: 4126:		if( a2 == a1->excluded[k]) goto SKIP;
        -: 4127:	}	
        -: 4128:		if( (a2->x-a1->x) > cutoff) goto SKIP;
        -: 4129:		if( (a2->x-a1->x) < lcutoff) goto SKIP;
        -: 4130:		if( (a2->y-a1->y) > cutoff) goto SKIP;
        -: 4131:		if( (a2->y-a1->y) < lcutoff) goto SKIP;
        -: 4132:		if( (a2->z-a1->z) > cutoff) goto SKIP;
        -: 4133:		if( (a2->z-a1->z) < lcutoff) goto SKIP;
        -: 4134:/* now calculate the radius */
        -: 4135:/*	x = a2->x -a1->x;
        -: 4136:	y = a2->y -a1->y;
        -: 4137:	z = a2->z -a1->z;
        -: 4138:	r = x*x + y*y + z*z;
        -: 4139:	if( r > rcut) goto SKIP;
        -: 4140:	
        -: 4141:	(*local)[*thesize] = a2;
        -: 4142:	*thesize += 1;
        -: 4143:	if( *thesize >= max)
        -: 4144:	{aaerror("please increase nbdeep (seti nbdeep (>20);)");
        -: 4145:	 i = a_number();
        -: 4146:	 j = get_i_variable("nbdeep");
        -: 4147:	 if( j== 0) j = 20;
        -: 4148:	 if( j == i+2) 
        -: 4149:	 {aaerror("Terrible error in uselist, too many interactions");
        -: 4150:	  exit( 0) ; }
        -: 4151:	 j = 2*j; if( j > i+2) j = i+2;
        -: 4152:	 set_i_variable("nbdeep",j);
        -: 4153:	 goto RESET;
        -: 4154:	 }
        -: 4155:SKIP:
        -: 4156:	bp = a_next(1);
        -: 4157:	}
        -: 4158:	(*local)[*thesize] = a1;
        -: 4159:	*thesize += 1;
        -: 4160:	lsize = *thesize;
        -: 4161:
        -: 4162:}
        -: 4163:/*printf(" uselist finished %d %d\n",*thesize,max); */
    #####: 4164:return 1;
        -: 4165:}
        -: 4166:
        -: 4167:/* v_nonbon()
        -: 4168:* this function sums up the potentials
        -: 4169:* for the atoms defined in the nonbon data structure.
        -: 4170:*/
        -: 4171:/* standard returns 0 if error (any) 1 if ok
        -: 4172:* V is the potential */
function _Z10u_v_nonbonPff called 3 returned 100% blocks executed 83%
        3: 4173:int u_v_nonbon(float *V, float lambda)
        -: 4174:{
        -: 4175:	float r,r0,xt,yt,zt;
        -: 4176:	float lcutoff,cutoff,get_f_variable(char*);
        -: 4177:	float rdebye;
        -: 4178:	int inbond,inangle,i;
        -: 4179:	ATOM *a1,*a2,*bonded[10],*angled[10];
        -: 4180:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 4181:	ATOM *(*use)[];
        -: 4182:	int uselist();
        -: 4183://	int uselist (ATOM*(**)[],int*,float);
        -: 4184:	int nuse,used;
        -: 4185:	ATOM *cp,*bp;
        -: 4186:	int a_number(),inbuffer;
        -: 4187:	float (*buffer)[],xx,yy,zz;
        -: 4188:	int invector,atomsused,ii,jj,imax;
        -: 4189:	float (*vector)[];
        -: 4190:	ATOM *(*atms)[];
        -: 4191:	float dielectric;
        -: 4192:
        -: 4193:/* nonbonded potentials 
        -: 4194:* do a double loop starting from the first atom to the 
        -: 4195:* last 
        -: 4196:* then from the second to the last 
        -: 4197:* etc
        -: 4198:*
        -: 4199:* also check to avoid bonded and 1-3 bonded atoms
        -: 4200:*/
        3: 4201:	cutoff = get_f_variable("cutoff");
call    0 returned 100%
        3: 4202:	if( cutoff < 1.) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 4203:	{
        3: 4204:		v_nonbon( V,lambda);
call    0 returned 100%
        3: 4205:		return 1;
        -: 4206:	}
        -: 4207:/*	rdebye = cutoff/2.;
        -: 4208:	dielectric = get_f_variable("dielec");
        -: 4209:	if( dielectric < 1.) dielectric = 1.;
        -: 4210:	dielectric = 332.17752/dielectric;
        -: 4211:	if( !uselist( &use,&nuse,cutoff) )return 0;
        -: 4212:/*  get the number of atoms and allocate the memory for the array space */
        -: 4213:/*	i = a_number();
        -: 4214:	buffer = (float (*)[]) malloc( 3*i*sizeof(float) );
        -: 4215:	if( buffer == NULL) 
        -: 4216:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4217:	vector = (float (*)[]) malloc( i*sizeof(float) );
        -: 4218:	if( vector == NULL) 
        -: 4219:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4220:	atms = (ATOM* (*)[]) malloc( i*sizeof(ATOM *) );
        -: 4221:	if( atms == NULL) 
        -: 4222:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4223:
        -: 4224:
        -: 4225:	a1 = a_next(-1);
        -: 4226:	a1 = (ATOM*) a1->next;
        -: 4227:	imax = a_number();
        -: 4228:	used = 0;
        -: 4229:	for( jj=1; jj<imax; jj++,a1=bp)
        -: 4230:	{
        -: 4231:	bp = (ATOM*) a1->next;
        -: 4232:	inbuffer = 0;
        -: 4233:	if( (*use)[used] == a1) 
        -: 4234:	{ used += 1;}
        -: 4235:	else { aaerror("error in uselist - must abort"); return 0;}
        -: 4236:	while( (*use)[used] != a1)
        -: 4237:	{
        -: 4238:	  (*atms)[inbuffer++] = (*use)[used];
        -: 4239:	  used += 1;
        -: 4240:	}
        -: 4241:	used += 1;
        -: 4242:/* (*atms) now contains the list of atoms to be  done 
        -: 4243:*  there are inbuffer of them
        -: 4244:*  of course inbuffer can be zero so we must check for that
        -: 4245:*/
        -: 4246:/*	if( inbuffer > 0)
        -: 4247:	{
        -: 4248:	for( i=0; i< inbuffer; i++)
        -: 4249:	{
        -: 4250:	(*buffer)[3*i  ] = (*atms)[i]->x;
        -: 4251:	(*buffer)[3*i+1] = (*atms)[i]->y;
        -: 4252:	(*buffer)[3*i+2] = (*atms)[i]->z;
        -: 4253:	}
        -: 4254:	if( lambda != 0.)
        -: 4255:	{
        -: 4256:	for( i=0; i< inbuffer; i++)
        -: 4257:	{
        -: 4258:		(*buffer)[3*i  ] = (*atms)[i]->x +(*atms)[i]->dx*lambda;	
        -: 4259:		(*buffer)[3*i+1] = (*atms)[i]->y +(*atms)[i]->dy*lambda;	
        -: 4260:		(*buffer)[3*i+2] = (*atms)[i]->z +(*atms)[i]->dz*lambda;	
        -: 4261:	}
        -: 4262:	}
        -: 4263:	xx = a1->x + lambda*a1->dx;
        -: 4264:	yy = a1->y + lambda*a1->dy;
        -: 4265:	zz = a1->z + lambda*a1->dz;
        -: 4266:/* now for the work */
        -: 4267:/*	for( i=0;i< inbuffer; i++)
        -: 4268:	{
        -: 4269:	xt = xx - (*buffer)[3*i];
        -: 4270:	yt = yy - (*buffer)[3*i+1];
        -: 4271:	zt = zz - (*buffer)[3*i+2];
        -: 4272:	r = xt*xt+yt*yt+zt*zt;
        -: 4273:	if( r < 2.) r = 2.; 
        -: 4274:	r0 = sqrt(r); r = r*r*r ;
        -: 4275:/* the standard which follows is recursive */
        -: 4276:/*	 *V += 332.17752*a1->q*a2->q/r0; 
        -: 4277:	*V -= a1->a*a2->a/r;
        -: 4278:	*V += a1->b*a2->b/r/r; 
        -: 4279:*/
        -: 4280:/* use debye screen e(-r0/rdebye) */
        -: 4281:/*	(*vector)[i] = a1->q*(*atms)[i]->q/r0*dielectric*exp(-r0/rdebye) 
        -: 4282:		     - a1->a*(*atms)[i]->a/r
        -: 4283:		     + a1->b*(*atms)[i]->b/r/r;
        -: 4284:	}
        -: 4285:	for(i=0; i< inbuffer; i++)
        -: 4286:		*V += (*vector)[i];
        -: 4287:
        -: 4288:	} /* end of the inbuffer if check many lines ago */
        -: 4289://	}
    #####: 4290:	free( atms); free( buffer); 
    #####: 4291:	free( vector);
    #####: 4292:	return 1;
        -: 4293:
        -: 4294:}
        -: 4295:/* u_f_nonbon()
        -: 4296:*
        -: 4297:* u_f_nonbon increments the forces in the atom structures by the force
        -: 4298:* due to the nonbon components.  NOTE THE WORD increment.
        -: 4299:* the forces should first be zero'd.
        -: 4300:* if not then this code will be invalid.  THIS IS DELIBERATE.
        -: 4301:* on bigger (and better?) machines the different potential terms
        -: 4302:* may be updated at random or in parrellel, if we assume that this routine
        -: 4303:* will initialize the forces then we can't do this.
        -: 4304:*/
function _Z10u_f_nonbonf called 1002 returned 100% blocks executed 83%
     1002: 4305:int u_f_nonbon(float lambda)
        -: 4306:/*  returns 0 if error, 1 if OK */
        -: 4307:{
        -: 4308:	float r,r0,xt,yt,zt;
        -: 4309:	float lcutoff,cutoff,get_f_variable(char*);
        -: 4310:	float rdebye;
        -: 4311:	int inbond,inangle,i;
        -: 4312:	ATOM *a1,*a2,*bonded[10],*angled[10];
        -: 4313:	ATOM *a_next(int); /* returns first ATOM when called with -1 */
        -: 4314:	ATOM *(*use)[];
        -: 4315:	int uselist(); //ATOM *(**)[],int *, float),nuse,used;
        -: 4316:	ATOM *cp,*bp;
        -: 4317:	int a_number(),inbuffer;
        -: 4318:	float (*buffer)[],xx,yy,zz,k;
        -: 4319:	int invector,atomsused,ii,jj,imax;
        -: 4320:	float (*vector)[];
        -: 4321:	ATOM *(*atms)[];
        -: 4322:	float dielectric;
        -: 4323:
        -: 4324:/* nonbonded potentials 
        -: 4325:* do a double loop starting from the first atom to the 
        -: 4326:* last 
        -: 4327:* then from the second to the last 
        -: 4328:* etc
        -: 4329:*
        -: 4330:* also check to avoid bonded and 1-3 bonded atoms
        -: 4331:*/
     1002: 4332:	cutoff = get_f_variable("cutoff");
call    0 returned 100%
     1002: 4333:	if( cutoff < 1.) 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 4334:	{
     1002: 4335:		f_nonbon( lambda);
call    0 returned 100%
     1002: 4336:		return 1;
        -: 4337:	}
        -: 4338:/*	rdebye = cutoff/2.;
        -: 4339:	dielectric = get_f_variable("dielec");
        -: 4340:	if( dielectric < 1.) dielectric = 1.;
        -: 4341:	dielectric = 332.17752/dielectric;
        -: 4342:	if( !uselist( &use,&nuse,cutoff) )return 0;
        -: 4343:/*  get the number of atoms and allocate the memory for the array space */
        -: 4344:/*	i = a_number();
        -: 4345:	buffer = (float (*)[]) malloc( 3*i*sizeof(float) );
        -: 4346:	if( buffer == NULL) 
        -: 4347:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4348:	vector = (float (*)[]) malloc( 3*i*sizeof(float) );
        -: 4349:	if( vector == NULL) 
        -: 4350:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4351:	atms = (ATOM (*)[]) malloc( i*sizeof(ATOM *) );
        -: 4352:	if( atms == NULL) 
        -: 4353:	{ aaerror("cannot allocate memory in u_v_nonbon\n"); return 0;}
        -: 4354:
        -: 4355:
        -: 4356:	a1 = a_next(-1);
        -: 4357:	a1 = (ATOM*) a1->next;
        -: 4358:	imax = a_number();
        -: 4359:	used = 0;
        -: 4360:	for( jj=1; jj<imax; jj++,a1=bp)
        -: 4361:	{
        -: 4362:	bp = (ATOM*) a1->next;
        -: 4363:	inbuffer = 0;
        -: 4364:	if( (*use)[used] == a1) 
        -: 4365:	{ used += 1;}
        -: 4366:	else { aaerror("error in uselist - must abort"); return 0;}
        -: 4367:	while( (*use)[used] != a1)
        -: 4368:	{
        -: 4369:	  (*atms)[inbuffer++] = (*use)[used];
        -: 4370:	  used += 1;
        -: 4371:	}
        -: 4372:	used += 1;
        -: 4373:/* (*atms) now contains the list of atoms to be  done 
        -: 4374:*  there are inbuffer of them
        -: 4375:*  of course inbuffer can be zero so we must check for that
        -: 4376:*/
        -: 4377:/*	if( inbuffer > 0)
        -: 4378:	{
        -: 4379:	for( i=0; i< inbuffer; i++)
        -: 4380:	{
        -: 4381:	(*buffer)[3*i  ] = (*atms)[i]->x;
        -: 4382:	(*buffer)[3*i+1] = (*atms)[i]->y;
        -: 4383:	(*buffer)[3*i+2] = (*atms)[i]->z;
        -: 4384:	}
        -: 4385:	if( lambda != 0.)
        -: 4386:	{
        -: 4387:	for( i=0; i< inbuffer; i++)
        -: 4388:	{
        -: 4389:		(*buffer)[3*i  ] = (*atms)[i]->x +(*atms)[i]->dx*lambda;	
        -: 4390:		(*buffer)[3*i+1] = (*atms)[i]->y +(*atms)[i]->dy*lambda;	
        -: 4391:		(*buffer)[3*i+2] = (*atms)[i]->z +(*atms)[i]->dz*lambda;	
        -: 4392:	}
        -: 4393:	}
        -: 4394:	xx = a1->x + lambda*a1->dx;
        -: 4395:	yy = a1->y + lambda*a1->dy;
        -: 4396:	zz = a1->z + lambda*a1->dz;
        -: 4397:/* now for the work */
        -: 4398:/*	for( i=0;i< inbuffer; i++)
        -: 4399:	{
        -: 4400:	xt = xx - (*buffer)[3*i];
        -: 4401:	yt = yy - (*buffer)[3*i+1];
        -: 4402:	zt = zz - (*buffer)[3*i+2];
        -: 4403:	r = xt*xt+yt*yt+zt*zt;
        -: 4404:	 /* watch for FP errors*/
        -: 4405:/*	 if( r <= 1.)
        -: 4406:	 { r = 1.; }
        -: 4407:	r0 = sqrt(r); xt = xt/r0; yt = yt/r0; zt = zt/r0;
        -: 4408:/* use debye screen e(-r0/rdebye) */
        -: 4409:/* d/dx(e(-r0/rdebye)/r0  = e(-r0/rdebye)*(-1/rdebye)/r0 + e(-r0/rdebye)/r) */
        -: 4410:/*	 k = -a1->q*(*atms)[i]->q*dielectric*exp(-r0/rdebye)*
        -: 4411:		(1./(rdebye*r0) +1./r) ; 
        -: 4412:	r = r*r*r;
        -: 4413:	k += a1->a*(*atms)[i]->a/r/r0*6;
        -: 4414:	k -= a1->b*(*atms)[i]->b/r/r/r0*12;
        -: 4415:	(*vector)[3*i  ] = xt*k;
        -: 4416:	(*vector)[3*i+1] = yt*k;
        -: 4417:	(*vector)[3*i+2] = zt*k;
        -: 4418:/*
        -: 4419:*	a1->fx += ux*k; 
        -: 4420:*	a1->fy += uy*k; 
        -: 4421:*	a1->fz += uz*k; 
        -: 4422:*	a2->fx -= ux*k; 
        -: 4423:*	a2->fy -= uy*k; 
        -: 4424:*	a2->fz -= uz*k;
        -: 4425:*/
        -: 4426:/*	}
        -: 4427:	for(i=0; i< inbuffer; i++)
        -: 4428:	{
        -: 4429:		a1->fx -= (*vector)[3*i  ];
        -: 4430:		a1->fy -= (*vector)[3*i+1];
        -: 4431:		a1->fz -= (*vector)[3*i+2];
        -: 4432:		(*atms)[i] ->fx += (*vector)[3*i  ];
        -: 4433:		(*atms)[i] ->fy += (*vector)[3*i+1];
        -: 4434:		(*atms)[i] ->fz += (*vector)[3*i+2];
        -: 4435:	}
        -: 4436:
        -: 4437:	} /* end of the inbuffer if check many lines ago */
        -: 4438://	}
    #####: 4439:	free( atms); free( buffer); 
    #####: 4440:	free( vector);
    #####: 4441:	return 1;
        -: 4442:}
        -: 4443:
