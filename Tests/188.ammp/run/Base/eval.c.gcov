        -:    0:Source:/home/gabriel/Escritorio/SPEC_CPU2000_CD_2/benchspec/CFP2000/188.ammp/src/eval.c
        -:    0:Graph:ammp_parallel.gcno
        -:    0:Data:ammp_parallel.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:*  Stripped down version of AMMP for benchmarking
        -:    3:*
        -:    4:*  AMMP is stripped down to a minimal core of useful routines
        -:    5:*  to save time for the optimizers
        -:    6:*
        -:    7:*  bonds,angles,torsions,restrains,noels,hybrids kept
        -:    8:*  only point charge vdw
        -:    9:*  4d embedding removed
        -:   10:*  all molec. dynamics kept
        -:   11:*  cngdel,steep,gsdg kept
        -:   12:* mom kept
        -:   13:*  tailor kept
        -:   14:*  analyze kept
        -:   15:*
        -:   16:*  added box routine 
        -:   17:*  this will allow the use of fmm on big systems
        -:   18:*
        -:   19:*  benchmark only
        -:   20:*  added
        -:   21:*  signify ;  check the value of drift (setf delta)
        -:   22:*             check the value of rmsd (use tethers)
        -:   23:*             check that the ns value is set
        -:   24:*
        -:   25:*/
        -:   26:/* ammp.c
        -:   27:* Another Molecular Mechanics Program
        -:   28:*
        -:   29:*  this essentially runs the intermediate code for 
        -:   30:*  a molecular mechanics program
        -:   31:*
        -:   32:* instructions are of the form
        -:   33:*  ident <parameters> ;
        -:   34:*  # <stuff> ; is a comment
        -:   35:*   "<stuff>" is  a literal string
        -:   36:*  most instructions can be nested, but NOT loop<if> and labels 
        -:   37:*
        -:   38:*  allowed idents
        -:   39:*
        -:   40:*	atom   - atom record
        -:   41:*	bond   - bond record
        -:   42:*       morse  - morse record
        -:   43:*	angle  - angle record
        -:   44:* 	torsion - torsion record
        -:   45:*       hybrid  - hybrid (pyramid height) record
        -:   46:*	abc    - angle bond correlation record 
        -:   47:*                  i1 i2 i3 angle zero_angle  dr/da dk12/da dk23/da
        -:   48:*	av5  - tetrahedral 'volume' or centroid
        -:   49:*		i1,i2,i3,i4,i5, k, value
        -:   50:*	noel -noe distance restraint
        -:   51:*       velocity  - velocity record
        -:   52:*	read <file>  open and read from file untill done
        -:   53:*	output <file> <vers>  open and use for output file
        -:   54:*	dump <atom,bond,angle,abc,torsion,hybrid,av5,morse,pdb,variable,velocity,force> 
        -:   55:*                         write out the results
        -:   56:*	analyze ilow,ihigh  write out the errors in the current potential for atoms 
        -:   57:*				ilow to ihigh. if ilow > ihigh ilow to ilow
        -:   58:*	close  		close the current output file if not stdout
        -:   59:*	steep  niter,toler   steepest descents
        -:   60:*	bfgs  niter,toler  bfgs quasi newton 
        -:   61:*	cngdel  niter,ncut,toler  conjugate del  
        -:   62:*	trust   niter,dtoler,toler   trust optimizer
        -:   63:*       polytope imin,imax,niter,vstart,vfinal  polytope of a range
        -:   64:*	rigid imin,imax,niter, vstart,vfinal  polytope rigid body solver
        -:   65:*	echo <off>   echo to the user (turn off when dumping !!)
        -:   66:*       use  < none,bond,angle,abc,torsion,nonbon,morse,restrain,tether
        -:   67:*		,periodic,mmbond,mmangle,cangle,gauss,screen,debye,shadow,fourd
        -:   68:*		hobond hoangle trace honoel hotether image >  
        -:   69:*               flag on potentials
        -:   70:*       restrain    - restrain a distance 
        -:   71:*	tether      - tether an atom to a positon
        -:   72:*          tether serial fk x y z
        -:   73:*          tether all fk x y z  do all of them
        -:   74:*	tailor  qab   number q a b  - set the qab parameters of an atom
        -:   75:*       tailor  exclude  number number  - add an interaction to the nonbon exclude list
        -:   76:*       tailor  include number number  - delete an interaction from the nonbon exclude list
        -:   77:*	setf name value  set a float into the variable store
        -:   78:*       seti name value   set an int into the variable store
        -:   79:*       loopi label init max delta  loop to label while init < max integer vers.
        -:   80:*       loopf label init max delta  loop to label while init < max float vers.
        -:   81:*       label:    
        -:   82:*	monitor    find potential energy and kinetic energy, and calculate the forces
        -:   83:*	mon2    find potential energy and kinetic energy, and calculate the forces
        -:   84:*                 but only report the total energy
        -:   85:*       v_maxwell  temperature,dx,dy,dz
        -:   86:*	v_rescale   temperature
        -:   87:*       verlet       nstep,dtime (dtime is in m/s = .01A/ps)
        -:   88:*       pac          nstep,dtime (dtime is in m/s = .01A/ps)
        -:   89:*       tpac          nstep,dtime,Temp (dtime in m/s = .01A/ps,1fs = .00001)
        -:   90:*       ppac          nstep,dtime,pressure (dtime in m/s = .01A/ps,1fs = .00001)
        -:   91:*       ptpac          nstep,dtime,pressure,Temp (dtime in m/s = .01A/ps,1fs = .00001)
        -:   92:*       hpac          nstep,dtime,Htarget (dtime in m/s = .01A/ps,1fs = .00001)
        -:   93:*       pacpac       nstep,dtime (dtime is in m/s = .01A/ps)
        -:   94:*	doubletime   nstep,dlong,dshort,temper  double time scale dynamics
        -:   95:*	dipole first,last  calculate the dipole moment for atoms first to last
        -:   96:*                          assumes sequential atom numbers...
        -:   97:*	tgroup id serial1 serial2 serial3 serial4 base number
        -:   98:*            define a tgroup( torsion by serial numbers) base = zeropoint
        -:   99:*	     number == number of steps.  The group of atoms is everything bonded to 
        -:  100:*	      serial3 that isn't serial 2.
        -:  101:*	tsearch id id id id (up to 8  - terminated by 0 or ; ) 
        -:  102:*             search the tgroups defined
        -:  103:*
        -:  104:*       tset i1 i2 i3 i4 where
        -:  105:*            set the torsion angle defined by i1...i4 to where
        -:  106:*            unlike tgroup,tsearch only one angle at a time, and
        -:  107:*            no limit to the number of atoms rotated
        -:  108:*	tmin i1 i2 i3 i4 nstep
        -:  109:*            search the torsion angle  i1...i4 for the minimum
        -:  110:*            energy in nsteps
        -:  111:*	tmap i1 i2 i3 i4 j1 j2 j3 j4 ni nj;  map in ni nj steps
        -:  112:*              the i j atoms over all 360 degrees;
        -:  113:* 
        -:  114:* 	mompar  serial,chi,jaa  add electronegativity and self colomb to atom serial
        -:  115:*	momadd  serial serial  adds atoms to the MOM stack( can just be called with one)
        -:  116:*       mom   tq, niter   solves current mom stack for charges  
        -:  117:*			tq = total charge, niter = number of iterations (20 default)
        -:  118:*
        -:  119:*       time  return time of day and elapsed time (not on all machines)
        -:  120:*
        -:  121:*	math routines  see math.c
        -:  122:*		add a b ;
        -:  123:*		sub a b ;
        -:  124:*		mul a b;
        -:  125:*		div a b;
        -:  126:*		nop a;  these routines can work with atomic parameters 
        -:  127:*		mov a b;  variables, and imeadiate values.
        -:  128:*		max a b;
        -:  129:*		min a b;
        -:  130:*		randf a ;
        -:  131:*
        -:  132:*	  serial a i atomid;  put the serial number or residue i, atom atomid
        -:  133:*                   into a
        -:  134:*	index a i;  put the serial number of the ith atom into a;
        -:  135:*
        -:  136:*        je a b label: ;   jump a == b
        -:  137:*        jl a b label: ;   jump a < b
        -:  138:*        jg a b label: ;   jump a > b
        -:  139:*	jes a string label: ; dump to label if a->name == string
        -:  140:*	jnes a string label: ; dump to label if a->name != string
        -:  141:*           jumps are restricted to the current file
        -:  142:*
        -:  143:*	exit         - exit the routine - in case EOF is not defined
        -:  144:*
        -:  145:*  	active i1 i2; <i2 optional> active atoms i1 to i2 (default is active)
        -:  146:*       inactive i1 i2; < i2 optional> inactivate atoms i1 to i2 
        -:  147:*       nzinactive i1 i2; < i2 optional> inactivate atoms i1 to i2 that
        -:  148:*                               are not 0 0 0  
        -:  149:*
        -:  150:*
        -:  151:* 	grasp nstep nopt imin imax atom;  GRASP in torsion space
        -:  152:*	genetic nstep ndeep sigma target n_opt_steps ; genetic optimizer
        -:  153:*	gsdg  niter min_atom max_atom; iterative distance geometry bounded by
        -:  154:*                                       serial numbers
        -:  155:*	bell  niter min_atom max_atom; iterative distance geometry bounded by
        -:  156:*                                       serial numbers
        -:  157:*
        -:  158:*	dgeom niter origin shift;  standard distance geometry
        -:  159:*                             implemented with the power method
        -:  160:*                              origin is the atom to use as the key
        -:  161:*                              shift is the amount of eigenvalue shift
        -:  162:*
        -:  163:*	normal damp    ;    calculate the normal modes  if damp > 0 output them
        -:  164:*
        -:  165:*	table id n ; create empty sorted table
        -:  166:*       tableent id who r v ; add the who'th element to the table it
        -:  167:*       access with use tbond
        -:  168:*
        -:  169:* direct SCF terms
        -:  170:*       orbit <o1,o1o,o2,o3,o4s,o4p,om> i1,<i2-i5>,osn, parameters, ipair ;
        -:  171:*               ipair == 2 (doublet) ipair == 1 (singlet)
        -:  172:*       expand osn,n,a,r,a,r (up to 6)  ;
        -:  173:*                          these define an orbital
        -:  174:*
        -:  175:*       dscf <coef,expo,xyz,geom,anal> n toler;  optimize the orbitals
        -:  176:*            <coefficients, exponents, atom center, orbital geometry>;
        -:  177:*
        -:  178:*	others like fix,and... TBD
        -:  179:*   first nonblank == '#' is a comment and the line is skipped 
        -:  180:*/
        -:  181:/*
        -:  182:*  copyright 1992,1993 Robert W. Harrison
        -:  183:*  
        -:  184:*  This notice may not be removed
        -:  185:*  This program may be copied for scientific use
        -:  186:*  It may not be sold for profit without explicit
        -:  187:*  permission of the author(s) who retain any
        -:  188:*  commercial rights including the right to modify 
        -:  189:*  this notice
        -:  190:*/
        -:  191:#define ANSI 1
        -:  192:#define MAXTOKEN_EVAL 20 
        -:  193:#define TOKENLENGTH_EVAL 80 
        -:  194:/* misc includes - ANSI and some are just to be safe */
        -:  195:#include <stdio.h>
        -:  196:#include <ctype.h>
        -:  197:#include <math.h>
        -:  198:#include <string.h>
        -:  199:#include <time.h>
        -:  200:#ifdef ANSI
        -:  201:#include <stdlib.h>
        -:  202:#endif
        -:  203:#ifdef ESV
        -:  204:#define NOTIME
        -:  205:#endif
        -:  206:#ifndef NOTIME
        -:  207:#define TIME
        -:  208:#endif
        -:  209:
        -:  210://#include "ammp.h"
        -:  211:#include "tgroup.c"
        -:  212:#include "tset.c"
        -:  213:#ifdef GRACELESS
        -:  214:#include "graceless.h"
        -:  215:#endif
        -:  216:
        -:  217:/* SPEC prevent compiler warnings by adding function proto jh/9/21/99 */
        -:  218:int loadloop (FILE *, FILE *, char *);
        -:  219:
function _Z12read_eval_doP8_IO_FILES0_ called 5 returned 80% blocks executed 69%
        5:  220:void read_eval_do(FILE *ip,FILE *op)
        -:  221:{
        -:  222:char line[4096], *ap, *ap1; /* buffer and pointers for sscanf */
        -:  223:int  itemp[MAXTOKEN_EVAL];  /* integers to read */
        -:  224:float ftemp[MAXTOKEN_EVAL]; /* floats to read */
        -:  225:int inbuff;     /* where am i in the buffer */
        -:  226:int inliteral ; /* inside of a literal string */
        -:  227:int eval(FILE*, FILE*, char *);
        -:  228:/* always start outside of a literal */
        -:  229:
        5:  230:	inliteral = (1 == 0); /* portable lexpresion */
        -:  231:/* error checking */
        5:  232:	if( ip == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  233:	{
    #####:  234:		aaerror(" cannot use input file \n");
call    0 never executed
    #####:  235:		return ;
        -:  236:	}
        5:  237:	if( op == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  238:	{
    #####:  239:		aaerror(" cannot use output file \n");
call    0 never executed
    #####:  240:		return;
        -:  241:	}
        -:  242:/* lex out a line  (i.e.  <stuff> ; )
        -:  243:* filter out \n and the \; */
        5:  244:	inbuff = 0;
  7074940:  245:	while((line[inbuff]=fgetc(ip))!= (char)EOF)
call    0 returned 100%
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
        -:  246:	{/* start of the lex while */
  7074931:  247:	if( !inliteral && line[inbuff] == '"') inliteral = (1==1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  7074931:  248:	if(  inliteral && line[inbuff] == '"') inliteral = (1==0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
  7074931:  249:	if( !inliteral ){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  7074931:  250:	if( line[inbuff] == ',') line[inbuff] = ' ';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  7074931:  251:	if( line[inbuff] == '\t') line[inbuff] = ' ';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  7074931:  252:	if( line[inbuff] == '\n') line[inbuff] = ' ';
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
  7074931:  253:	if( line[inbuff] == ';')
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:  254:	{
   116258:  255:	line[inbuff] = '\0';
   116258:  256:	if(eval(ip,op,line )<0){ return;}
call    0 returned 99%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   116257:  257:	inbuff = 0;
  6958673:  258:	} else if( line[inbuff] != '\n') inbuff++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:		}/* end of inliteral */
        -:  260:	 }/* end of the lex while */
        -:  261:}/* end of routine */
        -:  262:
        -:  263:/* eval actually parses the line */
        -:  264:/* original version used sscanf *
        -:  265:*  current version lexes tokens and if numeric
        -:  266:*  converts them to integer and floating point versions
        -:  267:*/ 
        -:  268:  int  (*potentials[10])(float*, float);
        -:  269:  int (*forces[10])(float);
        -:  270:  int nused=(-1);
function _Z4evalP8_IO_FILES0_Pc called 116258 returned 99% blocks executed 44%
   116258:  271:int eval(FILE *ip, FILE *op, char *line)
        -:  272:{
        -:  273:FILE *newfile,*fopen(const char*, const char*),*tmpfile();
        -:  274:char  token[MAXTOKEN_EVAL][TOKENLENGTH_EVAL],*ap, *ap1; 
        -:  275:	/* buffer and pointers for sscanf */
        -:  276:char   errmes[80];
        -:  277:int  itemp[MAXTOKEN_EVAL],itoken,tisvariable(char*),tisint(char*);  /* integers to read */
        -:  278:float ftemp[MAXTOKEN_EVAL]; /* floats to read */
        -:  279:/*static  int  (*potentials[10])(),(*forces[10])(),nused=(-1); */
        -:  280:static  int  echo=1;  
        -:  281:static int inloop = 1;
        -:  282:
        -:  283:/* SPEC we now declare set_f_variable in ammp.h jh/9/21/99 */
        -:  284:/* int get_i_variable(),set_i_variable(),set_f_variable(); */
        -:  285:int get_i_variable(char*),set_i_variable(char*, int);
        -:  286:
        -:  287:float get_f_variable(char*);
        -:  288:int v_bond(float*, float),f_bond(float),v_angle(float*, float),f_angle(float);
        -:  289:int v_mmbond(float*, float),f_mmbond(float),v_mmangle(float*, float),f_mmangle(float);
        -:  290:int v_c_angle(float*, float), f_c_angle(float);
        -:  291:int v_periodic(float*, float),f_periodic(float);
        -:  292:int v_nonbon(float*, float),f_nonbon(float),v_torsion(float*, float),f_torsion(float);
        -:  293:int v_box(float*, float),f_box(float);
        -:  294:int u_v_nonbon(float*, float),u_f_nonbon(float);
        -:  295:int v_ho_bond(float*, float),f_ho_bond(float);
        -:  296:int v_ho_angle(float*, float),f_ho_angle(float);
        -:  297:int atom(float, float, float, int, float, float, float, float, char*),bond(int, int, float, float),angle(int, int, int, float, float),torsion(int, int,int,int,float,int,float),a_readvelocity(int, float, float, float);
        -:  298:int restrain(int, int,float, float),v_restrain(float*, float),f_restrain(float);
        -:  299:int tether(int,float,float,float,float),v_tether(float*, float),f_tether(float),alltether(float);
        -:  300:int v_ho_tether(float*, float),f_ho_tether(float);
        -:  301:int hybrid(int,int,int, int, float, float),v_hybrid(float*, float),f_hybrid(float);
        -:  302:int noel(int, int, float, float, float, float, float),v_noel(float*, float),f_noel(float);
        -:  303:int v_ho_noel(float*, float),f_ho_noel(float);
        -:  304:int math(char(*)[80],float[],int[],FILE*,FILE*,int);
        -:  305:int tset(FILE *, int, int, int, int, int, float);
        -:  306:int tmin( FILE *,int,int,int,int,int,int, int(*[])(float*, float),int);
        -:  307:#ifdef TIME
        -:  308:clock_t clock();
        -:  309:#endif
        -:  310:int significance();
        -:  311:void gsdg();
        -:  312:void analyze();
        -:  313:void AMMPmonitor(int(*[])(float*, float),int(*[])(float), int, FILE*);
        -:  314:void AMMPmonitor_mute(int(*[])(float*, float),int(*[])(float), int, FILE*);
        -:  315:void mom_add(int, int),mom(FILE*, float, int);
        -:  316:void tailor_qab();
        -:  317:void tailor_include();
        -:  318:void tailor_exclude();
        -:  319:int verlet(),v_maxwell(float, float, float, float),v_rescale(float);
        -:  320:int pac(),pacpac(), tpac(int (*[])(float), int,int,float,float),hpac(),ppac();
        -:  321:int ptpac();
        -:  322:/* default setup of potentials and forces */
   116258:  323:if( nused == -1) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  324: potentials[0] = v_bond;
        1:  325:potentials[1] = v_angle;
        1:  326:potentials[2] = u_v_nonbon;
        1:  327:potentials[3] = v_torsion;
        1:  328:potentials[4] = v_hybrid;
        1:  329:forces[0] = f_bond;
        1:  330:forces[1] = f_angle;
        1:  331:forces[2] = u_f_nonbon;
        1:  332:forces[3] = f_torsion;
        1:  333:forces[4] = f_hybrid;
        1:  334:nused = 5;
        -:  335:}
        -:  336:/* for safety and to avoid side effects the token arrays are zero'd */
  2441418:  337: 	for( itoken=0; itoken<MAXTOKEN_EVAL; itoken++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  338:	{
  2325160:  339:		token[itoken][0] = '\0';
  2325160:  340:		itemp[itoken] = 0; ftemp[itoken] = 0.;
        -:  341:	}
        -:  342:/* now extract tokens and prepare to match it */
        -:  343:
   116258:  344:	if( echo ) fprintf(op,"%s;\n",line);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   116258:  345:	ap = line;
   896251:  346:	for( itoken=0; itoken< MAXTOKEN_EVAL; itoken++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  347:	{	
   896251:  348:	ap1 = &token[itoken][0];
   896251:  349:	*ap1 = '\0';
   896251:  350:	while(*ap == ' ') ap++;
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
   896251:  351:	if( *ap == '"') { /* its a literal copy until '"' is seen */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  352:		ap++;
    #####:  353:		while( *ap != '"' && *ap != '\0')
branch  0 never executed
branch  1 never executed
        -:  354:		{
    #####:  355:			*(ap1++) = *(ap++);
        -:  356:		}
    #####:  357:		if( *ap == '"' ) ap++;
branch  0 never executed
branch  1 never executed
        -:  358:			}else {/* not literal */
   896251:  359:	if( itoken== 0 && *ap == '#') return 1;
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  6958667:  360:	while(*ap != ' ' && *ap != '\0')
branch  0 taken 87%
branch  1 taken 13% (fallthrough)
        -:  361:	{
 11441663:  362:		if( itoken == 0 ||  ( strcmp(&token[0][0],"read") != 0 &&
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
  5379247:  363:				    strcmp(&token[0][0],"output") != 0)  )
        -:  364:		{
  6062358:  365:		if( isupper(*ap))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  366:		{*ap1 = tolower(*ap); }else{ *ap1 = *ap;}
  6062358:  367:		ap1++; ap++;
        -:  368:		} else {
       58:  369:		*ap1 = *ap; ap1++; ap++; 
        -:  370:		} 
        -:  371:	}
        -:  372:			}/* end of if not literal */
   896251:  373:	*ap1 = '\0';     
        -:  374:/*  now have a list of lexed tokens */
        -:  375:/*	printf(" %d %s \n",itoken,&token[itoken][0]);  */ 
        -:  376:/* if the token is a number atof or atoi it */
   896251:  377:	ap1 = &token[itoken][0];
   896251:  378:	if( tisvariable(ap1) )
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
        -:  379:	{
        -:  380:/* printf(" %s is a variable\n",ap1);  */
        -:  381:/*  here is where the variable fetch command will go */
   256444:  382:		ftemp[itoken] = get_f_variable( ap1);
call    0 returned 100%
   256444:  383:		itemp[itoken] = get_i_variable( ap1);
call    0 returned 100%
        -:  384:		} else{
   639807:  385:		if( tisint(ap1) == 1  )
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
        -:  386:		{
        -:  387:/*		printf(" %s is an integer\n",ap1); */  
   177369:  388:		itemp[itoken] = atoi(ap1);	
   177369:  389:		ftemp[itoken] = itemp[itoken];
        -:  390:		}else{
        -:  391:/*		printf(" %s is a float\n",ap1);   */
   462438:  392:		 ftemp[itoken] = atof(ap1);	
        -:  393:/*		sscanf( ap1,"%g",&ftemp[itoken]); */
   462438:  394:		itemp[itoken] = (int)ftemp[itoken];
        -:  395:		}
        -:  396:	}
   896251:  397:	if(*ap == '\0') break;
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
        -:  398:	}
   116258:  399:	if( token[0][0]  == '\0') return 1 ;  
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  400:	/* blank lines are not an error */
        -:  401:
        -:  402:/* the block ifs are used rather than a switch to manage
        -:  403:* potential complexity of  man commands 
        -:  404:* each if done in the general pattern will have no  side
        -:  405:* effects and is therfor well phrased.
        -:  406:* needless to say common commands should be first 
        -:  407:*/ 
   116258:  408:	if( strcmp( &token[0][0], "atom" ) == 0 )
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  409:	{
    38328:  410:	if(atom( ftemp[1],ftemp[2],ftemp[3],itemp[4],ftemp[6],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    38328:  411:		ftemp[7],ftemp[8],ftemp[9],&token[5][0]) )
call    0 returned 100%
        -:  412:	{ } else { 
    #####:  413:	aaerror(" cannot add to atom structure -data structure error");
call    0 never executed
    #####:  414:			exit(0); }
call    0 never executed
        -:  415:	goto DONE;
        -:  416:	}
        -:  417:
    77930:  418:	if( strcmp( &token[0][0], "bond" ) == 0 )
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:  419:	{
     7490:  420:	if( bond(itemp[1],itemp[2],ftemp[3],ftemp[4]))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  421:	{ }else
        -:  422:	{
    #####:  423:	 aaerror(" cannot add to bond structure -data structure error"); 
call    0 never executed
    #####:  424:		exit(0); }
call    0 never executed
        -:  425:	goto DONE;
        -:  426:	}
        -:  427:
    70440:  428:	if( strcmp( &token[0][0], "restrain" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  429:	{
    #####:  430:	if( restrain(itemp[1],itemp[2],ftemp[3],ftemp[4]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  431:	{ }else
    #####:  432:	{ aaerror(" cannot add to restrain structure -data structure error"); 
call    0 never executed
    #####:  433:	exit(0);}
call    0 never executed
        -:  434:	goto DONE;
        -:  435:	}
    70440:  436:	if( strcmp( &token[0][0], "angle" ) == 0 )
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:  437:	{
     8063:  438:	ftemp[2] = 3.141592653589793/180.;
     8063:  439:	ftemp[5] = ftemp[5]*ftemp[2];
     8063:  440:	if( angle( itemp[1],itemp[2],itemp[3],ftemp[4],ftemp[5]) )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  441:	{ } else
    #####:  442:	{ aaerror(" cannot add to angle structure -data structure error"); 
call    0 never executed
    #####:  443:	exit(0);}
call    0 never executed
        -:  444:	goto DONE;
        -:  445:	}
    62377:  446:	if( strcmp( &token[0][0], "noel" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  447:	{
    #####:  448:	if( noel(itemp[1],itemp[2],ftemp[3],ftemp[4],ftemp[5],
branch  0 never executed
branch  1 never executed
    #####:  449:			ftemp[6],ftemp[7]))
call    0 never executed
        -:  450:	{ }else
        -:  451:	{
    #####:  452:	 aaerror(" cannot add to noel structure -data structure error"); 
call    0 never executed
    #####:  453:		exit(0); }
call    0 never executed
        -:  454:	goto DONE;
        -:  455:	}
        -:  456:
        -:  457:
    62377:  458:	if( strcmp( &token[0][0], "torsion" ) == 0 )
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:  459:	{
     8650:  460:	ftemp[2] = acos(-1.)/180.; ftemp[7] = ftemp[7]*ftemp[2];
     8650:  461:	if( torsion(itemp[1],itemp[2],itemp[3],itemp[4],ftemp[5],itemp[6],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     8650:  462:			ftemp[7]) )
call    0 returned 100%
        -:  463:	{ } else
    #####:  464:	{ aaerror(" cannot add to torsion structure -data structure error"); 
call    0 never executed
    #####:  465:	exit(0);}
call    0 never executed
        -:  466:	goto DONE;
        -:  467:	}
    53727:  468:	if( strcmp( &token[0][0], "hybrid" ) == 0 )
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:  469:	{
      973:  470:	if(hybrid(itemp[1],itemp[2],itemp[3],itemp[4],ftemp[5],ftemp[6]))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  471:	{ } else
    #####:  472:	{ aaerror(" cannot add to hybrid structure -data structure error"); 
call    0 never executed
    #####:  473:	exit(0);}
call    0 never executed
        -:  474:	goto DONE;
        -:  475:	}
        -:  476:
        -:  477:
        -:  478:
        -:  479:
        -:  480:
    52754:  481:	if( strcmp( &token[0][0], "velocity" ) == 0 )
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  482:	{
    38328:  483:	if( a_readvelocity(itemp[1],ftemp[2],ftemp[3],ftemp[4]) )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  484:	{ } else
    #####:  485:	{ aaerror(" cannot update velocity -is this atom defined? "); 
call    0 never executed
    #####:  486:	exit(0);}
call    0 never executed
        -:  487:	goto DONE;
        -:  488:	}
    14426:  489:	if( strcmp( &token[0][0], "tether" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  490:	{
    #####:  491:	if( strcmp( &token[1][0], "all") == 0 )
branch  0 never executed
branch  1 never executed
        -:  492:	{
    #####:  493:		if( alltether( ftemp[2] ) )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:		{} else
    #####:  495:		{ aaerror(" cannot add to tether structure -data structure error"); 
call    0 never executed
    #####:  496:		exit(0);}
call    0 never executed
        -:  497:	}else
        -:  498:	{
    #####:  499:		if( tether( itemp[1],ftemp[2],ftemp[3],ftemp[4],ftemp[5]) )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  500:		{ } else
    #####:  501:		{ aaerror(" cannot add to tether structure -data structure error"); 
call    0 never executed
    #####:  502:	exit(0);}
call    0 never executed
        -:  503:	}
        -:  504:	goto DONE;
        -:  505:	}
        -:  506:
    14426:  507:	if( strcmp( &token[0][0],"tgroup") == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  508:	{
    #####:  509:	tgroup( itemp[1],itemp[2],itemp[3],itemp[4],itemp[5],ftemp[6],itemp[7]);
call    0 never executed
    #####:  510:	goto DONE ;
        -:  511:	} 
        -:  512:
    14426:  513:	if( strcmp( &token[0][0],"tsearch") == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  514:	{
    #####:  515:	tsearch( itemp[1],itemp[2],itemp[3],itemp[4],itemp[5],itemp[6],itemp[7],itemp[8]);
call    0 never executed
    #####:  516:	goto DONE ;
        -:  517:	} 
    14426:  518:	if( strcmp( &token[0][0],"tset") == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  519:	{
    #####:  520:	tset(op,echo,itemp[1],itemp[2],itemp[3],itemp[4],ftemp[5]*3.141592653589793/180.);
call    0 never executed
    #####:  521:	goto DONE ;
        -:  522:	}
    14426:  523:	if( strcmp( &token[0][0],"tmin") == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  524:	{
    #####:  525:	tmin( op,echo,itemp[1],itemp[2],itemp[3],itemp[4],itemp[5],potentials,nused);
call    0 never executed
    #####:  526:	goto DONE ;
        -:  527:	}
    14426:  528:	if( strcmp( &token[0][0],"tmap") == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:	{
    #####:  530:	tmap( op,echo,potentials,nused, itemp[1],itemp[2],itemp[3],itemp[4],itemp[5],itemp[6],itemp[7],itemp[8],itemp[9],itemp[10]);
call    0 never executed
    #####:  531:	goto DONE ;
        -:  532:	}
        -:  533:
    14426:  534:	if( strcmp( &token[0][0], "mompar" )== 0)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  535:	{
    14400:  536:	mom_param( itemp[1],ftemp[2],ftemp[3] );
call    0 returned 100%
    14400:  537:	goto DONE;
        -:  538:	}
       26:  539:	if( strcmp( &token[0][0], "momadd" )== 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  540:	{
    #####:  541:	mom_add( itemp[1],itemp[2] );
call    0 never executed
    #####:  542:	goto DONE;
        -:  543:	}
       26:  544:	if( strcmp( &token[0][0], "mom" )== 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  545:	{
    #####:  546:	mom( op,ftemp[1],itemp[2] );
call    0 never executed
    #####:  547:	goto DONE;
        -:  548:	}
       26:  549:	if( strcmp( &token[0][0], "monitor" )== 0)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  550:	{
        3:  551:	AMMPmonitor( potentials,forces,nused,op );
call    0 returned 100%
        3:  552:	goto DONE;
        -:  553:	}
       23:  554:	if( strcmp( &token[0][0], "mon2" )== 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  555:	{
    #####:  556:	AMMPmonitor_mute( potentials,forces,nused,op );
call    0 never executed
    #####:  557:	goto DONE;
        -:  558:	}
       23:  559:	if( strcmp( &token[0][0], "nzinactive" ) == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  560:	{
        -:  561:	//inactivate_non_zero( itemp[1],itemp[2]);
        -:  562:	goto DONE;
        -:  563:	}
       23:  564:	if( strcmp( &token[0][0], "inactive" ) == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  565:	{
        -:  566:	//inactivate( itemp[1],itemp[2]);
        -:  567:	goto DONE;
        -:  568:	}
       23:  569:	if( strcmp( &token[0][0], "active" ) == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  570:	{
        -:  571:	//activate( itemp[1],itemp[2]);
        -:  572:	goto DONE;
        -:  573:	}
       23:  574:	if( strcmp( &token[0][0],"signify") ==0 )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  575:	{
        -:  576:	//significance(op);
        -:  577:	goto DONE;
        -:  578:	}
       23:  579:	if( strcmp( &token[0][0], "analyze" )== 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  580:	{
        -:  581:	//analyze( potentials,nused,itemp[1],itemp[2],op );
        -:  582:	goto DONE;
        -:  583:	}
       23:  584:	if( strcmp(&token[0][0] , "tailor" ) == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  585:	{
    #####:  586:		if( strcmp(&token[1][0], "qab") == 0 )
branch  0 never executed
branch  1 never executed
        -:  587:		{
        -:  588:	//	tailor_qab( itemp[2], ftemp[3],ftemp[4],ftemp[5]);
        -:  589:		goto DONE;
        -:  590:		}
    #####:  591:		if( strcmp(&token[1][0], "include") == 0 )
branch  0 never executed
branch  1 never executed
        -:  592:		{
        -:  593:	//	tailor_include( itemp[2],itemp[3]);
        -:  594:		goto DONE;
        -:  595:		}
    #####:  596:		if( strcmp(&token[1][0], "exclude") == 0 )
branch  0 never executed
branch  1 never executed
        -:  597:		{
        -:  598:	//	tailor_exclude( itemp[2],itemp[3]);
        -:  599:		goto DONE;
        -:  600:		}
    #####:  601:	aaerror(" undefined tailor option "); aaerror(&token[1][0]); 
call    0 never executed
call    1 never executed
    #####:  602:	goto DONE;
        -:  603:	}
        -:  604:
       23:  605:	if( strcmp( &token[0][0], "read" ) == 0 )
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  606:	{
        4:  607:	newfile = fopen( &token[1][0],"r");
call    0 returned 100%
        4:  608:	if( newfile == NULL )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  609:	{ aaerror(" cannot open file for read "); aaerror(&token[1][0]); }
call    0 never executed
call    1 never executed
        -:  610:	 else
        4:  611:	{ read_eval_do(newfile,op); fclose(newfile); }
call    0 returned 100%
call    1 returned 100%
        -:  612:	goto DONE;
        -:  613:	}
       19:  614:	if( strcmp( &token[0][0], "output" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  615:	{
        -:  616:/* if a non-zero version then write it out */
    #####:  617:	if( itemp[2] > 0) 
branch  0 never executed
branch  1 never executed
        -:  618:	{
    #####:  619:	sprintf( errmes,"%s.%d",&token[1][0],itemp[2]);
    #####:  620:	newfile = fopen( errmes,"w");
call    0 never executed
        -:  621:	} else {
    #####:  622:	newfile = fopen( &token[1][0],"w");
call    0 never executed
        -:  623:	}
    #####:  624:	if( newfile == NULL )
branch  0 never executed
branch  1 never executed
    #####:  625:	{ aaerror(" cannot open file for write "); aaerror(&token[1][0]); } 
call    0 never executed
call    1 never executed
        -:  626:	else
    #####:  627:	{ read_eval_do(ip,newfile); }
call    0 never executed
        -:  628:	goto DONE;
        -:  629:	}
       19:  630:	if( strcmp( &token[0][0], "dump" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  631:	{
    #####:  632:	for( itoken=1; itoken<MAXTOKEN_EVAL; itoken++)
branch  0 never executed
branch  1 never executed
    #####:  633:	{if( token[itoken][0] == '\0') goto DONE;
branch  0 never executed
branch  1 never executed
    #####:  634:	if( strcmp(&token[itoken][0],"atom") == 0) dump_atoms( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  635:	if( strcmp(&token[itoken][0],"bond") == 0) dump_bonds( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  636:	if( strcmp(&token[itoken][0],"noel") == 0) dump_noels( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  637:	if( strcmp(&token[itoken][0],"angle") == 0) dump_angles( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  638:	if( strcmp(&token[itoken][0],"torsion") == 0) dump_torsions( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  639:	if( strcmp(&token[itoken][0],"hybrid") == 0) dump_hybrids( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  640:	if( strcmp(&token[itoken][0],"restrain") == 0) dump_restrains( op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  641:	if( strcmp(&token[itoken][0],"pdb") == 0) dump_pdb( op,100);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  642:	if( strcmp(&token[itoken][0],"variable") == 0) dump_variable(op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  643:	if( strcmp(&token[itoken][0],"velocity") == 0) dump_velocity(op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  644:	if( strcmp(&token[itoken][0],"force") == 0) dump_force(op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  645:	if( strcmp(&token[itoken][0],"tether") == 0) dump_tethers(op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  646:	if( strcmp(&token[itoken][0],"tgroup") == 0) dump_tgroup(op);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  647:	}
        -:  648:	goto DONE;
        -:  649:	}
       19:  650:	if( strcmp( &token[0][0], "use" ) == 0 )
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        -:  651:	{
        8:  652:	for( itoken=1; itoken<MAXTOKEN_EVAL; itoken++)
branch  0 taken 100%
branch  1 taken 0%
        -:  653:	{
        8:  654:	if( token[itoken][0] == '\0') goto DONE;
branch  0 taken 88% (fallthrough)
branch  1 taken 13%
        7:  655:	if( strcmp(&token[itoken][0],"none") == 0) nused = 0;
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        7:  656:	if( strcmp(&token[itoken][0],"nonbon") == 0)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  657:	{forces[nused] = u_f_nonbon; potentials[nused++] = u_v_nonbon;} 
        7:  658:	if( strcmp(&token[itoken][0],"bond") == 0) 
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  659:	{forces[nused] = f_bond; potentials[nused++] = v_bond;} 
        7:  660:	if( strcmp(&token[itoken][0],"mmbond") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  661:	{forces[nused] = f_mmbond; potentials[nused++] = v_mmbond;} 
        7:  662:	if( strcmp(&token[itoken][0],"hobond") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  663:	{forces[nused] = f_ho_bond; potentials[nused++] = v_ho_bond;} 
        7:  664:	if( strcmp(&token[itoken][0],"tether") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  665:	{forces[nused] = f_tether; potentials[nused++] = v_tether;} 
        7:  666:	if( strcmp(&token[itoken][0],"hotether") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  667:	{forces[nused] = f_ho_tether; potentials[nused++] = v_ho_tether;} 
        7:  668:	if( strcmp(&token[itoken][0],"restrain") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  669:	{forces[nused] = f_restrain; potentials[nused++] = v_restrain;} 
        7:  670:	if( strcmp(&token[itoken][0],"angle") == 0) 
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  671:	{forces[nused] = f_angle; potentials[nused++] = v_angle;} 
        7:  672:	if( strcmp(&token[itoken][0],"hoangle") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  673:	{forces[nused] = f_ho_angle; potentials[nused++] = v_ho_angle;} 
        7:  674:	if( strcmp(&token[itoken][0],"mmangle") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  675:	{forces[nused] = f_mmangle; potentials[nused++] = v_mmangle;} 
        7:  676:	if( strcmp(&token[itoken][0],"cangle") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  677:	{forces[nused] = f_c_angle; potentials[nused++] = v_c_angle;} 
        7:  678:	if( strcmp(&token[itoken][0],"torsion") == 0) 
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  679:	{forces[nused] = f_torsion; potentials[nused++] = v_torsion;} 
        7:  680:	if( strcmp(&token[itoken][0],"hybrid") == 0) 
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  681:	{forces[nused] = f_hybrid; potentials[nused++] = v_hybrid;} 
        7:  682:	if( strcmp(&token[itoken][0],"honoel") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  683:	{forces[nused] = f_ho_noel; potentials[nused++] = v_ho_noel;} 
        7:  684:	if( strcmp(&token[itoken][0],"noel") == 0) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  685:	{forces[nused] = f_noel; potentials[nused++] = v_noel;} 
        7:  686:	if( strcmp(&token[itoken][0],"box") == 0) 
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:  687:	{forces[nused] = f_box; potentials[nused++] = v_box;} 
        -:  688:	}
        -:  689:	goto DONE;
        -:  690:	}
       18:  691:	if( strcmp( &token[0][0], "close" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  692:	{
    #####:  693:		if( op != stdout )
branch  0 never executed
branch  1 never executed
        -:  694:		{
    #####:  695:		fclose(op);
call    0 never executed
    #####:  696:		return -1;
        -:  697:		}   goto DONE;
        -:  698:	}
       18:  699:	if( strcmp( &token[0][0], "seti" ) == 0 )
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  700:	{
        1:  701:	if( token[1][0] == '\0') 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  702:		{aaerror("seti requires a variable name: seti <name> value");
call    0 never executed
    #####:  703:		goto DONE;
        -:  704:		}
        1:  705:	set_i_variable( &token[1][0], itemp[2]);
call    0 returned 100%
        1:  706:	goto DONE;	
        -:  707:	}
       17:  708:	if( strcmp( &token[0][0], "setf" ) == 0 )
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  709:	{
        4:  710:	if( token[1][0] == '\0') 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  711:		{aaerror("setf requires a variable name: setf <name> value");
call    0 never executed
    #####:  712:		goto DONE;
        -:  713:		}
        4:  714:	set_f_variable( &token[1][0], ftemp[2]);
call    0 returned 100%
        4:  715:	goto DONE;	
        -:  716:	}
       13:  717:	if( math( token,ftemp,itemp,ip,op,echo ) > 0 ) goto DONE;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  718:
       13:  719:	if( strcmp( &token[0][0], "v_maxwell") == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  720:	{
    #####:  721:	v_maxwell( ftemp[1],ftemp[2],ftemp[3],ftemp[4]);
call    0 never executed
    #####:  722:	goto DONE;
        -:  723:	}
       13:  724:	if( strcmp( &token[0][0], "v_rescale") == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  725:	{
    #####:  726:	v_rescale( ftemp[1]);
call    0 never executed
    #####:  727:	goto DONE;
        -:  728:	}
       13:  729:	if( strcmp( &token[0][0], "verlet") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  730:	{
        -:  731:	//verlet( forces,nused, itemp[1],ftemp[2]);
        -:  732:	goto DONE;
        -:  733:	}
       13:  734:	if( strcmp( &token[0][0], "pac") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  735:	{
        -:  736://	pac( forces,nused, itemp[1],ftemp[2]);
        -:  737:	goto DONE;
        -:  738:	}
       13:  739:	if( strcmp( &token[0][0], "tpac") == 0)
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        -:  740:	{
        3:  741:	tpac(forces,nused, itemp[1],ftemp[2],ftemp[3]);
call    0 returned 100%
        3:  742:	goto DONE;
        -:  743:	}
       10:  744:	if( strcmp( &token[0][0], "ppac") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  745:	{
        -:  746://	ppac( forces,nused, itemp[1],ftemp[2],ftemp[3]);
        -:  747:	goto DONE;
        -:  748:	}
       10:  749:	if( strcmp( &token[0][0], "ptpac") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  750:	{
        -:  751://	ptpac( forces,nused, itemp[1],ftemp[2],ftemp[3],ftemp[4]);
        -:  752:	goto DONE;
        -:  753:	}
       10:  754:	if( strcmp( &token[0][0], "hpac") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  755:	{
        -:  756://	hpac( forces,potentials,nused, itemp[1],ftemp[2],ftemp[3]);
        -:  757:	goto DONE;
        -:  758:	}
       10:  759:	if( strcmp( &token[0][0], "pacpac") == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  760:	{
        -:  761://	pacpac( forces,nused, itemp[1],ftemp[2]);
        -:  762:	goto DONE;
        -:  763:	}
       10:  764:	if( strcmp( &token[0][0], "steep" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  765:	{
    #####:  766:	if( nused <= 0) goto DONE;
        -:  767:	//steep( potentials,forces,nused,itemp[1],ftemp[2]);
        -:  768:	goto DONE;
        -:  769:	}
        -:  770:
       10:  771:	if( strcmp( &token[0][0], "gsdg" ) == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  772:	{
    #####:  773:	if( nused <= 0) goto DONE;
        -:  774:	//gsdg( potentials,nused,itemp[1],itemp[2],itemp[3]);
        -:  775:	goto DONE;
        -:  776:	}
       10:  777:	if( strcmp( &token[0][0], "cngdel" ) == 0 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  778:	{
    #####:  779:	if( nused <= 0) goto DONE;
        -:  780://	cngdel( potentials,forces,nused,itemp[1],itemp[2],ftemp[3],echo);
        -:  781:	goto DONE;
        -:  782:	}
        -:  783:#ifdef TIME 
       10:  784:	if( strcmp( &token[0][0],"time") == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  785:	{
    #####:  786:	fprintf( op," %f CPU \n",((float)clock())/CLOCKS_PER_SEC); 
call    0 never executed
        -:  787:	goto DONE;
        -:  788:	}
        -:  789:#endif
       10:  790:	if( strcmp( &token[0][0],"echo" ) == 0)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
        -:  791:	{
        9:  792:	echo = 1;
        9:  793:	if( strcmp( &token[1][0],"off") == 0) echo = 0;
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
        -:  794:	goto DONE;
        -:  795:	}
        1:  796:	if( strcmp( &token[0][0],"exit") ==0 ) exit(0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 0%
        -:  797:/* looping stuff */
    #####:  798:	if( strcmp( &token[0][0],"loopi")  == 0)
branch  0 never executed
branch  1 never executed
        -:  799:	{
    #####:  800:	if( token[1][0] == '\0') 
branch  0 never executed
branch  1 never executed
    #####:  801:	{ aaerror(" must have a label to loop to "); goto DONE;}
call    0 never executed
    #####:  802:	if( itemp[4] == 0) itemp[4] = 1;  /* must loop  */
branch  0 never executed
branch  1 never executed
    #####:  803:	newfile = tmpfile();	
call    0 never executed
    #####:  804:	if( newfile == NULL )
branch  0 never executed
branch  1 never executed
    #####:  805:	{ aaerror(" cannot open temporary file in loopi"); goto DONE; }
call    0 never executed
        -:  806:/* scan the input data until the label is found */ 
    #####:  807:	loadloop( ip,newfile, &token[1][0]);
call    0 never executed
        -:  808:/*  now do the loop */
    #####:  809:	if( itemp[4] > 0)
branch  0 never executed
branch  1 never executed
        -:  810:	{
    #####:  811:	for( itemp[0] = itemp[2];itemp[0]< itemp[3];itemp[0]+=itemp[4])
branch  0 never executed
branch  1 never executed
        -:  812:	{
    #####:  813:	inloop = -1;
    #####:  814:	if( tisvariable(&token[2][0])) 
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  815:	set_i_variable( &token[2][0], itemp[0]);
call    0 never executed
    #####:  816:	rewind( newfile );
call    0 never executed
    #####:  817:	 read_eval_do(newfile,op); 
call    0 never executed
        -:  818:	}
        -:  819:	} else{
    #####:  820:	for( itemp[0] = itemp[2];itemp[0]< itemp[3];itemp[0]+=itemp[4])
branch  0 never executed
branch  1 never executed
        -:  821:	{
    #####:  822:	inloop = -1;
    #####:  823:	if( tisvariable(&token[2][0])) 
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  824:	set_i_variable( &token[2][0], itemp[0]);
call    0 never executed
    #####:  825:	rewind( newfile );
call    0 never executed
    #####:  826:	 read_eval_do(newfile,op); 
call    0 never executed
        -:  827:	}
        -:  828:	}
    #####:  829:	inloop = 1;
    #####:  830:	fclose( newfile);
call    0 never executed
    #####:  831:	goto DONE;
        -:  832:	}
    #####:  833:	if( strcmp( &token[0][0],"loopf")  == 0)
branch  0 never executed
branch  1 never executed
        -:  834:	{
    #####:  835:	if( token[1][0] == '\0') 
branch  0 never executed
branch  1 never executed
    #####:  836:	{ aaerror(" must have a label to loop to "); goto DONE;}
call    0 never executed
    #####:  837:	if( ftemp[4] == 0.) ftemp[4] = 1.;  /* must loop  */
branch  0 never executed
branch  1 never executed
    #####:  838:	newfile = tmpfile();	
call    0 never executed
    #####:  839:	if( newfile == NULL )
branch  0 never executed
branch  1 never executed
    #####:  840:	{ aaerror(" cannot open temporary file in loopi"); goto DONE; }
call    0 never executed
        -:  841:/* scan the input data until the label is found */ 
    #####:  842:	loadloop( ip,newfile, &token[1][0]);
call    0 never executed
        -:  843:/*  now do the loop */
    #####:  844:	if( ftemp[4] > 0.)
branch  0 never executed
branch  1 never executed
        -:  845:	{
    #####:  846:	for( ftemp[0] = ftemp[2];ftemp[0]< ftemp[3];ftemp[0]+=ftemp[4])
branch  0 never executed
branch  1 never executed
        -:  847:	{
    #####:  848:	inloop = -1;
    #####:  849:	if( tisvariable(&token[2][0])) 
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  850:	set_f_variable( &token[2][0], ftemp[0]);
call    0 never executed
    #####:  851:	rewind( newfile );
call    0 never executed
    #####:  852:	 read_eval_do(newfile,op); 
call    0 never executed
        -:  853:	}
        -:  854:	} else  {
    #####:  855:	for( ftemp[0] = ftemp[2];ftemp[0]> ftemp[3];ftemp[0]+=ftemp[4])
branch  0 never executed
branch  1 never executed
        -:  856:	{
    #####:  857:	inloop = -1;
    #####:  858:	if( tisvariable(&token[2][0])) 
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  859:	set_f_variable( &token[2][0], ftemp[0]);
call    0 never executed
    #####:  860:	rewind( newfile );
call    0 never executed
    #####:  861:	 read_eval_do(newfile,op); 
call    0 never executed
        -:  862:	}
        -:  863:	}
    #####:  864:	inloop = 1;
    #####:  865:	goto DONE;
        -:  866:	}
        -:  867:/* check if its a label  and return */
        -:  868:/* inloop returns -1 if in a loop which causes read_eval_do() to 
        -:  869:*  return and activates the loop routine */
    #####:  870:	for( itemp[0]=0; itemp[0] < TOKENLENGTH; itemp[0]++)
branch  0 never executed
branch  1 never executed
        -:  871:	{
    #####:  872:	if( token[0][itemp[0]] == '\0' || token[0][itemp[0]] == ' ')
branch  0 never executed
branch  1 never executed
        -:  873:	{
    #####:  874:	 if( itemp[0] == 0) break;
branch  0 never executed
branch  1 never executed
    #####:  875:	 if( token[0][itemp[0]-1] == ':') return inloop;
branch  0 never executed
branch  1 never executed
        -:  876:	}
        -:  877:	}
        -:  878:/*  default unrecognized token */
        -:  879:	sprintf(&errmes[0]," unrecognized token >%s<",&token[0][0]);
    #####:  880:	aaerror( errmes );
call    0 never executed
        -:  881:DONE:
   116257:  882:	return 1;
        -:  883:}
        -:  884:/* aaerror is a general error call function */
        -:  885:/* SPEC make this a void, since no one seems to use it jh/9/21/99 */
function _Z7aaerrorPc called 0 returned 0% blocks executed 0%
    #####:  886:void aaerror( char *line )
        -:  887:{
    #####:  888:	fprintf(stderr ,"%s \n",line);
        -:  889:	return ;
        -:  890:}
        -:  891:/* function tisvariable( char *p )
        -:  892:*
        -:  893:* returns 1 if the character string contains anything other than
        -:  894:* <+-><0-9>.<0-9><e><+-><0-9> 
        -:  895:* works on a tolowered string !!
        -:  896:*/
function _Z11tisvariablePc called 896251 returned 100% blocks executed 76%
   896251:  897:int tisvariable(char *p)
        -:  898:{
   896251:  899:	if( (*p != '+')&&(*p != '-')&& !(isdigit( (int) *p)) &&(*p != '.') )
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 32% (fallthrough)
branch  3 taken 68%
branch  4 taken 99% (fallthrough)
branch  5 taken 1%
branch  6 taken 29% (fallthrough)
branch  7 taken 71%
   256444:  900:	 return 1;
        -:  901:/* now for the rest we check until either '\0' or not a digit */
   639807:  902:	p++;
   639807:  903:	while( (*p != '\0') && (isdigit( (int) *p) ) ) p++;
branch  0 taken 66%
branch  1 taken 34% (fallthrough)
   639807:  904:	if( *p == '\0') return 0;
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
   462435:  905:	if( (*p != '.') && (*p != 'e') ) return 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   462435:  906:	p++;
   462435:  907:	if( !(isdigit( (int) *p)) ){
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  908:	if( *p == '\0' ) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  909:	if( (*p != '.') && (*p != 'e') ) return 1;
branch  0 never executed
branch  1 never executed
    #####:  910:	p++;
        -:  911:		}
   462433:  912:	if( *p == '\0') return 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   462433:  913:	if( (*p != '+')&&(*p != '-')&& !(isdigit( (int) *p)) &&(*p != '.') )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####:  914:	 return 1;
   462433:  915:	p++;
   462433:  916:	if( *p == '\0') return 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  2312161:  917:	while( (*p != '\0') && ((isdigit( (int) *p))||(*p=='.')) ) p++;
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 83%
branch  5 taken 17% (fallthrough)
   462433:  918:	if( *p == '\0') return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  919:	return 1;
        -:  920:}
        -:  921:/* function tisint( char *p )
        -:  922:*
        -:  923:* check that a string is <+-><0-9>
        -:  924:* return 1 if true
        -:  925:* return 0 if not
        -:  926:*/
function _Z6tisintPc called 639830 returned 100% blocks executed 94%
   639830:  927:int tisint(char *p)
        -:  928:{
        -:  929:	char *pp;
   639830:  930:	pp = p;
  3186512:  931:	while( *pp != '\0') 
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
  2369293:  932:	{ if( *pp == '.') return 0; pp++;}
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
   177389:  933:	if( (*p != '+')&&(*p != '-')&& !(isdigit( (int) *p)) ) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
   177369:  934:	p++;
  1037102:  935:	while (*p != '\0')
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -:  936:	{
   682364:  937:		if( !(isdigit( (int) *p )) ) return 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   682364:  938:		p++;
        -:  939:	}
   177369:  940:	return 1;
        -:  941:}
        -:  942:
        -:  943:/* routine loadloop( FILE *ip, FILE *tp, char *label)
        -:  944:*
        -:  945:* read lines from ip and write to tp
        -:  946:* when the line begins with label  stop (after writing it )
        -:  947:*/
        -:  948:/* SPEC use modern-style arg declaration, to match proto jh/9/22/99 */
function _Z8loadloopP8_IO_FILES0_Pc called 0 returned 0% blocks executed 0%
    #####:  949:int loadloop( FILE *ip, FILE *tp,  char *label)
        -:  950:{
        -:  951:	char line[256], *fgets(char[], int, FILE*) ;
        -:  952:	char *sp,*wp;
        -:  953:	
        -:  954:/*	printf( " the target label >%s<\n" , label);
        -:  955:*/
    #####:  956:	while( fgets(  line,256,ip) != NULL )
branch  0 never executed
branch  1 never executed
        -:  957:	{
    #####:  958:	fputs( line,tp );
call    0 never executed
    #####:  959:	fputs("\n",tp);
call    0 never executed
    #####:  960:	sp = line;
    #####:  961:	while( *sp == ' ' && *sp != '\0') sp++;
branch  0 never executed
branch  1 never executed
    #####:  962:	if( *sp != '\0' )
branch  0 never executed
branch  1 never executed
        -:  963:		{
    #####:  964:		wp = sp;
    #####:  965:		while(*wp != ';' && *wp != ' ' && *wp != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  966:			{ if( isupper(*wp)){*wp = (char)tolower((int)*wp);} 
branch  0 never executed
branch  1 never executed
    #####:  967:			 wp++;}
    #####:  968:	if( *wp == ' ' ) *wp = '\0'; 
branch  0 never executed
branch  1 never executed
    #####:  969:	if( *wp == ';' ) *wp = '\0'; 
branch  0 never executed
branch  1 never executed
        -:  970:        /* SPEC - add a "1" here to remove warnings, but I don't think */
        -:  971:        /*        any callers actually look at this return value       */
        -:  972:        /*        - j.henning 21-sep-99                                */
    #####:  973:		if( strcmp(sp,label) == 0 ) return 1; 
branch  0 never executed
branch  1 never executed
        -:  974:		}
        -:  975:	}
    #####:  976:	aaerror(" must have a label for looping ");
call    0 never executed
        -:  977:	sprintf(line," where is >%s< label ?\n",label);
    #####:  978:	aaerror( line );
call    0 never executed
    #####:  979:	return 0;
        -:  980:}
